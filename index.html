<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>SLEEEEP · Tall Grass Maze (Popup · Safe Mode)</title>
<meta name="theme-color" content="#000000">
<style>
  :root{ --fg:#fff; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#000;color:var(--fg);
    font-family:ui-serif,Georgia,"Times New Roman",serif}

  /* 바탕 검정 + 중앙 팝업 */
  #desk{position:relative;width:100vw;height:100vh;overflow:hidden}
  .gameWin{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:960px;height:540px;background:#000; /* 팝업 고정크기 */
    box-shadow:0 24px 60px rgba(0,0,0,.75),0 0 0 1px rgba(255,255,255,.08);
    overflow:hidden;
  }

  /* 캔버스: 팝업 안에 꽉 채움(정수배 스케일 아님, 안전 모드) */
  #view{position:absolute;inset:0;width:100%;height:100%;
    image-rendering:pixelated;image-rendering:crisp-edges;background:#000}

  /* 텍스트 버튼(박스 없음) */
  .tbtn{position:absolute;background:transparent;border:none;color:#fff;
    font:800 14px/1 ui-serif,Georgia,"Times New Roman",serif;letter-spacing:.02em;
    text-shadow:0 1px 0 #000a;cursor:pointer;user-select:none}
  #btnMap{left:10px;top:10px}
  #btnInv{right:10px;top:10px}
  #btnDialog{right:10px;bottom:10px}

  /* 투명 D-pad */
  .dpad{position:absolute;left:10px;bottom:10px;width:150px;height:150px;
    display:none;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:6px;z-index:3}
  .dpad .cell{display:grid;place-items:center}
  .key{background:transparent;border:none;color:#fff;font:800 18px ui-serif,Georgia,"Times New Roman",serif;cursor:pointer}
  .key:active{transform:scale(.95)}
  @media (pointer:coarse){ .dpad{display:grid} }

  /* 오류 배너 */
  #err{position:absolute;left:0;right:0;top:0;background:#b00020;color:#fff;
    font:700 12px/1.3 ui-serif;padding:8px 12px;display:none;z-index:9}
</style>
</head>
<body>
<div id="desk">
  <div class="gameWin" id="gameWin">
    <div id="err"></div>
    <canvas id="view" width="960" height="540"></canvas>

    <button id="btnMap" class="tbtn">MAP</button>
    <button id="btnInv" class="tbtn">INVENTORY</button>
    <button id="btnDialog" class="tbtn">Dialogue</button>

    <div id="dpad" class="dpad" aria-hidden="false">
      <div class="cell"></div><div class="cell"><button class="key" data-dir="up">↑</button></div><div class="cell"></div>
      <div class="cell"><button class="key" data-dir="left">←</button></div><div class="cell"></div><div class="cell"><button class="key" data-dir="right">→</button></div>
      <div class="cell"></div><div class="cell"><button class="key" data-dir="down">↓</button></div><div class="cell"></div>
    </div>
  </div>
</div>

<script>
(function(){
  const err = document.getElementById('err');
  function showErr(e){ err.textContent = 'ERROR: '+ e; err.style.display='block'; }

  try{
    const cv = document.getElementById('view');
    const g  = cv.getContext('2d',{alpha:false});
    if(!g) throw 'Canvas 2D context unavailable';
    g.imageSmoothingEnabled = false;

    // ===== 기본 팔레트
    const C={
      path:'#1e1e1e',
      ground:'#000',
      tuftDark:'#0b140d', tuftMid:'#1f2e20', tuftHi:'#3b553a',
      actor:'#f0e0bf', actorEdge:'#1a1a1a', actorHead:'#ffe8c9'
    };

    // ===== 타일/미로
    const W=cv.width, H=cv.height;
    const TILE=20;
    const COLS=(W/TILE)|0, ROWS=(H/TILE)|0;
    const WALL=1, OPEN=0;
    const grid=Array.from({length:ROWS},()=>Array(COLS).fill(WALL));

    // 간단 PRNG (시드 고정)
    let SEED=12345;
    function rnd(){ SEED=(SEED*1664525+1013904223)>>>0; return SEED/0xFFFFFFFF; }

    // 미로: 백트래킹 + 중앙 세로 코어로(탈출 보장)
    function carve(){
      const inb=(x,y)=>x>0&&y>0&&x<COLS-1&&y<ROWS-1;
      const neigh=(x,y)=>[[x+2,y],[x-2,y],[x,y+2],[x,y-2]]
        .filter(([nx,ny])=>inb(nx,ny)&&grid[ny][nx]===WALL);

      let sx=((COLS/2)|0); if(!(sx&1)) sx--; // 홀수
      let sy=ROWS-3;        if(!(sy&1)) sy--;
      const st=[sx,sy]; const stack=[st]; grid[sy][sx]=OPEN;

      while(stack.length){
        const [x,y]=stack[stack.length-1];
        const nb=neigh(x,y);
        if(nb.length===0){ stack.pop(); continue; }
        const [nx,ny]=nb[(rnd()*nb.length)|0];
        grid[(y+ny)/2][(x+nx)/2]=OPEN; grid[ny][nx]=OPEN; stack.push([nx,ny]);
      }
      const ex=((COLS/2)|0);
      for(let y=ROWS-2;y>=1;y--) grid[y][ex]=OPEN; // 중앙 직통
      grid[0][ex]=OPEN; // 천장 틈
      // 주변 넓힘
      for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
        grid[sy+dy]?.[sx+dx]=OPEN;
        grid[1+dy]?.[ex+dx]=OPEN;
      }
      return {start:[sx,sy], exit:[ex,0]};
    }
    const {start:START, exit:EXIT}=carve();

    // ===== 배경(귀여운 풀 + 길)
    function prng(n){ n=(n<<13)^n; return (1-((n*(n*n*15731+789221)+1376312589)&0x7fffffff)/1073741824.0); }
    function drawBG(){
      g.fillStyle=C.ground; g.fillRect(0,0,W,H);
      for(let ty=0;ty<ROWS;ty++){
        for(let tx=0;tx<COLS;tx++){
          const x=tx*TILE, y=ty*TILE;
          if(grid[ty][tx]===OPEN){
            g.fillStyle=C.path; g.fillRect(x,y,TILE,TILE);
            g.fillStyle='rgba(255,255,255,.05)'; g.fillRect(x,y,TILE,2);
            g.fillStyle='rgba(0,0,0,.25)'; g.fillRect(x,y+TILE-2,TILE,2);
          }else{
            const r=Math.abs(prng(tx*73856093 ^ ty*19349663));
            g.fillStyle = r<0.33?C.tuftDark:(r<0.66?C.tuftMid:C.tuftHi);
            const cx=x+(TILE>>1), cy=y+(TILE>>1);
            g.fillRect(cx-1, cy-4, 2, 5);
            g.fillRect(cx-5, cy-1, 2, 3);
            g.fillRect(cx+3, cy-1, 2, 3);
            if(r>0.7) g.fillRect(cx-7, cy+4, 1,1);
            if(r<0.25) g.fillRect(cx+6, cy+3, 1,1);
          }
        }
      }
      // 출구 강조(은은)
      g.fillStyle='rgba(255,255,255,.08)';
      g.fillRect(EXIT[0]*TILE, 0, TILE, TILE);
    }

    // ===== 플레이어(길 위 전용 이동)
    const player={
      x: START[0]*TILE + (TILE>>1),
      y: START[1]*TILE + (TILE>>1),
      spd: 2.6, size:.7
    };
    function tileAt(px,py){
      const tx=(px/TILE)|0, ty=(py/TILE)|0;
      if(tx<0||ty<0||tx>=COLS||ty>=ROWS) return WALL;
      return grid[ty][tx];
    }
    function move(px,py,ax,ay,s){
      let nx=px+ax*s, ny=py+ay*s;
      if(tileAt(nx,py)===OPEN) px=nx;
      if(tileAt(px,ny)===OPEN) py=ny;
      return [px,py];
    }
    function drawPlayer(){
      const s=player.size;
      g.fillStyle='rgba(0,0,0,.5)'; g.fillRect(player.x-10*s, player.y+10*s, 20*s, 4*s);
      g.fillStyle=C.actor;     g.fillRect(player.x-10*s, player.y-16*s, 20*s, 12*s);
      g.fillStyle=C.actorHead; g.fillRect(player.x-8*s,  player.y-28*s, 16*s, 10*s);
      g.fillStyle=C.actorEdge; g.fillRect(player.x-10*s, player.y-4*s,  20*s, 2*s);
    }

    // ===== 입력
    const keys=new Set();
    addEventListener('keydown',e=>{
      const k=e.key.toLowerCase();
      if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','e','enter'].includes(k)) e.preventDefault();
      keys.add(k);
    });
    addEventListener('keyup',e=>keys.delete(e.key.toLowerCase()));
    // 터치 D-pad
    const dpad=document.getElementById('dpad'); const held=new Set(); const dstate={ax:0,ay:0};
    function upd(){ let ax=0,ay=0; if(held.has('left')) ax-=1; if(held.has('right')) ax+=1; if(held.has('up')) ay-=1; if(held.has('down')) ay+=1; dstate.ax=ax; dstate.ay=ay; }
    dpad.querySelectorAll('[data-dir]').forEach(b=>{
      const dir=b.dataset.dir;
      const down=e=>{e.preventDefault();held.add(dir);upd();};
      const up  =e=>{e.preventDefault();held.delete(dir);upd();};
      b.addEventListener('pointerdown',down,{passive:false});
      b.addEventListener('pointerup',up,{passive:false});
      b.addEventListener('pointerleave',up,{passive:false});
      b.addEventListener('pointercancel',up,{passive:false});
      b.addEventListener('touchstart',down,{passive:false});
      b.addEventListener('touchend',up,{passive:false});
      b.addEventListener('touchcancel',up,{passive:false});
    });

    // ===== 루프 (즉시 한 프레임 그린 뒤 시작)
    function update(){
      let ax=0,ay=0;
      if(keys.has('arrowleft')||keys.has('a')) ax-=1;
      if(keys.has('arrowright')||keys.has('d')) ax+=1;
      if(keys.has('arrowup')||keys.has('w')) ay-=1;
      if(keys.has('arrowdown')||keys.has('s')) ay+=1;
      ax+=dstate.ax; ay+=dstate.ay;
      const m=Math.hypot(ax,ay)||1; ax/=m; ay/=m;
      [player.x,player.y]=move(player.x,player.y,ax,ay,player.spd);
    }
    function render(){
      drawBG(); drawPlayer();
    }
    render();
    (function loop(){ update(); render(); requestAnimationFrame(loop); })();

  }catch(e){ showErr(e); }
})();
</script>
</body>
</html>
