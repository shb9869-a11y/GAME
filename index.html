<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, interactive-widget=resizes-content" />
<title>Top-Down Demo</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0b0b10">

<style>
  :root{
    --bg:#0b0b10; --fg:#eaeaf2; --accent:#ff6633;
    --hud-pad: clamp(10px, 2.2vmin, 16px);
    --btn: clamp(48px, 10vmin, 80px);
    --gap: clamp(6px, 1.8vmin, 10px);
    --radius: 16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:ui-sans-serif,system-ui,AppleSDGothicNeo,"Noto Sans KR",Segoe UI,Roboto; -webkit-text-size-adjust:100%;}
  /* 모바일 롱프레스 하이라이트/선택 방지 */
  body, button { -webkit-tap-highlight-color: transparent; }
  * { -webkit-user-select: none; user-select: none; }
  canvas{display:block; width:100vw; height:100svh; touch-action:none}

  /* HUD */
  #hud{pointer-events:none}
  #hud, .corner{position:fixed; inset:0}
  .corner{display:flex; padding:calc(env(safe-area-inset-bottom,0) + var(--hud-pad)) var(--hud-pad) var(--hud-pad) var(--hud-pad);}
  .bl{justify-content:flex-start; align-items:flex-end}
  .br{justify-content:flex-end; align-items:flex-end}

  .dpad{
    pointer-events:auto; position:relative;
    width: calc(var(--btn)*3); height: calc(var(--btn)*3);
    display:grid; grid-template-columns: repeat(3,1fr); grid-template-rows: repeat(3,1fr);
    gap: var(--gap);
  }
  .dpad .spacer{opacity:0}
  .btn{
    pointer-events:auto;
    display:flex; align-items:center; justify-content:center;
    width: var(--btn); height: var(--btn);
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.18);
    border-radius: var(--radius);
    backdrop-filter: blur(6px);
    transition: transform .05s ease, background .2s ease;
  }
  .btn:active{ transform: scale(.96); background: rgba(255,255,255,.12); }
  .btn svg{ width:60%; height:60% }

  .talk{
    pointer-events:auto;
    width: calc(var(--btn)*1.2); height: calc(var(--btn)*1.2);
    display:flex; align-items:center; justify-content:center;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.18);
    border-radius: 50%;
    backdrop-filter: blur(6px);
  }
  .talk:active{ transform: scale(.96); background: rgba(255,255,255,.12) }

  /* 대화창 */
  #dialog{
    position:fixed; left:50%; bottom:calc(env(safe-area-inset-bottom,0) + 12px);
    transform:translateX(-50%);
    max-width:min(720px, 92vw);
    background: rgba(12,12,14,.88);
    border:1px solid rgba(255,255,255,.18);
    border-radius: 14px;
    padding: 12px 14px;
    line-height:1.45;
    font-size: clamp(12px, 2vmin, 16px);
    box-shadow: 0 8px 30px rgba(0,0,0,.35);
    display:none;
  }
  #dialog strong{ color: var(--accent); }
  #tip{
    position:fixed; left:50%; top:12px; transform:translateX(-50%);
    font-size: clamp(11px, 1.8vmin, 13px); opacity:.7
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud" aria-hidden="true">
  <div class="corner bl">
    <div class="dpad" id="dpad" role="group" aria-label="방향 패드">
      <button class="btn" data-dir="up"    style="grid-area:1/2" aria-label="위">
        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 5l7 8h-5v6h-4v-6H5z"/></svg>
      </button>
      <button class="btn" data-dir="left"  style="grid-area:2/1" aria-label="왼쪽">
        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M5 12l8-7v5h6v4h-6v5z"/></svg>
      </button>
      <div class="spacer" style="grid-area:2/2"></div>
      <button class="btn" data-dir="right" style="grid-area:2/3" aria-label="오른쪽">
        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 12l-8 7v-5H5v-4h6V5z"/></svg>
      </button>
      <button class="btn" data-dir="down"  style="grid-area:3/2" aria-label="아래">
        <svg viewBox="0 0 24 24"><path fill="currentColor" d="M12 19l-7-8h5V5h4v6h5z"/></svg>
      </button>
    </div>
  </div>
  <div class="corner br">
    <button id="talkBtn" class="talk" aria-label="대화">
      <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M21 6h-2v8H7l-4 4V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z"/></svg>
    </button>
  </div>
</div>

<div id="dialog" role="dialog" aria-live="polite"></div>
<div id="tip">이동: WASD / ←↑↓→ · 말걸기: [E] 또는 우하단 버튼</div>

<script>
(()=>{
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  let W=0, H=0;
  function resize(){
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // ----- 월드 구성 -----
  const world = { w: 1600, h: 1200 };

  // 집(벽 충돌)과 문 영역
  const house = { x: 600, y: 220, w: 400, h: 360 };
  const door = { x: house.x + house.w/2 - 30, y: house.y + house.h - 60, w: 60, h: 60 };

  // 나무 앙상한 가지 배열
  const trees = Array.from({length:28}, (_,i)=>({
    x: (i*53 % (world.w-80)) + 40,
    y: (i*137 % (world.h-120)) + 60,
    r: 18 + (i%5)*2
  })).filter(t => !(t.x>house.x-40 && t.x<house.x+house.w+40 && t.y>house.y-40 && t.y<house.y+house.h+40));

  // 플레이어
  const player = {
    x: world.w/2, y: world.h-180,
    w: 24, h: 28,
    speed: 2.2,
    vx:0, vy:0,
    name: "PLAYER"
  };

  // 카메라
  const cam = {x:0, y:0, w:W/DPR, h:H/DPR};
  function updateCamera(){
    cam.w = W/DPR; cam.h = H/DPR;
    cam.x = Math.max(0, Math.min(world.w - cam.w, player.x - cam.w/2));
    cam.y = Math.max(0, Math.min(world.h - cam.h, player.y - cam.h/2));
  }

  // ----- 입력 -----
  const keys = {up:false,down:false,left:false,right:false};
  const keyMap = { 'ArrowUp':'up', 'KeyW':'up', 'ArrowDown':'down', 'KeyS':'down', 'ArrowLeft':'left', 'KeyA':'left', 'ArrowRight':'right', 'KeyD':'right' };
  addEventListener('keydown', e=>{
    const dir = keyMap[e.code]; if(dir){ keys[dir]=true; e.preventDefault(); }
    if(e.code==='KeyE') speak();
  }, {passive:false});
  addEventListener('keyup', e=>{
    const dir = keyMap[e.code]; if(dir){ keys[dir]=false; e.preventDefault(); }
  }, {passive:false});

  // D-Pad (길게 누르고 있어도 계속 이동)
  const dpad = document.getElementById('dpad');
  let activeTouches = new Set();
  function setDir(dir, val){ keys[dir]=val; }
  dpad.querySelectorAll('.btn').forEach(btn=>{
    const dir = btn.dataset.dir;
    const on = (e)=>{ activeTouches.add(e.pointerId||'mouse'); setDir(dir,true); btn.setPointerCapture?.(e.pointerId); };
    const off= (e)=>{ activeTouches.delete(e.pointerId||'mouse'); setDir(dir,false); };
    btn.addEventListener('pointerdown', on);
    btn.addEventListener('pointerup', off);
    btn.addEventListener('pointercancel', off);
    btn.addEventListener('pointerleave', e=>{ if(!activeTouches.size) setDir(dir,false); });
  });

  // ----- 충돌(집 벽은 막고, 문만 통과 가능) -----
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }
  function resolveCollision(px, py){
    const p = {x:px-12, y:py-14, w:24, h:28}; // 히트박스
    const wall = {x:house.x, y:house.y, w:house.w, h:house.h};
    if(rectsOverlap(p, wall) && !rectsOverlap(p, door)){
      // 간단한 반발: 이전 위치로 돌려보내기
      return {x: player.x, y: player.y};
    }
    return {x:px, y:py};
  }

  // ----- 대화 -----
  const dialog = document.getElementById('dialog');
  let dialogTimer = 0;
  function showDialog(text, ms=2500){
    dialog.textContent='';
    const who = document.createElement('strong'); who.textContent='VOICE';
    dialog.appendChild(who);
    dialog.append(' · ');
    dialog.append(text);
    dialog.style.display='block';
    clearTimeout(dialogTimer);
    dialogTimer = setTimeout(()=> dialog.style.display='none', ms);
  }
  function speak(){
    // 문 앞이면 문 관련 멘트, 그 외엔 주변 묘사
    const nearDoor = rectsOverlap({x:player.x-12,y:player.y-14,w:24,h:28}, {x:door.x-10,y:door.y-4,w:door.w+20,h:door.h+8});
    if(nearDoor){
      showDialog('문은 굳게 잠겨 있다. 노크 소리만 메아리친다…');
    }else{
      const lines = [
        '바람이 마른 가지를 스친다.',
        '낡은 집에서 낮은 웅얼거림이 흘러나온다.',
        '습한 흙 냄새. 발자국이 사라진다.',
        '누군가의 시선이 등을 지나간다.'
      ];
      showDialog(lines[Math.floor(Math.random()*lines.length)]);
    }
  }
  document.getElementById('talkBtn').addEventListener('click', speak);

  // ----- 루프 -----
  let last=0;
  function loop(ts){
    const dt = (ts-last)||16; last = ts;

    // 이동 벡터
    const ax = (keys.right?1:0) - (keys.left?1:0);
    const ay = (keys.down?1:0) - (keys.up?1:0);
    const len = Math.hypot(ax,ay) || 1;
    const speed = player.speed * (dt/16);
    let nx = player.x + (ax/len)*speed*2.2;
    let ny = player.y + (ay/len)*speed*2.2;

    // 충돌 처리
    const fixed = resolveCollision(nx, ny);
    player.x = Math.max(12, Math.min(world.w-12, fixed.x));
    player.y = Math.max(14, Math.min(world.h-14, fixed.y));

    updateCamera();
    render();
    requestAnimationFrame(loop);
  }

  // ----- 그리기 -----
  function render(){
    // 배경 잔디
    ctx.save();
    ctx.scale(DPR, DPR);
    ctx.clearRect(0,0,W/DPR,H/DPR);
    // 잔디 텍스처 느낌
    ctx.fillStyle = '#2a2f26';
    ctx.fillRect(0,0,W/DPR,H/DPR);
    for(let i=0;i<400;i++){
      ctx.fillStyle = i%2? '#313828':'#2f352b';
      const x = (i*47 % world.w) - cam.x, y = (i*91 % world.h) - cam.y;
      ctx.fillRect(x, y, 6, 2);
    }

    // 흙길
    ctx.fillStyle = '#6a583e';
    ctx.strokeStyle = '#4f4332';
    ctx.lineWidth = 2;
    const path = new Path2D();
    path.rect(house.x+house.w/2-60 - cam.x, house.y+house.h - cam.y, 120, 220);
    ctx.fill(path); ctx.stroke(path);

    // 집
    drawHouse();

    // 나무
    trees.forEach(t=>{
      const x=t.x - cam.x, y=t.y - cam.y;
      ctx.fillStyle = '#1a1916'; ctx.beginPath(); ctx.arc(x,y,t.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#25231e'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x,y+t.r+14); ctx.stroke();
    });

    // 문 표시(대화 포인트)
    ctx.fillStyle = '#8a826d';
    ctx.fillRect(door.x - cam.x, door.y - cam.y, door.w, door.h);
    ctx.strokeStyle = 'rgba(255,255,255,.25)';
    ctx.strokeRect(door.x - cam.x, door.y - cam.y, door.w, door.h);

    // 플레이어 (간단한 픽셀 캐릭터)
    const px = Math.round(player.x - cam.x), py = Math.round(player.y - cam.y);
    drawPlayer(px, py);

    ctx.restore();
  }

  function drawHouse(){
    const x = house.x - cam.x, y = house.y - cam.y, w = house.w, h = house.h;
    // 본체
    ctx.fillStyle = '#cfcfd3';
    ctx.strokeStyle = '#b6b6bb';
    ctx.lineWidth = 2;
    ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
    // 지붕
    ctx.fillStyle = '#a43c24';
    ctx.beginPath();
    ctx.moveTo(x-10, y); ctx.lineTo(x+w+10, y); ctx.lineTo(x+w-70, y-80); ctx.lineTo(x+70, y-80); ctx.closePath(); ctx.fill();

    // 현관 삼각지붕
    const wx = x + w/2 - 80, wy = y + h - 160;
    ctx.fillStyle = '#d9d9dd';
    ctx.fillRect(wx, wy, 160, 160);
    ctx.fillStyle = '#a43c24';
    ctx.beginPath();
    ctx.moveTo(wx-8, wy); ctx.lineTo(wx+168, wy); ctx.lineTo(wx+80, wy-70); ctx.closePath(); ctx.fill();

    // 창문들
    ctx.fillStyle = '#9fa3a9';
    for(let i=0;i<3;i++){
      for(let j=0;j<2;j++){
        const cx = x+40 + i*(w-80)/2, cy = y+40 + j*90;
        drawWindow(cx, cy);
        drawWindow(cx+w/2-20, cy);
      }
    }
  }
  function drawWindow(x,y){
    ctx.fillStyle = '#9fa3a9';
    ctx.fillRect(x,y,40,36);
    ctx.strokeStyle = '#7c8086'; ctx.strokeRect(x,y,40,36);
    ctx.strokeStyle = 'rgba(255,255,255,.25)';
    ctx.beginPath(); ctx.moveTo(x+4,y+18); ctx.lineTo(x+36,y+18); ctx.moveTo(x+20,y+4); ctx.lineTo(x+20,y+32); ctx.stroke();
  }

  function drawPlayer(px, py){
    // 그림자
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.beginPath(); ctx.ellipse(px, py+12, 10, 6, 0, 0, Math.PI*2); ctx.fill();
    // 몸통
    ctx.fillStyle = '#2d5cff'; ctx.fillRect(px-10, py-14, 20, 18);
    // 머리
    ctx.fillStyle = '#d1c7b3'; ctx.fillRect(px-9, py-28, 18, 14);
    // 머리카락
    ctx.fillStyle = '#2a2a2a'; ctx.fillRect(px-9, py-28, 18, 6);
    // 다리
    ctx.fillStyle = '#222'; ctx.fillRect(px-9, py+4, 8, 12);
    ctx.fillRect(px+1, py+4, 8, 12);
  }

  // 시작 안내 멘트
  setTimeout(()=>showDialog('주변을 탐색해 보자. 문 앞에서 [E] 또는 “대화”를 눌러봐.' , 3500), 600);

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
