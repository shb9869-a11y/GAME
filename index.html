<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SLEEP ‚Äì Optimized (No Freeze on Loud Audio)</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;}

  #hint{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.72);
    color:#ddd; font-family:system-ui, -apple-system, sans-serif;
    text-align:center; padding:20px;
    z-index:50;
  }
  #hint .box{
    width:min(620px, 94vw);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:18px 16px;
    background:rgba(0,0,0,.55);
  }

  #topRight{
    position:fixed; right:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  .iconBtn{
    width:42px; height:42px;
    display:grid; place-items:center;
    background:rgba(0,0,0,.38);
    color:#eee;
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px;
    backdrop-filter: blur(10px);
    cursor:pointer;
    user-select:none;
    font-size:18px;
  }
  .iconBtn:hover{border-color:rgba(255,255,255,.30)}
  .iconBtn:active{transform:translateY(1px)}

  #ui{
    position:fixed; right:12px; top:62px;
    width:min(560px, calc(100vw - 24px));
    color:#ddd;
    font-family:system-ui, -apple-system, sans-serif;
    background:rgba(0,0,0,.42);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    box-shadow:0 0 0 1px rgba(255,255,255,.06) inset;
    backdrop-filter: blur(10px);
    overflow:hidden;
    z-index:40;
    transform-origin: top right;
  }
  #ui.hidden{display:none;}

  #bar{
    display:flex; align-items:center; gap:8px;
    padding:10px 10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  #bar .title{font-weight:800; font-size:13px; color:#eee;}
  #bar .pill{
    margin-left:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px; color:#bbb;
    padding:6px 8px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:999px;
    background:rgba(0,0,0,.25);
    white-space:nowrap;
  }

  button, select, input[type="range"]{
    background:#0f0f0f; color:#eee;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:8px 10px;
    font-weight:650;
    outline:none;
  }
  input[type="range"]{padding:8px 0;}
  button:hover, select:hover{border-color:rgba(255,255,255,.32)}
  button:disabled, select:disabled{opacity:.5; cursor:not-allowed}

  #tabs{
    display:flex; gap:6px; padding:10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .tab{
    flex:1;
    padding:8px 10px;
    font-size:12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
    cursor:pointer;
    text-align:center;
    user-select:none;
  }
  .tab.active{
    border-color:rgba(255,255,255,.34);
    background:rgba(255,255,255,.06);
  }
  #panels{padding:10px;}
  .panel{display:none;}
  .panel.active{display:block;}

  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0;}
  .label{font-size:12px; color:#aaa; width:128px;}
  .grow{flex:1; min-width:180px;}

  .meter{
    height:10px; border-radius:999px;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .meter > i{
    display:block; height:100%;
    width:0%;
    background:rgba(255,255,255,.85);
  }

  .small{
    font-size:11px; color:#9aa;
    line-height:1.45;
  }
  .mono{
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    color:#bbb;
    white-space:pre-wrap;
    word-break:break-word;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:10px;
    padding:8px;
    max-height:160px;
    overflow:auto;
  }
  .danger{color:#ffb0b0;}
</style>
</head>
<body>

<div id="hint">
  <div class="box">
    <div style="font-weight:900; font-size:16px; margin-bottom:10px;">SLEEP ‚Äì Start</div>
    <div class="small" style="margin-bottom:12px;">
      1) <b>Start Audio</b> (Ïò§ÎîîÏò§ Ïñ∏ÎùΩ)<br/>
      2) ÏõêÌïòÎ©¥ <b>Mic ON</b> ÎòêÎäî <b>Audio File</b>Î°ú ÏûÖÎ†•<br/>
      3) TouchMeÎäî MIDI ÌÉ≠ÏóêÏÑú Î°úÍ∑∏ ÌôïÏù∏
    </div>
    <div class="row">
      <button id="btnStartAudio">Start Audio</button>
      <button id="btnStartMic" disabled>Mic ON</button>
      <button id="btnStopMic" disabled>Mic OFF</button>
      <button id="btnFS">Fullscreen</button>
    </div>
    <div class="small" id="startStatus" style="opacity:.9"></div>
  </div>
</div>

<canvas id="c"></canvas>

<div id="topRight">
  <div class="iconBtn" id="btnGear" title="Settings">‚öôÔ∏è</div>
  <div class="iconBtn" id="btnMuteQuick" title="Mute">üîá</div>
  <div class="iconBtn" id="btnFSQuick" title="Fullscreen">‚õ∂</div>
</div>

<div id="ui" class="hidden">
  <div id="bar">
    <div class="title">Settings</div>
    <button id="btnHideUI" title="Close">Îã´Í∏∞</button>
    <div class="pill" id="topPill">audio:off | mic:off | file:off | midi:?</div>
  </div>

  <div id="tabs">
    <div class="tab active" data-tab="visual">VISUAL</div>
    <div class="tab" data-tab="audio">AUDIO</div>
    <div class="tab" data-tab="midi">MIDI</div>
    <div class="tab" data-tab="system">SYSTEM</div>
  </div>

  <div id="panels">
    <div class="panel active" id="panel-visual">
      <div class="row">
        <div class="label">Particles</div>
        <select id="selN" class="grow">
          <option value="160">160</option>
          <option value="220" selected>220</option>
          <option value="320">320</option>
          <option value="420">420</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Link density</div>
        <select id="selLink" class="grow">
          <option value="low">Low</option>
          <option value="mid" selected>Mid</option>
          <option value="high">High</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Keep in screen</div>
        <select id="selBounds" class="grow">
          <option value="soft" selected>Soft boundary</option>
          <option value="bounce">Bounce</option>
          <option value="wrap">Wrap</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Idle drama</div>
        <input id="rngIdle" class="grow" type="range" min="0" max="1" step="0.01" />
      </div>

      <div class="row">
        <div class="label">Sensitivity</div>
        <input id="rngSens" class="grow" type="range" min="0.6" max="4.0" step="0.01" />
      </div>

      <div class="small">
        ‚úÖ ÏÜåÎ¶¨ Ïª§Ï†∏ÎèÑ ‚ÄúÎ©àÏ∂§‚Äù Î∞©ÏßÄ: <b>Ï¥ù ÎßÅÌÅ¨ ÏÉÅÌïú + Ï†ÅÏùëÌòï ÏÑ±Îä• Î∏åÎ†àÏù¥ÌÅ¨</b> Ï†ÅÏö©Îê®.
      </div>
    </div>

    <div class="panel" id="panel-audio">
      <div class="row">
        <div class="label">Input level</div>
        <div class="grow"><div class="meter"><i id="meterIn"></i></div></div>
      </div>
      <div class="row">
        <div class="label">Amp / Œî</div>
        <div class="mono grow" id="txtAmp">amp: 0.0000 | dAmp: 0.0000</div>
      </div>
      <div class="row">
        <div class="label">FX (Touch)</div>
        <div class="mono grow" id="txtFx">‚Äî</div>
      </div>
      <div class="small">
        ÌïòÏö∏ÎßÅ/Í≥ºÏûÖÎ†• Ïãú ÏûêÎèô Î∏åÎ†àÏù¥ÌÅ¨(overload)Í∞Ä Í±∏Î¶ΩÎãàÎã§.
      </div>
    </div>

    <div class="panel" id="panel-midi">
      <div class="row">
        <div class="label">Touch value</div>
        <div class="grow"><div class="meter"><i id="meterTouch"></i></div></div>
      </div>
      <div class="row">
        <div class="label">MIDI log</div>
        <div class="mono grow" id="txtMIDI">Waiting‚Ä¶</div>
      </div>
    </div>

    <div class="panel" id="panel-system">
      <div class="row">
        <div class="label">Audio context</div>
        <button id="btnResume" class="grow">Resume / Unlock Audio</button>
      </div>

      <div class="row">
        <div class="label">Mic input</div>
        <select id="selMic" class="grow" disabled>
          <option>Ïû•Ïπò Î™©Î°ù Î∂àÎü¨Ïò§Îäî Ï§ë‚Ä¶</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Mic control</div>
        <button id="btnMicOn" class="grow" disabled>Mic ON</button>
        <button id="btnMicOff" class="grow" disabled>Mic OFF</button>
      </div>

      <div class="row">
        <div class="label">Audio File</div>
        <input id="fileAudio" class="grow" type="file" accept="audio/*" />
      </div>

      <div class="row">
        <div class="label">File control</div>
        <button id="btnPlayFile" class="grow" disabled>Play</button>
        <button id="btnStopFile" class="grow" disabled>Stop</button>
      </div>

      <div class="row">
        <div class="label">Loop</div>
        <select id="selLoop" class="grow">
          <option value="1" selected>On</option>
          <option value="0">Off</option>
        </select>
      </div>

      <div class="row">
        <div class="label">File volume</div>
        <input id="rngFileVol" class="grow" type="range" min="0" max="1" step="0.01" />
      </div>

      <div class="small mono" id="txtSupport"></div>
    </div>
  </div>
</div>

<script>
/* ==========================================================
   SETTINGS (localStorage)
========================================================== */
const STORE_KEY = "sleep_freezeFix_v1";
function loadSettings(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
function saveSettings(obj){ localStorage.setItem(STORE_KEY, JSON.stringify(obj)); }
const S = loadSettings();

function applyValue(id, fallback){
  const el = document.getElementById(id);
  if(!el) return;
  const v = (S[id] ?? fallback);
  if(el.type === "range") el.value = v;
  else el.value = v;
}
function hookSave(id){
  const el = document.getElementById(id);
  if(!el) return;
  const ev = (el.type === "range") ? "input" : "change";
  el.addEventListener(ev, ()=>{
    S[id] = el.value;
    saveSettings(S);
  });
}

/* ==========================================================
   CANVAS / DPR
========================================================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  W = innerWidth|0; H = innerHeight|0;
  canvas.width  = (W*DPR)|0;
  canvas.height = (H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* ==========================================================
   AUDIO (mic + file) + FX + ANALYSER
   - OPT: WaveShaper curve caching + update-on-change
========================================================== */
let audioCtx=null;
let analyser=null, timeData=null;

let masterGain=null, isMuted=false;
let preGain=null, driveWS=null, foldWS=null, postDriveGain=null;
let bp=null, notch=null, hp=null, gBP=null, gNotch=null, gHP=null;
let ringOsc=null, ringGain=null, ringMult=null;
let splitter=null, dL=null, dR=null, merger=null, comp=null;

let micStream=null, micSrc=null;
let fileEl=null, fileSrc=null, fileGain=null, fileOn=false;

let amp=0, ampSmooth=0, ampDelta=0, prevAmp=0;

/* --- curve cache --- */
const driveCurveCache = new Map();
const foldCurveCache  = new Map();
function makeWaveshaperCurveSoft(amount=20){
  const n=2048, curve=new Float32Array(n);
  const k=amount;
  for(let i=0;i<n;i++){
    const x=(i*2/n)-1;
    curve[i] = (1+k)*x/(1+k*Math.abs(x));
  }
  return curve;
}
function makeWavefoldCurve(amount=2.0){
  const n=2048, curve=new Float32Array(n);
  for(let i=0;i<n;i++){
    let x=(i*2/n)-1;
    x *= amount;
    x = ((x + 1) % 4 + 4) % 4 - 1;
    if(x > 1) x = 2 - x;
    curve[i] = x;
  }
  return curve;
}
function getDriveCurve(amount){
  const q = Math.max(1, Math.min(120, Math.round(amount*1.0)));
  let c = driveCurveCache.get(q);
  if(!c){ c = makeWaveshaperCurveSoft(q); driveCurveCache.set(q,c); }
  return c;
}
function getFoldCurve(amount){
  const q = Math.max(1, Math.min(16, Math.round(amount*10)/10));
  let c = foldCurveCache.get(q);
  if(!c){ c = makeWavefoldCurve(q); foldCurveCache.set(q,c); }
  return c;
}

/* --- safety brake --- */
let overload=0; // 0~1
function updateOverload(){
  const hot = Math.max(0, (amp - 0.17) * 6.0);
  const spike = Math.max(0, (ampDelta - 0.012) * 80.0);
  const target = Math.min(1, hot + spike);
  overload += (target - overload)*0.08;
  overload = Math.max(0, Math.min(1, overload));
  if(audioCtx && preGain && masterGain){
    const pre = 1.0 - overload*0.65;
    preGain.gain.setTargetAtTime(pre, audioCtx.currentTime, 0.04);
    const m = isMuted ? 0 : (0.9 - overload*0.35);
    masterGain.gain.setTargetAtTime(m, audioCtx.currentTime, 0.05);
  }
}

function ensureAudio(){
  if(audioCtx) return;

  audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  timeData = new Uint8Array(analyser.fftSize);

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;

  preGain = audioCtx.createGain(); preGain.gain.value = 1.0;

  driveWS = audioCtx.createWaveShaper();
  driveWS.curve = getDriveCurve(10);
  driveWS.oversample = '4x';

  foldWS = audioCtx.createWaveShaper();
  foldWS.curve = getFoldCurve(1.0);
  foldWS.oversample = '4x';

  postDriveGain = audioCtx.createGain();
  postDriveGain.gain.value = 1.0;

  bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=900; bp.Q.value=2.0;
  notch = audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=900; notch.Q.value=1.0;
  hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=120; hp.Q.value=0.7;

  gBP = audioCtx.createGain(); gBP.gain.value=1;
  gNotch = audioCtx.createGain(); gNotch.gain.value=0;
  gHP = audioCtx.createGain(); gHP.gain.value=0;

  ringOsc = audioCtx.createOscillator();
  ringOsc.type = 'sine';
  ringOsc.frequency.value = 35;

  ringGain = audioCtx.createGain();
  ringGain.gain.value = 0.0;

  ringMult = audioCtx.createGain();
  ringMult.gain.value = 1.0;
  ringOsc.connect(ringGain);
  ringGain.connect(ringMult.gain);

  splitter = audioCtx.createChannelSplitter(2);
  dL = audioCtx.createDelay(0.05);
  dR = audioCtx.createDelay(0.05);
  dL.delayTime.value = 0.004;
  dR.delayTime.value = 0.011;
  merger = audioCtx.createChannelMerger(2);

  comp = audioCtx.createDynamicsCompressor();
  comp.threshold.value = -22;
  comp.knee.value = 28;
  comp.ratio.value = 7;
  comp.attack.value = 0.003;
  comp.release.value = 0.16;

  preGain.connect(driveWS);
  driveWS.connect(foldWS);
  foldWS.connect(postDriveGain);

  postDriveGain.connect(bp);    bp.connect(gBP);
  postDriveGain.connect(notch); notch.connect(gNotch);
  postDriveGain.connect(hp);    hp.connect(gHP);

  gBP.connect(ringMult);
  gNotch.connect(ringMult);
  gHP.connect(ringMult);

  ringMult.connect(splitter);
  splitter.connect(dL, 0);
  splitter.connect(dR, 1);
  dL.connect(merger, 0, 0);
  dR.connect(merger, 0, 1);

  merger.connect(comp);
  comp.connect(analyser);
  analyser.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  ringOsc.start();
  updateTopPill();
}

function updateAmp(){
  if(!analyser) return;
  analyser.getByteTimeDomainData(timeData);
  let sum=0;
  for(let i=0;i<timeData.length;i++){
    const v=(timeData[i]-128)/128;
    sum+=v*v;
  }
  const rms=Math.sqrt(sum/timeData.length);
  ampSmooth += (rms-ampSmooth)*0.15;
  amp = ampSmooth;
  ampDelta = Math.abs(amp - prevAmp);
  prevAmp = amp;
  updateOverload();
}

/* ==========================================================
   MIC
========================================================== */
const selMic = document.getElementById('selMic');
let currentMicDeviceId = S.currentMicDeviceId ?? "default";

async function listDevices(){
  let devices=[];
  try{ devices = await navigator.mediaDevices.enumerateDevices(); }catch(e){}
  const mics = devices.filter(d=>d.kind==="audioinput");

  selMic.innerHTML="";
  if(mics.length===0){
    selMic.disabled=true;
    selMic.innerHTML = `<option>ÎßàÏù¥ÌÅ¨ Ïû•ÏπòÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå</option>`;
  }else{
    selMic.disabled=false;
    for(const d of mics){
      const opt=document.createElement('option');
      opt.value=d.deviceId;
      opt.textContent=d.label || `Mic (${d.deviceId.slice(0,6)}‚Ä¶)`;
      if(d.deviceId===currentMicDeviceId) opt.selected=true;
      selMic.appendChild(opt);
    }
  }

  const txt = document.getElementById('txtSupport');
  txt.textContent =
`ÏßÄÏõê ÏÉÅÌÉú:
- mic: ${mics.length}
- audioCtx: ${audioCtx ? audioCtx.state : "off"}

ÌåÅ:
- ÌïòÏö∏ÎßÅ ÎÇòÎ©¥(Ïä§ÌîºÏª§/ÎßàÏù¥ÌÅ¨ Í∞ÄÍπåÏõÄ) Î∞òÎìúÏãú Î¨ºÎ¶¨Ï†ÅÏúºÎ°ú Í±∞Î¶¨/Î≥ºÎ•®ÏùÑ Ï§ÑÏó¨Ïïº Ìï®.
- Ïù¥ ÏΩîÎìúÎäî Í≥ºÎ∂ÄÌïò Î∏åÎ†àÏù¥ÌÅ¨(overload)Î°ú ÏãúÍ∞Å/Ïò§ÎîîÏò§ Ìè≠Ï£ºÎ•º ÎàåÎü¨Ï§å.`;
}

async function startMic(deviceId="default"){
  ensureAudio();
  await audioCtx.resume();
  stopMic();
  try{
    micStream = await navigator.mediaDevices.getUserMedia({
      audio:{
        deviceId: deviceId ? {exact:deviceId} : undefined,
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false
      }
    });
    micSrc = audioCtx.createMediaStreamSource(micStream);
    micSrc.connect(preGain);

    setStartButtons(true);
    updateTopPill();
    startStatus("Mic ON. AUDIO ÌÉ≠ÏóêÏÑú amp ÌôïÏù∏!");
  }catch(e){
    console.error(e);
    startStatus("Mic ON Ïã§Ìå®. Í∂åÌïú/Ïû•Ïπò ÏÑ†ÌÉù ÌôïÏù∏.");
    alert("ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÎòêÎäî Ïû•Ïπò ÏÑ†ÌÉù Ïã§Ìå®. ÌÅ¨Î°¨ ÏÇ¨Ïù¥Ìä∏ Í∂åÌïú ÌôïÏù∏!");
  }
}
function stopMic(){
  if(micSrc){ try{ micSrc.disconnect(); }catch(e){} micSrc=null; }
  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream=null; }
  setStartButtons(false);
  updateTopPill();
}

selMic.addEventListener('change', async ()=>{
  currentMicDeviceId = selMic.value;
  S.currentMicDeviceId = currentMicDeviceId;
  saveSettings(S);
  if(micStream) await startMic(currentMicDeviceId);
});

/* ==========================================================
   AUDIO FILE INPUT
========================================================== */
const fileInput = document.getElementById('fileAudio');
const btnPlayFile = document.getElementById('btnPlayFile');
const btnStopFile = document.getElementById('btnStopFile');
const selLoop = document.getElementById('selLoop');
const rngFileVol = document.getElementById('rngFileVol');

applyValue('rngFileVol', '0.75');
hookSave('rngFileVol');
rngFileVol.addEventListener('input', ()=>{
  if(fileGain && audioCtx) fileGain.gain.setTargetAtTime(parseFloat(rngFileVol.value), audioCtx.currentTime, 0.03);
});

selLoop.addEventListener('change', ()=>{
  if(fileEl) fileEl.loop = (selLoop.value === "1");
  S.selLoop = selLoop.value; saveSettings(S);
});
applyValue('selLoop','1');

function setupFileNodes(){
  if(fileEl || !audioCtx) return;
  fileEl = new Audio();
  fileEl.crossOrigin = "anonymous";
  fileEl.loop = (selLoop.value==="1");
  fileEl.playsInline = true;

  fileGain = audioCtx.createGain();
  fileGain.gain.value = parseFloat(rngFileVol.value);

  fileSrc = audioCtx.createMediaElementSource(fileEl);
  fileSrc.connect(fileGain);
  fileGain.connect(preGain);

  btnPlayFile.disabled = false;
  btnStopFile.disabled = false;
}

fileInput.addEventListener('change', ()=>{
  const f = fileInput.files && fileInput.files[0];
  if(!f) return;
  ensureAudio();
  setupFileNodes();
  const url = URL.createObjectURL(f);
  fileEl.src = url;
  fileOn = true;
  updateTopPill();
  startStatus("Audio File Î°úÎìúÎê®. Play ÎàÑÎ•¥Î©¥ ÏûÖÎ†•ÏúºÎ°ú Îì§Ïñ¥Í∞ê!");
});

btnPlayFile.addEventListener('click', async ()=>{
  if(!fileEl) return;
  ensureAudio();
  await audioCtx.resume();
  try{
    await fileEl.play();
    fileOn = true;
    updateTopPill();
  }catch(e){
    console.warn(e);
    alert("Ïû¨ÏÉùÏù¥ ÎßâÌòîÏñ¥Ïöî. Start AudioÎ•º Î®ºÏ†Ä ÎàÑÎ•¥Í≥† Îã§Ïãú Play!");
  }
});

btnStopFile.addEventListener('click', ()=>{
  if(!fileEl) return;
  fileEl.pause();
  fileEl.currentTime = 0;
  fileOn = false;
  updateTopPill();
});

/* ==========================================================
   MIDI (TouchMe)
========================================================== */
let touch=0, touchSmooth=0;
let midiName="MIDI: ?";
let midiLog=[];

function pushMidiLog(line){
  midiLog.push(line);
  if(midiLog.length>18) midiLog.shift();
  document.getElementById('txtMIDI').textContent = `${midiName}\n` + midiLog.join('\n');
}

async function initMIDI(){
  if(!navigator.requestMIDIAccess){
    midiName="MIDI: not supported";
    pushMidiLog("requestMIDIAccess ÏóÜÏùå");
    return;
  }
  try{
    const midi = await navigator.requestMIDIAccess({sysex:false});
    const inputs=[...midi.inputs.values()];
    if(inputs.length===0){
      midiName="MIDI: no inputs";
      pushMidiLog("MIDI ÏûÖÎ†• Ïû•Ïπò ÏóÜÏùå");
      return;
    }
    const input=inputs[0];
    midiName="MIDI: "+(input.name||"input");
    pushMidiLog("Connected: "+midiName);

    input.onmidimessage=(e)=>{
      const data=[...e.data];
      const v=data[2] ?? 0;
      touch = Math.max(0, Math.min(1, v/127));
      pushMidiLog(`data=[${data.join(',')}] -> touch=${touch.toFixed(3)}`);
    };
  }catch(e){
    console.error(e);
    midiName="MIDI: blocked";
    pushMidiLog("MIDI access failed");
  }
}
function updateTouch(){
  touchSmooth += (touch-touchSmooth)*0.12;
}

/* ==========================================================
   FX MORPH (TouchMe)
========================================================== */
let lastDriveQ = -1;
let lastFoldQ  = -1;
let lastFXStamp = 0;

const FX_UI = {touch:0, driveAmt:0, foldAmt:0, f:0, ringHz:0};

function applyFX(){
  if(!audioCtx) return;

  const tRaw = Math.max(0, Math.min(1, touchSmooth));
  const t = Math.pow(tRaw, 1.85);
  const safe = 1.0 - overload*0.75;

  const driveAmt = (6 + t*78) * safe;
  const foldAmt  = (1.0 + Math.pow(t, 1.45)*7.0) * (0.75 + 0.25*safe);

  const driveQ = Math.max(1, Math.min(120, Math.round(driveAmt*1.0)));
  const foldQ  = Math.max(1, Math.min(16,  Math.round(foldAmt*10)/10));

  const now = performance.now();
  if((driveQ !== lastDriveQ || foldQ !== lastFoldQ) && (now - lastFXStamp > 20)){
    driveWS.curve = getDriveCurve(driveQ);
    foldWS.curve  = getFoldCurve(foldQ);
    lastDriveQ = driveQ;
    lastFoldQ  = foldQ;
    lastFXStamp = now;
  }

  postDriveGain.gain.setTargetAtTime((0.95 - t*0.28) * (0.85 + 0.15*safe), audioCtx.currentTime, 0.03);

  const f = (140 + Math.pow(t, 1.6)*6200) * (0.85 + 0.15*safe);
  bp.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.04);
  notch.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.04);
  hp.frequency.setTargetAtTime((80 + t*760) * (0.85 + 0.15*safe), audioCtx.currentTime, 0.04);

  bp.Q.setTargetAtTime(1.6 + t*10, audioCtx.currentTime, 0.04);
  notch.Q.setTargetAtTime(0.8 + t*8, audioCtx.currentTime, 0.04);
  hp.Q.setTargetAtTime(0.7 + t*0.9, audioCtx.currentTime, 0.04);

  const bpMix    = Math.max(0, 1 - t*1.35);
  const notchMix = Math.max(0, 1 - Math.abs(t-0.55)*3.2);
  const hpMix    = Math.max(0, (t-0.50)*2.4);
  gBP.gain.setTargetAtTime(bpMix, audioCtx.currentTime, 0.04);
  gNotch.gain.setTargetAtTime(notchMix, audioCtx.currentTime, 0.04);
  gHP.gain.setTargetAtTime(hpMix, audioCtx.currentTime, 0.04);

  const ringHz = (8 + t*320) * (0.85 + 0.15*safe);
  ringOsc.frequency.setTargetAtTime(ringHz, audioCtx.currentTime, 0.04);
  ringGain.gain.setTargetAtTime(t*0.92 * safe, audioCtx.currentTime, 0.04);

  const wob = (Math.sin(performance.now()*0.0015)*0.5+0.5);
  dL.delayTime.setTargetAtTime(0.002 + t*0.010 + wob*0.0007, audioCtx.currentTime, 0.06);
  dR.delayTime.setTargetAtTime(0.006 + t*0.016 + (1-wob)*0.0009, audioCtx.currentTime, 0.06);

  FX_UI.touch = t;
  FX_UI.driveAmt = driveQ;
  FX_UI.foldAmt  = foldQ;
  FX_UI.f = f;
  FX_UI.ringHz = ringHz;
}

/* ==========================================================
   UI helpers
========================================================== */
function startStatus(msg){
  const el=document.getElementById('startStatus');
  if(el) el.innerHTML = msg;
}
function setStartButtons(micOn){
  document.getElementById('btnStartMic').disabled = !audioCtx || micOn;
  document.getElementById('btnStopMic').disabled  = !micOn;
  document.getElementById('btnMicOn').disabled    = !audioCtx || micOn;
  document.getElementById('btnMicOff').disabled   = !micOn;
}
function updateTopPill(){
  const pill=document.getElementById('topPill');
  const a = audioCtx ? audioCtx.state : 'off';
  const mic = micStream ? 'on' : 'off';
  const file = (fileEl && !fileEl.paused && fileOn) ? 'on' : 'off';
  const midi = midiName.includes('MIDI:') ? midiName.replace('MIDI: ','') : '?';
  pill.textContent = `audio:${a} | mic:${mic} | file:${file} | midi:${midi}`;
}

/* ==========================================================
   VISUAL (WHITE + SMALL) + NO FREEZE SYSTEM
========================================================== */
let N = 220;
let pts=[];
let rot=0;

const BASE_ALPHA = 0.28;
const BASE_RADIUS = 1.05;
const ACTIVE_RADIUS_GAIN = 2.55;

// Ï†ÑÏ≤¥Î•º Ï†àÎ∞ò ÎäêÎ¶¨Í≤å
const SPEED_SCALE = 0.50;

// ---- Adaptive Performance Brake ----
let lastT = performance.now();
let qDrop = 0; // 0(ÏµúÍ≥†ÌíàÏßà)~1(ÏµúÏ†ÄÌíàÏßà)
function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function updateQuality(dt){
  // 60fps Í∏∞Ï§Ä 16.7ms, 20ms ÎÑòÏúºÎ©¥ Î∂ÄÎã¥
  const overloadDt = Math.max(0, dt - 18);
  const target = clamp01(overloadDt / 30); // dt 48msÎ©¥ target ~1
  qDrop += (target - qDrop) * 0.08;
  qDrop = clamp01(qDrop);

  // ÏÜåÎ¶¨ Ìè≠Ï£º(overload)ÎèÑ ÌíàÏßà ÌïòÌñ•ÏùÑ ÎèÑÏôÄÏ§ÄÎã§
  qDrop = clamp01(Math.max(qDrop, overload*0.80));
}
function qScale(a,b){ // quality 1Ïù¥Î©¥ a, 0Ïù¥Î©¥ b
  const q = 1 - qDrop;
  return b + (a-b)*q;
}

// hard caps (Î©àÏ∂§ Î∞©ÏßÄ ÌïµÏã¨)
const TOTAL_LINK_CAP_BASE = 8500; // Ìïú ÌîÑÎ†àÏûÑÏóê Í∑∏Î¶¥ ÏÑ† ÏµúÎåÄÏπò
const TOTAL_LINK_CAP_MIN  = 1800;

applyValue('rngIdle', '0.55'); hookSave('rngIdle');
applyValue('rngSens', '2.10'); hookSave('rngSens');

function initPoints(){
  pts=[];
  for(let i=0;i<N;i++){
    pts.push({
      x:(Math.random()*2-1)*(W*0.34),
      y:(Math.random()*2-1)*(H*0.34),
      z:(Math.random()*2-1)*360,
      vx:0,vy:0,vz:0,
      seed:Math.random()*1000,
      ph1:Math.random()*Math.PI*2,
      ph2:Math.random()*Math.PI*2
    });
  }
  pr.length = N;
  for(let i=0;i<N;i++) pr[i] = {x:0,y:0,k:1,z:0};
}
document.getElementById('selN').addEventListener('change', (e)=>{
  N = parseInt(e.target.value,10);
  initPoints();
});

const pr = [];
function projectInto(i){
  const p=pts[i];
  const s=Math.sin(rot), c=Math.cos(rot);
  const x = p.x*c - p.z*s;
  const z = p.x*s + p.z*c;
  const depth = 900;
  const k = depth/(depth+z);
  pr[i].x = x*k + W/2;
  pr[i].y = p.y*k + H/2;
  pr[i].k = k;
  pr[i].z = z;
}

function applyBounds(p, mode){
  if(mode==="wrap"){
    const maxX=W*0.65, maxY=H*0.65, maxZ=600;
    if(p.x> maxX) p.x=-maxX;
    if(p.x<-maxX) p.x= maxX;
    if(p.y> maxY) p.y=-maxY;
    if(p.y<-maxY) p.y= maxY;
    if(p.z> maxZ) p.z=-maxZ;
    if(p.z<-maxZ) p.z= maxZ;
    return;
  }
  const maxX=W*0.58, maxY=H*0.58, maxZ=600;
  if(mode==="bounce"){
    if(p.x> maxX){ p.x=maxX; p.vx*=-0.7; }
    if(p.x<-maxX){ p.x=-maxX; p.vx*=-0.7; }
    if(p.y> maxY){ p.y=maxY; p.vy*=-0.7; }
    if(p.y<-maxY){ p.y=-maxY; p.vy*=-0.7; }
    if(p.z> maxZ){ p.z=maxZ; p.vz*=-0.7; }
    if(p.z<-maxZ){ p.z=-maxZ; p.vz*=-0.7; }
    return;
  }
  const pull=0.0026;
  const edgeX=Math.max(0, Math.abs(p.x)-maxX);
  const edgeY=Math.max(0, Math.abs(p.y)-maxY);
  const edgeZ=Math.max(0, Math.abs(p.z)-maxZ);
  if(edgeX>0) p.vx += (-Math.sign(p.x))*edgeX*pull;
  if(edgeY>0) p.vy += (-Math.sign(p.y))*edgeY*pull;
  if(edgeZ>0) p.vz += (-Math.sign(p.z))*edgeZ*pull;
}

/* ---- Spatial hash for links ---- */
const grid = new Map();
function cellKey(cx,cy){ return (cx<<16) ^ (cy & 0xffff); }
function buildGrid(cellSize){
  grid.clear();
  const inv = 1/cellSize;
  for(let i=0;i<N;i++){
    const x = pr[i].x, y = pr[i].y;
    const cx = (x*inv)|0;
    const cy = (y*inv)|0;
    const k = cellKey(cx,cy);
    let arr = grid.get(k);
    if(!arr){ arr=[]; grid.set(k,arr); }
    arr.push(i);
  }
}

function drawLinks(linkDist, maxLinksPerPoint, alphaBoost, totalCap){
  const LD = Math.min(linkDist, 190); // Îçî Í∞ïÌïú cap (Ìè≠Ï£º Ï∞®Îã®)
  const cellSize = Math.max(28, LD);
  buildGrid(cellSize);

  const inv = 1/cellSize;
  const LD2 = LD*LD;

  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,255,255,0.92)";

  let totalLinks = 0;

  for(let i=0;i<N;i++){
    let links = 0;
    const ax = pr[i].x, ay = pr[i].y;
    const cx = (ax*inv)|0, cy = (ay*inv)|0;

    for(let oy=-1; oy<=1; oy++){
      for(let ox=-1; ox<=1; ox++){
        const k = cellKey(cx+ox, cy+oy);
        const arr = grid.get(k);
        if(!arr) continue;

        for(let idx=0; idx<arr.length; idx++){
          const j = arr[idx];
          if(j<=i) continue;
          const bx = pr[j].x, by = pr[j].y;
          const dx = ax-bx, dy = ay-by;
          const d2 = dx*dx + dy*dy;
          if(d2 < LD2){
            const d = Math.sqrt(d2);
            const a = (1 - d/LD);
            ctx.globalAlpha = Math.min(1, a * alphaBoost);
            ctx.beginPath();
            ctx.moveTo(ax,ay);
            ctx.lineTo(bx,by);
            ctx.stroke();
            links++;
            totalLinks++;

            // ‚úÖ total cap: Ïó¨Í∏∞ÏÑú ÌîÑÎ†àÏûÑ Î©àÏ∂§ Î∞©ÏßÄ
            if(totalLinks >= totalCap){
              ctx.globalAlpha = 1;
              return;
            }
            if(links >= maxLinksPerPoint){ oy=2; break; }
          }
        }
      }
    }
  }
  ctx.globalAlpha = 1;
}

/* ==========================================================
   MAIN LOOP
========================================================== */
let frame=0;
const elMeterIn = document.getElementById('meterIn');
const elTxtAmp  = document.getElementById('txtAmp');
const elMeterTouch = document.getElementById('meterTouch');
const elTxtFx = document.getElementById('txtFx');

function loop(){
  const now = performance.now();
  const dt = now - lastT;
  lastT = now;

  updateQuality(dt);

  // trail
  ctx.fillStyle = "rgba(0,0,0,0.12)";
  ctx.fillRect(0,0,W,H);

  // sensors
  if(audioCtx) updateAmp();
  updateTouch();
  if(audioCtx) applyFX();

  const idle = parseFloat(document.getElementById('rngIdle').value);
  const sens = parseFloat(document.getElementById('rngSens').value);
  const boundsMode = document.getElementById('selBounds').value;

  const safe = 1.0 - overload*0.75;

  // ÏÜåÎ¶¨ Î∞òÏùë: cap + overload Í∞êÏá†
  const a = Math.min(1, amp * (2.4*sens) * safe);
  const d = Math.min(1, ampDelta * (18*sens) * safe);

  let energy = Math.min(1, idle*0.86 + a*0.82 + d*0.62 + touchSmooth*0.45);
  energy *= (0.85 + 0.15*safe);

  const burst = Math.min(1, d*1.05 + (touchSmooth>0.02 ? touchSmooth*0.35 : 0)) * (0.85 + 0.15*safe);

  // ÏÜçÎèÑ Ï†àÎ∞ò
  const t = now*0.001 * SPEED_SCALE;
  const breathe = 0.5 + 0.5*Math.sin(t*1.15 + 1.7*Math.sin(t*0.33));

  const freeze = Math.max(0, (energy*0.85) - (d*1.1));
  const rotSpeed = (0.0012 + energy*0.006 + burst*0.006) * (1 - 0.55*freeze) * SPEED_SCALE;
  rot += rotSpeed;

  const scale = 1.0 + (energy*(breathe-0.5))*0.30;

  const baseSpeed = (0.10 + idle*0.18 + energy*(0.08 + a*0.7) + burst*0.15) * SPEED_SCALE;

  const chaosBase = (0.75 + idle*1.05) + energy*(1.6 + a*5.2 + burst*10.0 + touchSmooth*3.0);
  const chaos = Math.min(18.0, chaosBase) * (0.75 + 0.25*safe);

  const centerPull = 0.004 + (1-energy)*0.006 + idle*0.002;
  const spread = energy*(a*0.018 + d*0.050 + touchSmooth*0.010 + burst*0.040);

  for(const p of pts){
    const l1 = Math.sin(t*1.25 + p.ph1 + p.seed*0.07);
    const l2 = Math.cos(t*1.55 + p.ph2 + p.seed*0.09);
    const l3 = Math.sin(t*0.85 + p.ph2*1.3);

    p.vx += (l1*0.9 + l3*0.4) * chaos;
    p.vy += (l2*0.9 + l1*0.35) * chaos;
    p.vz += (l3*0.8 + l2*0.3) * chaos*0.65;

    p.vx += (-p.x)*centerPull;
    p.vy += (-p.y)*centerPull;
    p.vz += (-p.z)*centerPull*0.6;

    p.vx += p.x*spread;
    p.vy += p.y*spread;
    p.vz += p.z*spread*0.6;

    const damp = 0.915 - energy*0.055;
    p.vx *= damp;
    p.vy *= damp;
    p.vz *= (0.93 - energy*0.045);

    p.x = (p.x + p.vx*baseSpeed) * scale + (1-scale)*p.x;
    p.y = (p.y + p.vy*baseSpeed) * scale + (1-scale)*p.y;
    p.z = (p.z + p.vz*baseSpeed) * (0.92 + 0.08*scale) + (1-(0.92 + 0.08*scale))*p.z;

    applyBounds(p, boundsMode);
  }

  for(let i=0;i<N;i++) projectInto(i);

  // ÎßÅÌÅ¨(ÏÑ†) ‚Äî Î©àÏ∂§ Î∞©ÏßÄ ÌïµÏã¨: qualityÏóê Îî∞Îùº ÏûêÎèôÏúºÎ°ú Ï§ÑÏûÑ + Ï¥ù cap
  const linkMode = document.getElementById('selLink').value;
  const baseLinks = (linkMode==="low") ? 5 : (linkMode==="mid" ? 8 : 12);

  const protect = Math.max(overload, burst*0.65);
  const maxLinksPerPointRaw = Math.max(3, Math.round(baseLinks * (1 - protect*0.50)));

  // qualityÍ∞Ä Îñ®Ïñ¥ÏßÄÎ©¥ Îçî Ï§ÑÏù∏Îã§
  const maxLinksPerPoint = Math.max(2, Math.round(maxLinksPerPointRaw * qScale(1.0, 0.45)));

  // linkDistÎèÑ qualityÍ∞Ä Îñ®Ïñ¥ÏßàÏàòÎ°ù Ï§ÑÏó¨ÏÑú ‚ÄúÏåàÎ∞ïÌïòÍ≤å‚Äù Î©àÏ∂§ Î∞©ÏßÄ
  const linkDistRaw = 44 + idle*26 + energy*(32 + a*170 + burst*95 + touchSmooth*140);
  const linkDist = linkDistRaw * qScale(1.0, 0.55);

  const linkAlphaBoost = (0.18 + idle*0.52 + energy*(0.52 + a*0.82 + burst*0.75)) * qScale(1.0, 0.70);

  const totalCap = Math.round(qScale(TOTAL_LINK_CAP_BASE, TOTAL_LINK_CAP_MIN));
  // overloadÍ∞Ä ÏïÑÏ£º ÎÜíÏúºÎ©¥ ÎßÅÌÅ¨Î•º Îçî Í∞ïÌïòÍ≤å ÏñµÏ†ú
  const totalCapSafe = Math.round(totalCap * (1 - overload*0.55));

  // overloadÍ∞Ä Í∑πÎã®Ï†ÅÏúºÎ°ú ÎÜíÏúºÎ©¥ ÎßÅÌÅ¨ ÏûêÏ≤¥Î•º Ïû†Íπê ÎÅäÏñ¥ ÌîÑÎ†àÏûÑÏùÑ ÏÇ¥Î¶∞Îã§
  if(overload < 0.92){
    drawLinks(linkDist, maxLinksPerPoint, linkAlphaBoost, Math.max(600, totalCapSafe));
  }

  // Í∏ÄÎ°úÏö∞(Îπõ): dtÍ∞Ä ÌÅ¨Î©¥ ÏûêÎèôÏúºÎ°ú ÏïΩÌôî/ÏÉùÎûµ
  let glow = Math.min(1, (a*0.9 + touchSmooth*0.7 + burst*0.9) * (0.85 + 0.15*safe));
  glow *= qScale(1.0, 0.0); // ÌíàÏßà Îñ®Ïñ¥ÏßÄÎ©¥ glow off

  // Ï†êÏùÑ ‚ÄúÏùºÎ∂ÄÎßå‚Äù Í∑∏Î†§ÏÑú ÌîÑÎ†àÏûÑ ÏÇ¥Î¶¨Í∏∞ (quality drop ÎÜíÏùÑ Îïå)
  const drawStep = (qDrop > 0.55) ? 2 : 1; // 1Ïù¥Î©¥ Ï†ÑÎ∂Ä, 2Î©¥ Ï†àÎ∞òÎßå

  if(glow > 0.02){
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = "rgba(255,255,255,1)";
    for(let i=0;i<N;i+=drawStep){
      const p = pr[i];
      const depthK = 0.8 + p.k*0.95;
      const r = (BASE_RADIUS + 2.0 + glow*2.4) * depthK;
      const aa = Math.min(0.18, (0.05 + glow*0.16) * (0.85 + 0.15*depthK));
      ctx.globalAlpha = aa;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // core points
  ctx.fillStyle = "rgba(255,255,255,1)";
  for(let i=0;i<N;i+=drawStep){
    const p = pr[i];
    const depthK = 0.8 + p.k*0.95;

    const rQuiet = BASE_RADIUS * depthK;
    const rActive = (BASE_RADIUS + ACTIVE_RADIUS_GAIN + a*2.2 + touchSmooth*1.1 + burst*1.1 + idle*0.7) * depthK;
    const r = rQuiet*(1-energy) + rActive*energy;

    const aQuiet = BASE_ALPHA + idle*0.12;
    const aActive = Math.min(1, 0.33 + a*1.05 + touchSmooth*0.55 + burst*0.70 + idle*0.22);
    const aa = (aQuiet*(1-energy) + aActive*energy) * (0.90 + 0.10*safe);

    ctx.globalAlpha = aa;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // UI: Ï†ÄÏ£ºÍ∏∞ ÏóÖÎç∞Ïù¥Ìä∏
  frame++;
  if((frame & 3) === 0){
    const inPct = Math.max(0, Math.min(1, amp*7.0));
    elMeterIn.style.width = (inPct*100).toFixed(1)+"%";
    elTxtAmp.textContent = `amp: ${amp.toFixed(4)} | dAmp: ${ampDelta.toFixed(4)} | overload:${overload.toFixed(3)} | qDrop:${qDrop.toFixed(3)} | dt:${dt.toFixed(1)}ms`;
    elMeterTouch.style.width = (touchSmooth*100).toFixed(1)+"%";
    elTxtFx.textContent =
      `touch:${FX_UI.touch.toFixed(3)} | drive:${FX_UI.driveAmt} | fold:${FX_UI.foldAmt} | f:${FX_UI.f.toFixed(0)}Hz | ring:${FX_UI.ringHz.toFixed(1)}Hz`;
    updateTopPill();
  }

  requestAnimationFrame(loop);
}

/* ==========================================================
   UI WIRING
========================================================== */
const ui = document.getElementById('ui');
function setUIVisible(v){
  ui.classList.toggle('hidden', !v);
  S.uiVisible = v ? 1 : 0;
  saveSettings(S);
}
document.getElementById('btnGear').addEventListener('click', ()=> setUIVisible(ui.classList.contains('hidden')));
document.getElementById('btnHideUI').addEventListener('click', ()=> setUIVisible(false));
setUIVisible((S.uiVisible ?? 0)===1);

function toggleFullscreen(){
  const el=document.documentElement;
  if(!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
}
document.getElementById('btnFS').addEventListener('click', toggleFullscreen);
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

document.getElementById('btnMuteQuick').addEventListener('click', ()=>{
  if(!audioCtx) return;
  isMuted = !isMuted;
  const m = isMuted ? 0 : (0.9 - overload*0.35);
  masterGain.gain.setTargetAtTime(m, audioCtx.currentTime, 0.02);
  document.getElementById('btnMuteQuick').textContent = isMuted ? 'üîà' : 'üîá';
});

document.getElementById('btnResume').addEventListener('click', async ()=>{
  ensureAudio();
  await audioCtx.resume();
  await listDevices();
  setStartButtons(!!micStream);
  updateTopPill();
});

document.getElementById('btnMicOn').addEventListener('click', async ()=> startMic(currentMicDeviceId));
document.getElementById('btnMicOff').addEventListener('click', ()=> stopMic());

document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    document.getElementById('panel-'+t.dataset.tab).classList.add('active');
    S.activeTab = t.dataset.tab;
    saveSettings(S);
  });
});
if(S.activeTab){
  const tabEl = document.querySelector(`.tab[data-tab="${S.activeTab}"]`);
  if(tabEl) tabEl.click();
}

/* restore */
applyValue('selN','220'); hookSave('selN');
applyValue('selLink','mid'); hookSave('selLink');
applyValue('selBounds','soft'); hookSave('selBounds');
applyValue('rngIdle','0.55'); hookSave('rngIdle');
applyValue('rngSens','2.10'); hookSave('rngSens');

N = parseInt(document.getElementById('selN').value,10);
initPoints();

/* ==========================================================
   START AUDIO
========================================================== */
function logStartError(e){
  console.error(e);
  startStatus(`<span class="danger">Start Audio Ïã§Ìå®:</span> ${String(e && e.message ? e.message : e)}<br/>
  üëâ ÌÅ¨Î°¨Ïù¥Î©¥ Ï£ºÏÜåÏ∞Ω Ïò§Î•∏Ï™Ω <b>üîí</b> ‚Üí Site settings ‚Üí <b>Sound ÌóàÏö©</b> ÌôïÏù∏<br/>
  üëâ Í∑∏Î¶¨Í≥† <b>https</b> ÎòêÎäî Î°úÏª¨ÏÑúÎ≤Ñ(Ïòà: Live Server)ÏóêÏÑú Ïó¨Îäî Í±∏ Ï∂îÏ≤ú`);
}

async function startAudioFlow(){
  try{
    ensureAudio();
    await audioCtx.resume();
    await initMIDI();
    await listDevices();

    document.getElementById('btnStartMic').disabled = false;
    document.getElementById('btnMicOn').disabled = false;

    btnPlayFile.disabled = !fileEl;
    btnStopFile.disabled = !fileEl;

    setStartButtons(!!micStream);
    updateTopPill();

    startStatus("Audio unlocked ‚úÖ  (ÏõêÌïòÎ©¥ Mic ON ÎòêÎäî Audio File Play)");
  }catch(e){
    logStartError(e);
  }
}

const btnStartAudio = document.getElementById('btnStartAudio');
btnStartAudio.addEventListener('click', startAudioFlow);
btnStartAudio.addEventListener('pointerup', startAudioFlow, {passive:true});

document.getElementById('btnStartMic').addEventListener('click', async ()=>{
  await startMic(currentMicDeviceId);
  document.getElementById('hint').style.display='none';
});
document.getElementById('btnStopMic').addEventListener('click', ()=> stopMic());

addEventListener('pointerdown', async ()=>{
  if(audioCtx && audioCtx.state==='suspended'){
    try{ await audioCtx.resume(); }catch(e){}
    updateTopPill();
  }
},{passive:true});

document.getElementById('btnFS').addEventListener('click', toggleFullscreen);
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

loop();
</script>
</body>
</html>
