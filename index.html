<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>SLEEEEEEEP â€“ THE SECOND SLEEP</title>

<!-- í”½ì…€ ê²Œì„ í°íŠ¸ -->
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SLEEP">
<meta name="theme-color" content="#000000">

<style>
:root{
  --appH: 100svh;
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;

  --fs-body: clamp(12px, 2.2vmin, 16px);
  --fs-strong: clamp(14px, 2.8vmin, 20px);
  --fs-small: clamp(11px, 1.8vmin, 14px);

  --pad-btn-y: clamp(6px, 1.1vmin, 10px);
  --pad-btn-x: clamp(10px, 1.8vmin, 20px);

  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);

  --accent: #f5f5f5;
}

*{
  box-sizing:border-box;
  margin:0;
  padding:0;
  -webkit-user-select:none;
  user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color: transparent;
}

html, body{
  width:100%;
  height:100%;
  overflow:hidden;
  touch-action:manipulation;
}

body{
  background:#000;
  color:var(--accent);
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans KR",sans-serif;
}

input, textarea{
  -webkit-user-select:text;
  user-select:text;
}

/* ê³µí†µ ë²„íŠ¼ */
.uiBtn{
  background:transparent;
  color:var(--accent);
  border:1px solid rgba(245,245,245,0.8);
  font-size:var(--fs-small);
  padding:var(--pad-btn-y) var(--pad-btn-x);
  font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  white-space:nowrap;
  cursor:pointer;
}
.uiBtn.flat{
  border:none;
  background:transparent;
}
.uiBtn[disabled]{
  opacity:0.4;
  pointer-events:none;
}

/* í”„ë ˆì„ ë°•ìŠ¤ */
.frameBox{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  top:calc(var(--frame) + var(--safe-t));
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  border:2px solid rgba(245,245,245,0.85);
  z-index:5;
  pointer-events:none;
}

/* íšŒì „ ì•ˆë‚´ */
#rotateOverlay{
  position:fixed;
  inset:0;
  z-index:2000;
  display:none;
  align-items:center;
  justify-content:center;
  text-align:center;
  background:#000;
  color:var(--accent);
  padding:40px;
  font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
}

/* ì‹œì‘ ê²Œì´íŠ¸ (ì§€ê¸ˆì€ ì•ˆ ì”€, í˜¹ì‹œ ëª°ë¼ ë‚¨ê²¨ë‘ ) */
#startOverlay{
  position:fixed;
  inset:0;
  z-index:1500;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.9);
  color:var(--accent);
  text-align:center;
  padding:24px;
}
#startInner{
  max-width:72ch;
  font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  line-height:1.8;
}

/* ì¤‘ì•™ ê¿€ë ì´ (ì „ì²´ ë°°ê²½) */
#blobCanvas{
  position:fixed;
  inset:0;
  z-index:0;
  width:100vw;
  height:100vh;
  display:block;
  image-rendering:pixelated;
}

/* 2ì¥ íƒ€ì´í‹€ (ì§€ê¸ˆì€ ì‚¬ìš© ì•ˆ í•¨) */
#titleOverlay{
  position:fixed;
  inset:0;
  z-index:30;
  display:none;
  align-items:center;
  justify-content:center;
  pointer-events:none;
}
#titleLines{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:8px;
}
.sleepLine{
  font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  letter-spacing:.16em;
  font-size:clamp(26px, 6.2vmin, 80px);
  text-transform:uppercase;
  white-space:nowrap;
  text-align:center;
  text-shadow:0 0 8px rgba(0,0,0,0.85);
}

/* ê²Œì„ ì¹´ë“œ */
#gameLayout{
  position:fixed;
  inset:0;
  z-index:20;
  padding:calc(var(--frame) + var(--safe-t))
           calc(var(--frame) + var(--safe-r))
           calc(var(--frame) + var(--safe-b) + 40px)
           calc(var(--frame) + var(--safe-l));
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
  transform: translateY(-4vh);
}
#gameCard{
  width:100%;
  max-width:1120px;
  height:auto;
  background:transparent;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:flex-start;
  gap:8px;
}
#gameScreenWrap{
  position:relative;
  width:100%;
  max-width:720px;
  aspect-ratio:16/9;
  background:#001307;
  border:1px solid rgba(245,245,245,0.4);
  box-shadow:0 0 0 2px rgba(0,0,0,0.85), 0 0 30px rgba(0,0,0,0.9);
  overflow:hidden;
  pointer-events:auto;
}
#gameCanvas{
  width:100%;
  height:100%;
  display:block;
  image-rendering:pixelated;
  position:relative;
  z-index:1;
}

/* ë‹¤í ì˜ìƒ (web/video/blobN.mp4) */
#docVideo{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  background:#000;
  z-index:0;
}

/* ë‹‰ë„¤ì„ ë¼ë²¨ */
#nameTag{
  position:absolute;
  left:8px;
  top:8px;
  padding:4px 8px;
  background:rgba(0,0,0,0.6);
  border:1px solid rgba(245,245,245,0.7);
  font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  font-size:clamp(9px,1.6vmin,12px);
}

/* ëŒ€í™”ì°½ â€“ ê²Œì„ í™”ë©´ ì•„ë˜ */
#dialogBar{
  width:100%;
  max-width:720px;
  display:flex;
  align-items:flex-end;
  justify-content:space-between;
  gap:12px;
  padding:10px 12px;
  background:rgba(0,0,0,0.9);
  border:1px solid rgba(245,245,245,0.6);
  box-shadow:0 0 18px rgba(0,0,0,0.9);
  position:relative;
  left:auto;
  bottom:auto;
  transform:none;
  pointer-events:auto;
}
#dialogTextWrap{
  flex:1;
}
#dialogText{
  font-family:"Courier New",ui-monospace,monospace;
  font-size:clamp(11px,2.0vmin,14px);
  line-height:1.7;
  white-space:pre-wrap;
}
#dialogHint{ display:none; }

/* ì„ íƒì§€ ë²„íŠ¼ ê·¸ë£¹ */
#dialogChoices{
  margin-top:6px;
  display:flex;
  flex-wrap:wrap;
  gap:6px;
}
#dialogChoices .uiBtn{
  font-size:clamp(10px,1.7vmin,13px);
  padding:4px 8px;
}

#dialogNext{
  flex:0 0 auto;
}

/* ì•ˆë‚´ ë°” â€“ ê²Œì„ ì°½ ë°–, ê²€ë¶‰ì€ ê¸€ì */
#hintBar{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  bottom:calc(var(--frame) + var(--safe-b) + 4px);
  max-width:720px;
  width:calc(100vw - 2*(var(--frame) + var(--safe-l)));
  padding:6px 10px;
  font-family:"Courier New",ui-monospace,monospace;
  font-size:clamp(10px,1.9vmin,13px);
  text-align:center;
  color:#7b1f2a;
  pointer-events:none;
}

/* ë§í’ì„  (ìš°ì£¼ êµ¬ê°„ì—ì„œ ì“¸ ìˆ˜ë„ ìˆì–´ì„œ ë‚¨ê²¨ë‘ ) */
#speechBubble{
  position:absolute;
  max-width:180px;
  padding:6px 8px;
  background:#f5f5f5;
  color:#000;
  border-radius:8px;
  border:1px solid #000;
  font-family:"Courier New",ui-monospace,monospace;
  font-size:10px;
  line-height:1.4;
  pointer-events:none;
  transform:translate(-50%, -100%);
}
#speechBubble::after{
  content:"";
  position:absolute;
  left:50%;
  bottom:-6px;
  transform:translateX(-50%);
  border-width:6px 6px 0 6px;
  border-style:solid;
  border-color:#f5f5f5 transparent transparent transparent;
}

/* HUD â€“ ë°©í–¥í‚¤ & ì•¡ì…˜ ë²„íŠ¼ */
#hudLeft{
  position:fixed;
  left:calc(var(--frame) + var(--safe-l));
  bottom:calc(var(--frame) + var(--safe-b));
  z-index:40;
}
#hudRight{
  position:fixed;
  right:calc(var(--frame) + var(--safe-r));
  bottom:calc(var(--frame) + var(--safe-b));
  z-index:40;
}

/* D-Pad */
.dpad{
  width:96px;
  height:96px;
  position:relative;
}
.dpad button{
  position:absolute;
  width:32px;
  height:32px;
  border-radius:6px;
  border:1px solid rgba(245,245,245,0.8);
  background:rgba(0,0,0,0.85);
  font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  font-size:10px;
  color:var(--accent);
  cursor:pointer;
}
.dpad button:active{
  background:#f5f5f5;
  color:#000;
}
.dpad-up{    left:32px; top:0; }
.dpad-down{  left:32px; bottom:0; }
.dpad-left{  left:0; top:32px; }
.dpad-right{ right:0; top:32px; }

/* ì•¡ì…˜ ë²„íŠ¼ */
#actionBtn{
  width:72px;
  height:72px;
  border-radius:50%;
  border:2px solid rgba(245,245,245,0.9);
  background:rgba(156,31,60,0.95);
  color:#fff;
  font-family:"Press Start 2P","Courier New",ui-monospace,monospace;
  font-size:11px;
  cursor:pointer;
  box-shadow:0 4px 0 rgba(0,0,0,0.9);
}
#actionBtn:active{
  transform:translateY(2px);
  box-shadow:0 2px 0 rgba(0,0,0,0.9);
}

/* í˜ì´ë“œ ìœ í‹¸ */
.fade-hidden{ opacity:0; transition:opacity 1800ms ease; }
.fade-show{ opacity:1; }

/* ìŠ¤í…Œì´ì§€ ì „í™˜ í˜ì´ë“œ */
#stageFade{
  position:fixed;
  inset:0;
  background:#000;
  z-index:50;
  opacity:0;
  pointer-events:none;
  transition:opacity 800ms ease;
}

/* ê°€ì‹œì„± ì œì–´ */
.hidden{ display:none !important; }

</style>
</head>
<body>

<canvas id="blobCanvas"></canvas>
<div class="frameBox" aria-hidden="true"></div>

<!-- íšŒì „ ì•ˆë‚´ -->
<div id="rotateOverlay">
  <div>
    <b>Landscape mode required</b><br/>
    Please rotate your device to continue.
  </div>
</div>

<!-- ì‹œì‘ ê²Œì´íŠ¸ (ì§€ê¸ˆì€ ì•ˆ ì”€) -->
<div id="startOverlay">
  <div id="startInner">
    <p>WELCOME TO</p>
    <p style="margin-top:8px;">SLEEEEEEEEP â€“ THE SECOND SLEEP</p>
    <p style="margin-top:18px;font-size:clamp(10px,2vmin,13px);">
      Tap START to continue.<br/>
      (ì¹´ë©”ë¼ì™€ ë§ˆì´í¬ëŠ” ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ, ì „ì²´ í™”ë©´ ë° ì‚¬ìš´ë“œ ì‚¬ìš©ì„ ìœ„í•´ í•œ ë²ˆ í„°ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.)
    </p>
    <button id="startBtn" class="uiBtn flat" style="margin-top:20px;">START</button>
  </div>
</div>

<!-- 2ì¥ íƒ€ì´í‹€ (ì§€ê¸ˆì€ ì‚¬ìš© ì•ˆ í•¨) -->
<div id="titleOverlay">
  <div id="titleLines">
    <div id="titleLine1" class="sleepLine"></div>
    <div id="titleLine2" class="sleepLine"></div>
    <div id="titleLine3" class="sleepLine"></div>
  </div>
</div>

<!-- ê²Œì„ ë ˆì´ì•„ì›ƒ -->
<div id="gameLayout" class="hidden">
  <div id="gameCard">
    <div id="gameScreenWrap">
      <canvas id="gameCanvas" width="320" height="180"></canvas>
      <!-- web/video/blob1~5.mp4 ì— ë‹¤í ì˜ìƒ ë„£ê¸° -->
      <video id="docVideo" class="hidden" playsinline webkit-playsinline></video>
      <div id="nameTag"></div>
      <div id="speechBubble" class="hidden">ì–´ì–´ì–´ì–´â€¦!!</div>
    </div>

    <!-- ëŒ€í™”ì°½ -->
    <div id="dialogBar" class="hidden">
      <div id="dialogTextWrap">
        <div id="dialogText"></div>
        <div id="dialogHint"></div>
        <div id="dialogChoices" class="hidden"></div>
      </div>
      <button id="dialogNext" class="uiBtn">NEXT</button>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="hudLeft" class="hidden">
  <div class="dpad">
    <button class="dpad-up"    data-dir="up">â–²</button>
    <button class="dpad-down"  data-dir="down">â–¼</button>
    <button class="dpad-left"  data-dir="left">â—€</button>
    <button class="dpad-right" data-dir="right">â–¶</button>
  </div>
</div>
<div id="hudRight" class="hidden">
  <button id="actionBtn">A</button>
</div>

<!-- ì•ˆë‚´ ë°” -->
<div id="hintBar" class="hidden"></div>

<!-- ìŠ¤í…Œì´ì§€ ì „í™˜ í˜ì´ë“œ -->
<div id="stageFade" class="hidden"></div>

<script>
(() => {
  /* ===== ìœ í‹¸ ===== */
  const qs = s => document.querySelector(s);
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  function setAppH(){
    document.documentElement.style.setProperty('--appH', window.innerHeight + 'px');
  }
  setAppH();
  addEventListener('resize', ()=>setTimeout(setAppH,50), {passive:true});

  /* ===== íšŒì „ ì•ˆë‚´ ===== */
  const rotateOverlay = qs('#rotateOverlay');
  function isPortrait(){
    const vv = window.visualViewport;
    const w = vv?vv.width:innerWidth;
    const h = vv?vv.height:innerHeight;
    return h > w;
  }
  function updateRotateOverlay(){
    rotateOverlay.style.display = isPortrait() ? 'flex' : 'none';
  }
  ['load','resize','orientationchange','pageshow'].forEach(ev=>{
    addEventListener(ev, updateRotateOverlay, {passive:true});
  });
  updateRotateOverlay();

  /* ===== ì˜¤ë””ì˜¤ ===== */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }
  async function primeAudio(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }
  async function ensureResumed(){
    ensureAudio();
    if(audioCtx.state === 'suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }

  /* ===== íƒ€ì ì†Œë¦¬ ===== */
  let typeBuffer = null;
  let lastTypeSoundTime = 0;

  function buildTypeBuffer(ctx){
    const duration   = 0.05;
    const sampleRate = ctx.sampleRate;
    const length     = Math.floor(sampleRate * duration);
    const buffer     = ctx.createBuffer(1, length, sampleRate);
    const data       = buffer.getChannelData(0);
    const freq       = 780;
    for(let i=0;i<length;i++){
      const t   = i / sampleRate;
      const env = Math.exp(-t * 11);
      const phase = 2*Math.PI*freq*t;
      data[i] = Math.sin(phase)*env*0.9;
    }
    return buffer;
  }

  function playTypeTick(){
    try{
      ensureAudio();
      const ctx = audioCtx;
      const now = ctx.currentTime || 0;
      if(now - lastTypeSoundTime < 0.05) return;
      lastTypeSoundTime = now;
      if(!typeBuffer) typeBuffer = buildTypeBuffer(ctx);
      const src = ctx.createBufferSource();
      src.buffer = typeBuffer;
      const g = ctx.createGain();
      g.gain.value = 0.35;
      src.connect(g).connect(ctx.destination);
      src.start();
    }catch(e){}
  }

  async function typeText(el, text, speed=40, append=false){
    if(!append) el.textContent = '';
    for(let i=0;i<text.length;i++){
      el.textContent += text[i];
      playTypeTick();
      await sleep(speed);
    }
  }

  /* ===== BGM ===== */
  let musicRunning = false;

  function playNote(freq, dur=0.16, vol=0.38, type='square'){
    try{
      ensureAudio();
      const ctx = audioCtx;
      const now = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(vol, now+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
      o.connect(g).connect(ctx.destination);
      o.start(now);
      o.stop(now+dur+0.05);
    }catch(e){}
  }

  // 1) ë°ê³  ê·€ì—¬ìš´ ìŒì•… (ì‚¬ì´ë“œë·°)
  function startBrightMusic(){
    musicRunning = false;
    setTimeout(()=>{
      if(musicRunning) return;
      musicRunning = true;
      const base = 523.25; // C5
      const pattern = [
        0, 4, 7, 12,
        7, 4, 0, 7,
        2, 5, 9, 14,
        9, 5, 2, 7
      ];
      let idx = 0;
      const stepDur = 150;

      function step(){
        if(!musicRunning) return;
        const semi = pattern[idx % pattern.length];
        const f = base * Math.pow(2, semi/12);
        playNote(f, 0.14, 0.4, 'square');
        idx++;
        setTimeout(step, stepDur);
      }
      step();
    }, 200);
  }

  // 2) ë¯¸ë¡œìš© ì§„ì§€í•œ ìŒì•…
  function startDarkMusic(){
    musicRunning = false;
    setTimeout(()=>{
      if(musicRunning) return;
      musicRunning = true;
      const base = 440; // A4
      const pattern = [0, 3, 7, 10, 3, 7, 0, -2];
      let idx = 0;
      const stepDur = 260;

      function step(){
        if(!musicRunning) return;
        const semi = pattern[idx % pattern.length];
        const f = base * Math.pow(2, semi/12);
        playNote(f, 0.22, 0.28, 'sawtooth');
        idx++;
        setTimeout(step, stepDur);
      }
      step();
    }, 400);
  }

  // 3) ì˜ìƒ êµ¬ê°„ìš© ì”ì”í•œ ìš°ì£¼ ì•°ë¹„ì–¸íŠ¸
  function startVideoAmbientMusic(){
    musicRunning = false;
    setTimeout(()=>{
      if(musicRunning) return;
      musicRunning = true;
      const base = 220; // A3
      const pattern = [0, 7, 12, 5, 0, -5];
      let idx = 0;

      function step(){
        if(!musicRunning) return;
        const semi = pattern[idx % pattern.length];
        const f = base * Math.pow(2, semi/12);
        // ì¡°ê¸ˆ ë” ê¸¸ê³ , ë³¼ë¥¨ ë‚®ê³ , sine ê³„ì—´
        playNote(f, 1.6, 0.16, 'sine');
        idx++;
        setTimeout(step, 1400 + Math.random()*800);
      }
      step();
    }, 600);
  }

  /* ===== ì¤‘ì•™ ê¿€ë ì´ (ë°°ê²½) ===== */
  const blobCanvas = qs('#blobCanvas');
  const blobCtx = blobCanvas.getContext('2d');
  let blobAlpha = 0;
  let blobFadeIn = true;
  let blobStartTime = performance.now();

  function resizeBlob(){
    const dpr = window.devicePixelRatio || 1;
    blobCanvas.width = innerWidth * dpr;
    blobCanvas.height = innerHeight * dpr;
    blobCtx.setTransform(dpr,0,0,dpr,0,0);
  }
  resizeBlob();
  addEventListener('resize', ()=>setTimeout(resizeBlob,30), {passive:true});

  function drawBlobBackground(){
    const w = innerWidth;
    const h = innerHeight;
    blobCtx.clearRect(0,0,w,h);
    if(blobAlpha <= 0) return;

    const t = (performance.now() - blobStartTime) * 0.001;
    const cx = w/2;
    const cy = h/2;
    const baseR = Math.min(w,h)*0.45;
    const N = 48;

    blobCtx.save();
    blobCtx.globalAlpha = blobAlpha;
    blobCtx.beginPath();
    for(let i=0;i<N;i++){
      const ang = (i/N)*Math.PI*2;
      const wob = 0.24*Math.sin(t*2 + i*0.7);
      const rr = baseR * (0.8 + wob);
      const x = cx + Math.cos(ang)*rr;
      const y = cy + Math.sin(ang)*rr*0.6;
      if(i===0) blobCtx.moveTo(x,y); else blobCtx.lineTo(x,y);
    }
    blobCtx.closePath();
    const grad = blobCtx.createRadialGradient(cx,cy,baseR*0.1, cx,cy,baseR*1.1);
    grad.addColorStop(0,'#000000');
    grad.addColorStop(1,'#101010');
    blobCtx.fillStyle = grad;
    blobCtx.strokeStyle = 'rgba(245,245,245,0.3)';
    blobCtx.lineWidth = 2.3;
    blobCtx.fill();
    blobCtx.stroke();
    blobCtx.restore();
  }

  function blobLoop(){
    requestAnimationFrame(blobLoop);
    const now = performance.now();
    if(blobFadeIn && blobAlpha < 1){
      const k = clamp((now - blobStartTime)/2000, 0, 1);
      blobAlpha = k;
    }
    drawBlobBackground();
  }
  blobLoop();

  /* ===== DOM ì°¸ì¡° ===== */
  const gameLayout      = qs('#gameLayout');
  const gameCanvas      = qs('#gameCanvas');
  const gctx            = gameCanvas.getContext('2d');
  const nameTag         = qs('#nameTag');
  const dialogBar       = qs('#dialogBar');
  const dialogTextElem  = qs('#dialogText');
  const dialogHint      = qs('#dialogHint');
  const dialogNextBtnEl = qs('#dialogNext');
  const dialogChoices   = qs('#dialogChoices');
  const hudLeftEl       = qs('#hudLeft');
  const hudRight        = qs('#hudRight');
  const startOverlayEl  = qs('#startOverlay');
  const stageFade       = qs('#stageFade');
  const hintBar         = qs('#hintBar');
  const speechBubble    = qs('#speechBubble');
  const gameScreenWrap  = qs('#gameScreenWrap');
  const docVideo        = qs('#docVideo');

  /* ë‹‰ë„¤ì„ ì²˜ë¦¬ */
  const nickRaw = (()=> {
    try{
      const v = localStorage.getItem('sleepNick');
      if(v && v.trim().length>0) return v.trim();
    }catch(e){}
    return '';
  })();

  const nick =
    nickRaw && nickRaw.toUpperCase() !== 'YOU'
      ? nickRaw
      : '';

  const nickForText = nick || 'í† ë¼';

  if(nick){
    nameTag.textContent = nick;
  }else{
    nameTag.style.display = 'none';
  }

  /* í”½ì…€ í† ë¼ */
  function drawRedRabbit(ctx, x, y, scale=1){
    ctx.fillStyle = '#ff3333';
    ctx.fillRect(x + 2*scale, y + 1*scale, 4*scale, 3*scale); // ë¨¸ë¦¬
    ctx.fillRect(x + 1*scale, y - 1*scale, 1*scale, 3*scale); // ê·€1
    ctx.fillRect(x + 4*scale, y - 1*scale, 1*scale, 3*scale); // ê·€2
    ctx.fillRect(x + 2*scale, y + 4*scale, 4*scale, 3*scale); // ëª¸í†µ
    ctx.fillRect(x + 6*scale, y + 4*scale, 2*scale, 2*scale); // ê¼¬ë¦¬
  }

  /* ê²Œì„ ì›”ë“œ(ì‚¬ì´ë“œë·° íŒŒíŠ¸) */
  const W = gameCanvas.width;
  const H = gameCanvas.height;
  const groundY = 145;
  const sofaX = 210;
  const sofaWidth = 70;
  const sofaHeight = 26;

  let playerX = 40;
  let playerY = groundY - 16;
  let playerVX = 0;
  let playerVY = 0;
  const speed = 0.14;
  const maxVX = 1.4;

  let moveLeft=false, moveRight=false, moveUp=false, moveDown=false, actionPressed=false;
  let gameStarted = false;
  let introWalkStartTime = 0;

  // ë¯¸ë¡œ ê´€ë ¨
  const tileSize = 16;
  const mazeMap = [
    "11111111111111111111",
    "10000001000000000001",
    "10111101011111111001",
    "10100100010000001001",
    "10100111110111101001",
    "10100000000100101001",
    "10101111110100101001",
    "10101000010100101001",
    "10101011110100101001",
    "10001000000000100001",
    "11111111111111111111"
  ];
  const mazeBlobs = [
    {tx:10, ty:2},
    {tx:10, ty:8},
    {tx:4,  ty:5},
    {tx:16, ty:5},
    {tx:10, ty:5}
  ];
  let blobVisited = [false,false,false,false,false];

  const mazeStartTile = {tx:1, ty:8};
  const mazeStartTargetX = (mazeStartTile.tx + 0.5)*tileSize;
  const mazeStartY = (mazeStartTile.ty + 0.5)*tileSize;

  let mazePlayerX = mazeStartTargetX;
  let mazePlayerY = mazeStartY;
  const mazeSpeed = 1.1;

  function isWall(px, py){
    const tx = Math.floor(px / tileSize);
    const ty = Math.floor(py / tileSize);
    if(ty < 0 || ty >= mazeMap.length) return true;
    if(tx < 0 || tx >= mazeMap[0].length) return true;
    return mazeMap[ty].charAt(tx) === '1';
  }

  // ìƒíƒœ
  // 'title', 'introWalk', 'introDialog', 'freeToSofa', 'seatedDialog',
  // 'freeToBlob', 'blobDialog', 'transitionToMaze', 'mazeEnter', 'maze',
  // 'mazeDialog', 'blobVideo', 'blobVideoBlack'
  let gameState = 'title';

  /* ëŒ€í™” ì‹œìŠ¤í…œ */
  let currentLines = [];
  let currentIdx = 0;
  let typing = false;
  let fullLine = '';
  let onDialogDone = null;
  let dialogMode = 'normal'; // 'normal' | 'blobIntro' | 'blobStory' | 'blobDecision'
  let currentBlobIndex = -1;

  function clearChoices(){
    dialogChoices.innerHTML = '';
    dialogChoices.classList.add('hidden');
    dialogNextBtnEl.classList.remove('hidden');
  }

  function showChoiceButtons(options){
    dialogChoices.innerHTML = '';
    options.forEach(opt=>{
      const b = document.createElement('button');
      b.className = 'uiBtn';
      b.textContent = opt.label;
      b.addEventListener('click', async ()=>{
        await ensureResumed();
        opt.onSelect();
      });
      dialogChoices.appendChild(b);
    });
    dialogChoices.classList.remove('hidden');
    dialogNextBtnEl.classList.add('hidden');
  }

  async function showDialog(lines, hint='', cb=null){
    dialogMode = 'normal';
    currentLines = lines;
    currentIdx = 0;
    onDialogDone = cb;

    if(hint && hint.trim().length){
      hintBar.textContent = hint;
      hintBar.classList.remove('hidden');
    }else{
      hintBar.textContent = '';
      hintBar.classList.add('hidden');
    }

    clearChoices();
    dialogBar.classList.remove('hidden');
    await typeCurrentLine();
  }

  async function typeCurrentLine(){
    const line = currentLines[currentIdx] || '';
    fullLine = line;
    typing = true;
    await typeText(dialogTextElem, line, 40, false);
    typing = false;
  }

  dialogNextBtnEl.addEventListener('click', async ()=>{
    await ensureResumed();

    if(dialogMode === 'blobStory'){
      if(typing){
        typing = false;
        dialogTextElem.textContent = fullLine;
        return;
      }
      await showBlobDecision(currentBlobIndex);
      return;
    }

    if(dialogMode !== 'normal'){
      return;
    }

    if(typing){
      typing = false;
      dialogTextElem.textContent = fullLine;
      return;
    }

    currentIdx++;
    if(currentIdx >= currentLines.length){
      if(onDialogDone) onDialogDone();
      return;
    }
    await typeCurrentLine();
  });

  /* HUD ì…ë ¥ */
  const dpad = hudLeftEl.querySelector('.dpad');
  if(dpad){
    dpad.addEventListener('pointerdown', (e)=>{
      const btn = e.target.closest('button[data-dir]');
      if(!btn) return;
      const dir = btn.dataset.dir;
      if(dir==='left')  moveLeft=true;
      if(dir==='right') moveRight=true;
      if(dir==='up')    moveUp=true;
      if(dir==='down')  moveDown=true;
      e.target.setPointerCapture(e.pointerId);
    });
    dpad.addEventListener('pointerup', (e)=>{
      const btn = e.target.closest('button[data-dir]');
      if(!btn) return;
      const dir = btn.dataset.dir;
      if(dir==='left')  moveLeft=false;
      if(dir==='right') moveRight=false;
      if(dir==='up')    moveUp=false;
      if(dir==='down')  moveDown=false;
    });
    dpad.addEventListener('pointercancel', ()=>{
      moveLeft=moveRight=moveUp=moveDown=false;
    });
  }

  const actionBtn = qs('#actionBtn');
  actionBtn.addEventListener('pointerdown', ()=>{ actionPressed = true; });
  actionBtn.addEventListener('pointerup', ()=>{ actionPressed = false; });
  actionBtn.addEventListener('pointercancel', ()=>{ actionPressed = false; });

  window.addEventListener('keydown', (e)=>{
    if(e.code === 'ArrowLeft')  moveLeft=true;
    if(e.code === 'ArrowRight') moveRight=true;
    if(e.code === 'ArrowUp')    moveUp=true;
    if(e.code === 'ArrowDown')  moveDown=true;
    if(e.code === 'Space')      actionPressed=true;
  });
  window.addEventListener('keyup', (e)=>{
    if(e.code === 'ArrowLeft')  moveLeft=false;
    if(e.code === 'ArrowRight') moveRight=false;
    if(e.code === 'ArrowUp')    moveUp=false;
    if(e.code === 'ArrowDown')  moveDown=false;
    if(e.code === 'Space')      actionPressed=false;
  });

  /* ê²Œì„ ì•ˆ ì‘ì€ ê¿€ë ì´ (ì‚¬ì´ë“œë·°) */
  function drawInnerBlob(ctx){
    const cx = W/2;
    const cy = 70;
    const baseR = 40;
    const N = 22;
    const t = performance.now()*0.001;

    ctx.beginPath();
    for(let i=0;i<N;i++){
      const ang = (i/N)*Math.PI*2;
      const wob = 0.25*Math.sin(t*2 + i*0.6);
      const r = baseR * (0.8 + wob);
      const x = cx + Math.cos(ang)*r;
      const y = cy + Math.sin(ang)*r*0.6;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = '#001307';
    ctx.strokeStyle = 'rgba(190,230,190,0.4)';
    ctx.lineWidth = 1.5;
    ctx.fill();
    ctx.stroke();
  }

  /* ===== ì—…ë°ì´íŠ¸ ===== */
  function update(){
    if(!gameStarted) return;

    if(gameState === 'blobVideo' || gameState === 'blobVideoBlack'){
      return;
    }

    if(gameState === 'introWalk'){
      const elapsed = (performance.now() - introWalkStartTime) / 1000;
      const startX = -24;
      const targetX = 56;
      const t = clamp(elapsed / 1.2, 0, 1);
      playerX = startX + (targetX - startX)*t;
      playerY = groundY - 16;
      if(t >= 1){
        gameState = 'introDialog';
        startIntroDialog();
      }
      return;
    }

    if(gameState === 'mazeDialog'){
      return;
    }

    if(gameState === 'freeToSofa' || gameState === 'freeToBlob'){
      let ax = 0;
      if(moveLeft)  ax -= speed;
      if(moveRight) ax += speed;
      playerVX += ax;
      playerVX *= 0.82;
      playerVX = clamp(playerVX, -maxVX, maxVX);

      playerX += playerVX;
      playerY = groundY - 16;

      if(playerX < 8){
        playerX = 8;
        playerVX = 0;
      }
      if(playerX > W-24){
        playerX = W-24;
        playerVX = 0;
      }

      if(gameState === 'freeToSofa'){
        const nearSofa = (playerX > sofaX - 12);
        if(nearSofa && actionPressed){
          sitOnSofa();
        }
      }

      if(gameState === 'freeToBlob'){
        const centerX = W/2;
        const nearBlob = (Math.abs(playerX - centerX) < 20);
        if(nearBlob && actionPressed){
          startBlobDialog();
        }
      }
    }

    if(gameState === 'seatedDialog'){
      playerVX = 0;
      playerVY = 0;
    }

    if(gameState === 'transitionToMaze'){
      // ê·¸ëƒ¥ í˜ì´ë“œ ì¤‘: ì—…ë°ì´íŠ¸ ì—†ìŒ
      return;
    }

    if(gameState === 'mazeEnter'){
      const targetX = mazeStartTargetX;
      const dir = targetX > mazePlayerX ? 1 : -1;
      const step = 0.7;
      mazePlayerX += dir * step;

      if( (dir > 0 && mazePlayerX >= targetX) ||
          (dir < 0 && mazePlayerX <= targetX) ){
        mazePlayerX = targetX;
        gameState = 'maze';
      }
      return;
    }

    if(gameState === 'maze'){
      let dx = 0, dy = 0;
      if(moveLeft)  dx -= mazeSpeed;
      if(moveRight) dx += mazeSpeed;
      if(moveUp)    dy -= mazeSpeed;
      if(moveDown)  dy += mazeSpeed;

      let nx = mazePlayerX + dx;
      let ny = mazePlayerY + dy;

      if(!isWall(nx, mazePlayerY)) mazePlayerX = nx;
      if(!isWall(mazePlayerX, ny)) mazePlayerY = ny;

      checkMazeBlobs();
    }
  }

  /* ë¯¸ë¡œì—ì„œ ë¸”ë™í™€ ê·¼ì ‘ ì²´í¬ */
  function checkMazeBlobs(){
    for(let i=0;i<mazeBlobs.length;i++){
      if(blobVisited[i]) continue;
      const b = mazeBlobs[i];
      const bx = (b.tx+0.5)*tileSize;
      const by = (b.ty+0.5)*tileSize;
      const dx = mazePlayerX - bx;
      const dy = mazePlayerY - by;
      const dist = Math.hypot(dx,dy);
      if(dist < 10){
        startBlobEncounter(i);
        break;
      }
    }
  }

  /* ===== ê·¸ë¦¬ê¸° ===== */
  function drawSideView(){
    const ctx = gctx;
    ctx.clearRect(0,0,W,H);

    ctx.fillStyle = '#05210f';
    ctx.fillRect(0,0,W,H);

    drawInnerBlob(ctx);

    ctx.fillStyle = '#0b2f18';
    ctx.fillRect(0, groundY, W, H-groundY);
    ctx.strokeStyle = '#193d23';
    ctx.beginPath();
    ctx.moveTo(0,groundY);
    ctx.lineTo(W,groundY);
    ctx.stroke();

    ctx.fillStyle = '#164524';
    ctx.fillRect(8, groundY-10, 32, 10);

    ctx.save();
    ctx.translate(sofaX, groundY - sofaHeight);
    ctx.fillStyle = '#e8c93b';
    ctx.fillRect(0, 8, sofaWidth, sofaHeight-8);
    ctx.fillRect(4, 0, sofaWidth-8, 10);
    ctx.fillStyle = '#c6a629';
    ctx.fillRect(6, 12, sofaWidth-12, sofaHeight-14);
    ctx.fillStyle = '#b09324';
    ctx.fillRect(4, sofaHeight-2, 8, 4);
    ctx.fillRect(sofaWidth-12, sofaHeight-2, 8, 4);
    ctx.restore();

    const scale = 3;
    drawRedRabbit(ctx, playerX, playerY, scale);
  }

  function drawMazeView(){
    const ctx = gctx;
    ctx.clearRect(0,0,W,H);

    ctx.fillStyle = '#001307';
    ctx.fillRect(0,0,W,H);

    for(let y=0;y<mazeMap.length;y++){
      for(let x=0;x<mazeMap[0].length;x++){
        const tile = mazeMap[y].charAt(x);
        const px = x*tileSize;
        const py = y*tileSize;
        if(tile === '1'){
          ctx.fillStyle = '#062711';
          ctx.fillRect(px,py,tileSize,tileSize);
          ctx.strokeStyle = '#0f3c1e';
          ctx.strokeRect(px+0.5,py+0.5,tileSize-1,tileSize-1);
        }else{
          ctx.fillStyle = '#07351a';
          ctx.fillRect(px,py,tileSize,tileSize);
        }
      }
    }

    const t = performance.now()*0.001;
    mazeBlobs.forEach(b=>{
      const cx = (b.tx+0.5)*tileSize;
      const cy = (b.ty+0.5)*tileSize;
      const r = 4 + Math.sin(t*2 + b.tx*0.5 + b.ty*0.8)*1.5;
      ctx.beginPath();
      ctx.arc(cx,cy,r,0,Math.PI*2);
      ctx.fillStyle = '#000';
      ctx.fill();
      ctx.strokeStyle = 'rgba(190,230,190,0.8)';
      ctx.lineWidth = 1;
      ctx.stroke();
    });

    const rx = mazePlayerX - 6;
    const ry = mazePlayerY - 6;
    drawRedRabbit(ctx, rx, ry, 1.2);
  }

  function drawBlobVideoView(){
    const ctx = gctx;
    ctx.clearRect(0,0,W,H);
    const scale = 3;
    const px = W/2 - 4*scale;
    const py = H - 32 - 10;
    drawRedRabbit(ctx, px, py, scale);
  }

  function drawBlobVideoBlackView(){
    const ctx = gctx;
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#000000';
    ctx.fillRect(0,0,W,H);
  }

  function draw(){
    if(gameState === 'blobVideo'){
      drawBlobVideoView();
      return;
    }
    if(gameState === 'blobVideoBlack'){
      drawBlobVideoBlackView();
      return;
    }
    if(gameState === 'maze' || gameState === 'mazeEnter' || gameState === 'mazeDialog' || gameState === 'transitionToMaze'){
      drawMazeView();
      return;
    }
    drawSideView();
  }

  function gameLoop(){
    requestAnimationFrame(gameLoop);
    update();
    draw();
  }
  gameLoop();

  /* ===== ìƒíƒœ ì „í™˜ ===== */
  function startGameScene(){
    gameLayout.classList.remove('hidden');
    hudLeftEl.classList.remove('hidden');
    hudRight.classList.remove('hidden');

    gameStarted = true;

    setTimeout(()=>{
      gameState = 'introWalk';
      introWalkStartTime = performance.now();
    }, 800);
  }

  async function startIntroDialog(){
    const lines = [
      "ì•ˆë…•?",
      `ë‚˜ëŠ” ${nickForText}ì´ì•¼.`,
      "ì–´ë•Œ, ê·¸ë˜ë„ í•œ 8ë¶„ ê±¸ì–´ì˜¨ ê²ƒ ê°™ì€ë°, ì–´ë”” í¸í•œ ê³³ì— ì•‰ì•„ë³¼ê¹Œ?",
      "ì•„ì•„ì•—? ì €ê¸° ì†ŒíŒŒê°€ ìˆë‹¤! ì €ê¸°ì— ì•‰ì•„ë³´ì!!"
    ];
    const hint =
      "ì•ˆë‚´ : ìºë¦­í„°ë¥¼ ìš°ì¸¡ìœ¼ë¡œ ì´ë™ì‹œì¼œ ë²„íŠ¼(A)ì„ ëˆŒëŸ¬ ì‡¼íŒŒì— ì•‰ìœ¼ì„¸ìš”.\n" +
      "ë‹¹ì‹ ë„ ì–´ë”” ì¢‹ì€ ìë¦¬ë¥¼ ì¡ì•„ ì•‰ì•„ë³´ì„¸ìš”.";
    await showDialog(lines, hint, ()=>{
      gameState = 'freeToSofa';
    });
  }

  function sitOnSofa(){
    if(gameState !== 'freeToSofa') return;
    gameState = 'seatedDialog';

    playerX = sofaX + sofaWidth*0.4;
    playerY = groundY - sofaHeight - 2;
    playerVX = 0;
    playerVY = 0;

    const lines = [
      "ì•‰ì•˜ì–´?",
      "ê·¸ë˜. ì–´ë•Œ?",
      "ì§§ì€ ì‹œê°„ì˜ ì—¬ì •ì€ ì¡°ê¸ˆ ê´œì°®ì•„?",
      "ì§€ê¸ˆë¶€í„°ëŠ” ì œ 2ì¥. ê·¸ëŸ¬ë‹ˆê¹Œ THE SECOND SLEEPì´ì•¼!",
      "THE FIRST SLEEPê°€ ëˆˆê³¼ ê·€ë¡œ íƒ€ìë¥¼ ì¸ì‹í•´ë‚˜ê°€ëŠ” ìˆœê°„ì´ì—ˆë‹¤ë©´, ì§€ê¸ˆì€ ì–´ì©Œë©´â€¦",
      "ë¨¸ë¦¬ë¡œ?",
      "ê·¸ëŸ¬ë‹ˆê¹Œ ê·¸ëƒ¥ ì¸ì‹ë˜ì–´ë²„ë ¸ë˜ ê·¸ê²ƒë“¤ì„ í•œ ë²ˆ ë” ìƒê°í•´ë³´ëŠ” ì‹œê°„ì´ì§€!",
      "ë„ˆëŠ” í¸í•˜ê²Œ ì•‰ì•„ìˆì–´. ì´ì œ ë‚´ê°€ í•œ ë²ˆ ì›€ì§ì—¬ë³¼ê²Œ."
    ];
    showDialog(lines, '', ()=>{
      playerY = groundY - 16;
      playerX = sofaX + sofaWidth*0.2;
      gameState = 'freeToBlob';
      const hint =
        "ì•ˆë‚´ : ìºë¦­í„°ë¥¼ í™”ë©´ ì¤‘ì•™ì˜ ê¿€ë ì´ ê°€ê¹Œì´ ì´ë™ì‹œí‚¨ ë’¤, A ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.\n" +
        "ë‹¹ì‹ ì€ ê·¸ëŒ€ë¡œ í¸í•˜ê²Œ ì•‰ì•„, ë°©ê¸ˆ ë“¤ì—ˆë˜ ê²ƒë“¤ì„ í•œ ë²ˆ ë” ë– ì˜¬ë ¤ ë³´ì„¸ìš”.";
      hintBar.textContent = hint;
      hintBar.classList.remove('hidden');
    });
  }

  function startBlobDialog(){
    if(gameState !== 'freeToBlob') return;
    gameState = 'blobDialog';

    playerX = W/2 - 8;
    playerY = groundY - 16;

    const lines = [
      "ìš°ë¦¬ëŠ” ì§€ê¸ˆë¶€í„° ì´ ê¿€ë ê¿€ë  ê±°ë¦¬ëŠ” ë¬¼ì§ˆ ì†ìœ¼ë¡œ ë“¤ì–´ê°ˆê±°ì•¼.",
      "ì´ê±´ ì–¸ì œë¶€í„° ì¡´ì¬í–ˆëŠ”ì§€ëŠ” ëª¨ë¥´ì§€ë§Œ, ì–´ëŠ ìˆœê°„ë¶€í„° ìƒê²¨ë‚œ ì‘ì¶•ëœ ì‘ì–´ë¦¬ ê°™ì€ ê±°ê±°ë“ .",
      "ì¤€ë¹„ê°€ ë˜ë©´ ë²„íŠ¼ì„ ëˆŒëŸ¬ì¤˜.",
      "í•¨ê»˜ ê·¸ê²ƒì˜ ì†ìœ¼ë¡œ ë“¤ì–´ê°€ë³´ì."
    ];
    hintBar.textContent = '';
    hintBar.classList.add('hidden');
    showDialog(lines, '', ()=>{
      goToMaze();
    });
  }

  // ğŸ”¥ ìš°ì£¼ ë¹¨ë ¤ë“¤ê¸° ì—°ì¶œ ì—†ì´ ë°”ë¡œ ë¯¸ë¡œë¡œ
  function goToMaze(){
    gameState = 'transitionToMaze';
    dialogBar.classList.add('hidden');
    hintBar.classList.add('hidden');

    stageFade.classList.remove('hidden');
    requestAnimationFrame(()=>{
      stageFade.style.opacity = '1';
    });

    musicRunning = false;
    startDarkMusic();

    setTimeout(()=>{
      mazePlayerX = (mazeStartTile.tx - 1) * tileSize;
      mazePlayerY = mazeStartY;

      stageFade.style.opacity = '0';
      setTimeout(()=>{
        stageFade.classList.add('hidden');
      }, 800);

      gameState = 'mazeEnter';
      dialogBar.classList.add('hidden');
      hintBar.classList.add('hidden');
    }, 900);
  }

  /* ===== ë¯¸ë¡œ ë¸”ë™í™€ ì´ë²¤íŠ¸ ===== */

  const blobStories = [
    "ì´ê³³ì´ ë‚˜ë¥¼ ì›í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì–´ì©” ìˆ˜ ì—†ì–´ìš”. í•˜ì§€ë§Œ ì €ëŠ” ì„ íƒì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ì´ê³³ì— ë¨¸ë¬´ëŠ” ê²ƒë°–ì—.",
    "ì‹¬ë¼êµ¬ì§€ë€ ìƒë¥˜ì— íŠ¸ëŸ­ì´ ì„°ë‹¤. 2ê°œì˜ ë¬¼íƒ±í¬ê°€ 2ë¶„ê°„ ì¿ë¹› ì˜¤ì—¼ìˆ˜ë¥¼ ìŸì•„ëƒˆë‹¤. 30ë¶„ ë’¤ ë˜‘ê°™ì€ ì¥ë©´ì´ ë°˜ë³µëë‹¤. í‘œë°±ê³µì¥ì˜ â€˜ë”ëŸ¬ìš´ ë¬¼â€™ì€ ë°©ë¥˜ë˜ì–´ ë§ˆì„ê³¼ ê°•ìœ¼ë¡œ íë¥¸ë‹¤.",
    "ë©€ë¦¬ì„œ ë³¼ ë• ë™ì‚°ì´ë‚˜ ì–¸ë•ì²˜ëŸ¼ ë³´ì˜€ë‹¤. ...ê°€ì¥ ë†’ì€ ê³³ì€ ë†’ì´ê°€ 10më¥¼ ë„˜ê³  ë©´ì ì€ 5ã¢ê°€ ëœë‹¤. ê±°ëŒ€í•œ ì“°ë ˆê¸° ì‚° ìœ„ì— ê¹Œë§ˆê·€EPê°€ ë§´ëŒê³  ë“¤ê°œëŠ” ì”í•´ë¬¼ì„ ë¬¼ì–´ëœ¯ëŠ”ë‹¤.",
    "GPSë¥¼ ë„£ì€ ì‹ ë°œì€ í¬ì²œì‹œ ì™¸ê³½ì§€ì—­ìœ¼ë¡œ ì´ë™í–ˆë‹¤. ì´í‹€ ë’¤ ì–‘ì£¼ì‹œë¡œ ë³´ë‚´ì¡Œë‹¤. ì¼ì£¼ì¼ ë’¤ ì¸ì²œ í•­êµ¬ì—ì„œ ë°œê²¬ëë‹¤. ì•½ 4ì£¼ ë’¤, íƒ€ì´ ì•„ë€ì•¼ì˜ë¼í…Ÿ ë¡±ëŒë¥´ì•„ ì‹œì¥ì—ì„œ ì‹ í˜¸ë¥¼ ë³´ëƒˆë‹¤. í•œêµ­ì—ì„œ ì•½ 3500km ë–¨ì–´ì§„ ê³³ì´ë‹¤.",
    "ë§¤ì¼ ì•„ì¹¨ ì™¼ë°œ ì•ìª½ì— ë¶•ëŒ€ë¥¼ ê°ëŠ”ë‹¤. 2011ë…„ ì‚°ì—…ì¬í•´ë¡œ ì™¼ìª½ ë°œê°€ë½ 5ê°œ ì „ë¶€ë¥¼ ìƒì—ˆë‹¤. ë¶•ëŒ€ëŠ” ë°œê°€ë½ ëŒ€ì‹  ëª¸ì˜ ê· í˜•ì„ ì¡ì•„ì¤€ë‹¤. í•˜ì§€ë§Œ ì–¼ë§ˆ ëª» ê°€ ëª¨ì–‘ì´ ííŠ¸ëŸ¬ì§„ë‹¤."
  ];

  function startBlobEncounter(index){
    currentBlobIndex = index;
    blobVisited[index] = true;
    gameState = 'mazeDialog';
    dialogMode = 'blobIntro';
    clearChoices();
    dialogBar.classList.remove('hidden');
    hintBar.classList.add('hidden');
    showBlobIntro();
  }

  async function showBlobIntro(){
    const line = "ì–´ì–´ì—‡â€¦? ë¬´ìŠ¨ ì†Œë¦¬ê°€ ë“¤ë ¤ì˜¨ë‹¤.";
    typing = true;
    fullLine = line;
    await typeText(dialogTextElem, line, 40, false);
    typing = false;

    dialogMode = 'blobIntro';
    showChoiceButtons([
      {
        label: "ë“¤ì–´ë³´ê¸°",
        onSelect: ()=> {
          dialogMode = 'blobStory';
          playBlobStory(currentBlobIndex);
        }
      },
      {
        label: "ë¬´ì‹œí•˜ê¸°",
        onSelect: ()=> {
          clearChoices();
          dialogBar.classList.add('hidden');
          gameState = 'maze';
          dialogMode = 'normal';
        }
      }
    ]);
  }

  async function playBlobStory(index){
    clearChoices();
    dialogMode = 'blobStory';
    const line = blobStories[index] || "";
    typing = true;
    fullLine = line;
    await typeText(dialogTextElem, line, 35, false);
    typing = false;
    dialogNextBtnEl.classList.remove('hidden');
  }

  async function showBlobDecision(index){
    dialogMode = 'blobDecision';
    const line = "í â€¦ ë“¤ì–´ê°€ë³¼ê¹Œ?";
    typing = true;
    fullLine = line;
    await typeText(dialogTextElem, line, 40, false);
    typing = false;

    showChoiceButtons([
      {
        label: "ë“¤ì–´ê°€ì§€",
        onSelect: ()=>{
          clearChoices();
          startBlobVideo(index);
        }
      },
      {
        label: "ë” ë‘˜ëŸ¬ë³´ê¸°",
        onSelect: ()=>{
          clearChoices();
          dialogBar.classList.add('hidden');
          gameState = 'maze';
          dialogMode = 'normal';
        }
      }
    ]);
  }

  /* ===== ë¸”ë™í™€ ë¹„ë””ì˜¤ (ë‹¤í ì˜ìƒ) ===== */

  function getBlobVideoSrc(index){
    const i = index + 1;
    return `video/blob${i}.mp4`;
  }

  function startBlobVideo(index){
    gameState = 'blobVideo';
    dialogMode = 'normal';
    dialogBar.classList.add('hidden');
    hintBar.classList.add('hidden');

    // ê¸°ì¡´ BGM ë„ê³ , ì˜ìƒìš© ìš°ì£¼ ì•°ë¹„ì–¸íŠ¸ ì‹œì‘
    musicRunning = false;
    startVideoAmbientMusic();

    const src = getBlobVideoSrc(index);
    docVideo.src = src;
    docVideo.currentTime = 0;
    docVideo.classList.remove('hidden');

    ensureResumed().then(()=>{
      docVideo.play().catch(()=>{});
    });

    const onEnded = ()=>{
      docVideo.removeEventListener('ended', onEnded);
      endBlobVideoToBlack();
    };
    docVideo.addEventListener('ended', onEnded);

    setTimeout(()=>{
      if(gameState === 'blobVideo'){
        endBlobVideoToBlack();
      }
    }, 5*60*1000);
  }

  function endBlobVideoToBlack(){
    docVideo.pause();
    docVideo.classList.add('hidden');
    gameState = 'blobVideoBlack';
    musicRunning = false; // ì˜ìƒ ëë‚˜ë©´ ì•°ë¹„ì–¸íŠ¸ë„ ì •ì§€
  }

  /* ===== ì‹œì‘: ìë™ìœ¼ë¡œ ê²Œì„ ì‹œì‘ ===== */
  async function startAll(){
    try{
      await primeAudio();
      await ensureResumed();
    }catch(e){}
    startOverlayEl.style.display = 'none';
    blobStartTime = performance.now();
    blobFadeIn = true;
    blobAlpha = 0;
    startBrightMusic();
    startGameScene();
  }

  // ìŠ¤í¬ë¦½íŠ¸ ë¡œë”©ë˜ë©´ ë°”ë¡œ ì‹œì‘
  startAll().catch(()=>{});

})();
</script>
</body>
</html>
