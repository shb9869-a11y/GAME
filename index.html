<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>TouchMe + Mic â€” Dramatic Visual + IO Debug + Visual Fullscreen</title>
<style>
  :root{color-scheme:dark}
  html,body{height:100%;margin:0}
  body{
    background:#0b0b0b;color:#eee;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    touch-action:manipulation;
    -webkit-tap-highlight-color:transparent;
  }

  #hint{
    position:fixed; inset:0; z-index:2147483647;
    display:flex; align-items:center; justify-content:center;
    pointer-events:none;
    background:radial-gradient(circle, rgba(255,255,255,0.06), transparent 55%);
  }
  #hint .box{
    max-width:820px;
    padding:18px 16px;
    border:1px solid #333;border-radius:16px;
    background:rgba(15,15,15,.86);
    text-align:center;
    pointer-events:none;
  }
  .hintS{font-size:12px;opacity:.75;line-height:1.5}

  #wrap{max-width:1200px;margin:0 auto;padding:18px}
  .card{background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px}

  .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
  .row>*{flex:1; min-width:220px}

  button,input,select{
    width:100%;
    padding:12px; border-radius:12px;
    border:1px solid #333; background:#0f0f0f; color:#eee;
  }
  button{cursor:pointer}
  button:disabled{opacity:.55; cursor:not-allowed}

  label{display:block;margin-top:10px;font-size:13px;opacity:.9}
  .meter{height:10px;border-radius:999px;background:#1a1a1a;border:1px solid #2a2a2a;overflow:hidden}
  .meter>div{height:100%;width:0%;background:#eaeaea;opacity:.9}

  .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:12px}
  @media(min-width:980px){ .grid{grid-template-columns:1fr 1fr} }
  .viz{background:#0f0f0f;border:1px solid #2a2a2a;border-radius:14px;padding:10px}
  canvas{width:100%;height:240px;display:block;border-radius:10px;background:#0a0a0a}

  audio{width:100%; margin-top:8px}

  #log{
    margin-top:12px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
    font-size:12px;
    background:#0f0f0f;border:1px solid #2a2a2a;border-radius:12px;
    padding:12px;white-space:pre-wrap;
  }

  /* Visual fullscreen overlay fallback */
  #fsOverlay{
    position:fixed; inset:0; z-index:2147483000;
    background:#000;
    display:none;
  }
  #fsTopBar{
    position:absolute; left:12px; right:12px; top:12px;
    display:flex; gap:10px;
  }
  #fsTopBar button{width:auto}
  #fsCanvas{
    position:absolute; inset:0;
    width:100%; height:100%;
    display:block;
  }
</style>
</head>
<body>

<div id="hint">
  <div class="box">
    <h2 style="margin:0 0 8px">TouchMe + Mic (Dramatic Visual)</h2>
    <div style="opacity:.92;line-height:1.55">
      <b>í™”ë©´ ì•„ë¬´ ê³³ 1íšŒ í´ë¦­/í„°ì¹˜</b> â†’ ì˜¤ë””ì˜¤/MIDI ì¤€ë¹„<br/>
      <b>Test Beep</b>ë¡œ ì¶œë ¥ í™•ì¸ â†’ <b>Mic On</b><br/>
      TouchMe ëˆ„ë¥´ëŠ” ë™ì•ˆ FXâ†‘ + ë¹„ì£¼ì–¼ ë” ë‚œë¦¬ë‚¨
    </div>
    <div class="hintS" style="margin-top:8px">
      â€» ë§ˆì´í¬ëŠ” HTTPS/localhostê°€ ì œì¼ ì•ˆì •ì <br/>
      â€» í°ì—ì„œ â€œì…ë ¥ì€ ë˜ëŠ”ë° ì¶œë ¥ì´ ì•ˆ ë¨â€ì´ë©´: íƒ­/ì‚¬ì´íŠ¸ ìŒì†Œê±°, ë¬´ìŒëª¨ë“œ, ë¸”ë£¨íˆ¬ìŠ¤ ì¶œë ¥ í™•ì¸
    </div>
  </div>
</div>

<div id="wrap">
  <div class="card">

    <div class="row">
      <button id="micBtn" disabled>Mic On</button>
      <button id="micOffBtn" disabled>Mic Off</button>
      <button id="beepBtn" disabled>Test Beep (ì¶œë ¥ í™•ì¸)</button>
      <button id="panicBtn" disabled>Panic (Mute)</button>
    </div>

    <div class="row">
      <div>
        <label>Input Device (ë§ˆì´í¬ ì„ íƒ)</label>
        <select id="inSel" disabled><option value="">(Start í›„ ë¡œë”©)</option></select>
      </div>
      <div>
        <label>Output Device (í¬ë¡¬/HTTPSë©´ ì„ íƒ ê°€ëŠ¥)</label>
        <select id="outSel" disabled><option value="">(ê¸°ë³¸ ì¶œë ¥)</option></select>
        <div class="hintS">â€» setSinkId ì§€ì› í™˜ê²½ì—ì„œë§Œ ë™ì‘</div>
      </div>
    </div>

    <label>Audio Monitor (ì—¬ê¸°ì„œ ì‹¤ì œ ì¶œë ¥ì´ ë‚˜ê° / í°ì€ â–¶ï¸ í•„ìš”í•  ìˆ˜ ìˆìŒ)</label>
    <audio id="monitor" controls autoplay playsinline></audio>

    <div class="row">
      <div>
        <label>Mic level</label>
        <div class="meter"><div id="micBar"></div></div>
      </div>
      <div>
        <label>TouchMe velocity</label>
        <div class="meter"><div id="midiBar"></div></div>
      </div>
    </div>

    <div class="row">
      <div><label>DRY (ì›ìŒ)</label><input id="dry" type="range" min="0" max="100" value="78" disabled></div>
      <div><label>WET MAX (TouchMe ëˆ„ë¥¼ ë•Œ FX)</label><input id="wetmax" type="range" min="0" max="100" value="92" disabled></div>
      <div><label>Dramatic (ë¹„ì£¼ì–¼ ê³¼ì¥)</label><input id="drama" type="range" min="0" max="100" value="78" disabled></div>
      <div><label>Strobe (ë³€í™”ëŸ‰ í­ë°œ)</label><input id="strobe" type="range" min="0" max="100" value="70" disabled></div>
    </div>

    <div class="row">
      <div><label>Smear (Delay/Blur)</label><input id="smear" type="range" min="0" max="100" value="65" disabled></div>
      <div><label>Muffle (LPF)</label><input id="muffle" type="range" min="0" max="100" value="70" disabled></div>
      <div><label>Crush (ë­‰ê°œì§)</label><input id="crush" type="range" min="0" max="100" value="35" disabled></div>
      <button id="fsBtn" disabled style="font-weight:800">VISUAL FULLSCREEN</button>
    </div>

    <div class="grid">
      <div class="viz">
        <label>MIC WAVE (ìˆ˜ìŒ íŒŒí˜•)</label>
        <canvas id="waveMic"></canvas>
      </div>
      <div class="viz">
        <label>REACTIVE FIELD (TouchMe + Mic ë°˜ì‘)</label>
        <canvas id="field"></canvas>
      </div>
    </div>

    <div id="log">waitingâ€¦</div>
  </div>
</div>

<!-- Fullscreen overlay fallback -->
<div id="fsOverlay">
  <canvas id="fsCanvas"></canvas>
  <div id="fsTopBar">
    <button id="fsExitBtn">Exit</button>
    <button id="fsMirrorBtn">Mirror</button>
  </div>
</div>

<script>
(() => {
  const $=id=>document.getElementById(id);
  const logEl=$("log");
  const log=(m)=>{ logEl.textContent = m + "\n" + logEl.textContent; };

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const norm=(x)=>clamp(x/100,0,1);

  // =========================
  // Audio state
  // =========================
  let ctx=null;

  let micStream=null, micSrc=null;

  let dryGain=null, wetGain=null, master=null;
  let lp=null, delay=null, fb=null, shaper=null;

  // Output routing via audio element (better on mobile + allows setSinkId)
  let mediaDest=null;
  const monitor=$("monitor");

  // analysers
  let anMic=null;    // mic waveform
  let anOut=null;    // output level

  // MIDI (TouchMe)
  let midiVel=0;     // 0..1
  let pressed=0;
  let wetGate=0;

  // crush
  let crushHold=0, crushCounter=0;

  // =========================
  // Canvas
  // =========================
  const cvMic=$("waveMic");
  const cvField=$("field");
  const gMic=cvMic.getContext("2d");
  const gField=cvField.getContext("2d");

  const cvFS=$("fsCanvas");
  const gFS=cvFS.getContext("2d");

  let dpr=1;
  function resizeCanvas(){
    dpr=Math.max(1,window.devicePixelRatio||1);
    // normal
    [cvMic,cvField].forEach(cv=>{
      const r=cv.getBoundingClientRect();
      cv.width=Math.floor(r.width*dpr);
      cv.height=Math.floor(r.height*dpr);
    });
    // fullscreen overlay
    cvFS.width=Math.floor(window.innerWidth*dpr);
    cvFS.height=Math.floor(window.innerHeight*dpr);
  }

  // =========================
  // UI enable
  // =========================
  function enableUI(on){
    ["micBtn","micOffBtn","beepBtn","panicBtn","dry","wetmax","smear","muffle","crush","drama","strobe","fsBtn","inSel","outSel"]
      .forEach(id=>$(id).disabled=!on);
  }

  // =========================
  // DSP helpers
  // =========================
  function makeCurve(amount){
    const n=4096;
    const curve=new Float32Array(n);
    const k=amount*40;
    for(let i=0;i<n;i++){
      const x=(i/(n-1))*2-1;
      curve[i]=(1+k)*x/(1+k*Math.abs(x));
    }
    return curve;
  }

  function buildAudioGraph(){
    ctx = new (window.AudioContext||window.webkitAudioContext)({ latencyHint: "interactive" });

    master = ctx.createGain();
    master.gain.value = 0.95;

    // route WebAudio -> MediaStreamDestination -> <audio>
    mediaDest = ctx.createMediaStreamDestination();
    master.connect(mediaDest);
    monitor.srcObject = mediaDest.stream;
    monitor.muted = false;
    monitor.volume = 1.0;

    dryGain = ctx.createGain();
    wetGain = ctx.createGain();

    dryGain.gain.value = norm($("dry").value);
    wetGain.gain.value = 0.0;

    dryGain.connect(master);
    wetGain.connect(master);

    // FX chain: mic -> shaper -> lp -> delay -> (crush) -> wetGain
    shaper = ctx.createWaveShaper();
    shaper.curve = makeCurve(0.85);
    shaper.oversample = "4x";

    lp = ctx.createBiquadFilter();
    lp.type="lowpass";
    lp.frequency.value = 2000;
    lp.Q.value = 0.7;

    delay = ctx.createDelay(1.0);
    delay.delayTime.value = 0.18;

    fb = ctx.createGain();
    fb.gain.value = 0.35;

    delay.connect(fb);
    fb.connect(delay);

    // analysers
    anMic = ctx.createAnalyser();
    anMic.fftSize = 2048;
    anMic.smoothingTimeConstant = 0.80;

    anOut = ctx.createAnalyser();
    anOut.fftSize = 2048;
    anOut.smoothingTimeConstant = 0.85;

    master.connect(anOut);
  }

  function updateParams(){
    if(!ctx) return;

    dryGain.gain.value = norm($("dry").value);

    const smear = norm($("smear").value);
    const muffle= norm($("muffle").value);

    lp.frequency.value    = lerp(16000, 520, muffle);
    delay.delayTime.value = lerp(0.035, 0.30, smear);
    fb.gain.value         = clamp(lerp(0.04, 0.90, smear), 0, 0.93);
  }

  function updateWetGate(){
    const wetMax = norm($("wetmax").value);
    const on = pressed>0 ? 1 : 0;
    const target = on ? clamp(wetMax*(0.20 + 0.95*midiVel), 0, 1) : 0;

    wetGate = lerp(wetGate, target, on ? 0.20 : 0.10);
    wetGain.gain.value = wetGate;

    if(!on) midiVel *= 0.985;
    $("midiBar").style.width = `${Math.round(midiVel*100)}%`;
  }

  // =========================
  // Device enumeration + output select
  // =========================
  async function refreshDevices(){
    if(!navigator.mediaDevices?.enumerateDevices) return;
    const devices = await navigator.mediaDevices.enumerateDevices();

    const ins = devices.filter(d=>d.kind==="audioinput");
    const outs= devices.filter(d=>d.kind==="audiooutput");

    const inSel=$("inSel");
    const outSel=$("outSel");

    inSel.innerHTML = `<option value="">(ê¸°ë³¸ ì…ë ¥)</option>`;
    ins.forEach((d,i)=>{
      const opt=document.createElement("option");
      opt.value=d.deviceId;
      opt.textContent=d.label || `Input ${i+1}`;
      inSel.appendChild(opt);
    });

    outSel.innerHTML = `<option value="">(ê¸°ë³¸ ì¶œë ¥)</option>`;
    outs.forEach((d,i)=>{
      const opt=document.createElement("option");
      opt.value=d.deviceId;
      opt.textContent=d.label || `Output ${i+1}`;
      outSel.appendChild(opt);
    });

    log(`Devices: in=${ins.length}, out=${outs.length} (ë¼ë²¨ì€ Mic í—ˆìš© í›„ ë” ì˜ ëœ¸)`);
  }

  async function setOutputDevice(deviceId){
    if(typeof monitor.setSinkId !== "function"){
      log("Output select: setSinkId ë¯¸ì§€ì›(ë˜ëŠ” HTTPS ì•„ë‹˜ / ëª¨ë°”ì¼ ì œí•œ)");
      return;
    }
    try{
      await monitor.setSinkId(deviceId || "");
      log(deviceId ? "Output set âœ…" : "Output default âœ…");
    }catch(e){
      log("setSinkId error: " + e.message);
    }
  }

  // =========================
  // Mic
  // =========================
  async function micOn(){
    const deviceId = $("inSel").value;
    const constraints = {
      audio: {
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false,
        ...(deviceId ? { deviceId: { exact: deviceId } } : {})
      }
    };

    micStream = await navigator.mediaDevices.getUserMedia(constraints);

    const t = micStream.getAudioTracks()[0];
    log("Mic track: " + (t?.readyState||"n/a") + " / muted=" + (t?.muted ?? "n/a") + " / " + (t?.label||"no label"));

    micSrc = ctx.createMediaStreamSource(micStream);

    // analyser tap
    micSrc.connect(anMic);

    // DRY always
    micSrc.connect(dryGain);

    // WET path
    micSrc.connect(shaper);
    shaper.connect(lp);
    lp.connect(delay);

    // crush (sample-hold) implemented in JS-ish way by a tiny ScriptProcessor (compatible)
    const sp = ctx.createScriptProcessor(1024, 1, 1);
    delay.connect(sp);

    sp.onaudioprocess = (e)=>{
      const input = e.inputBuffer.getChannelData(0);
      const out   = e.outputBuffer.getChannelData(0);
      const crush = norm($("crush").value);

      const holdN = Math.max(1, (1 + crush*36)|0);
      for(let i=0;i<input.length;i++){
        if(crushCounter<=0){ crushHold=input[i]; crushCounter=holdN; }
        else crushCounter--;
        // mix original + hold
        const s = lerp(input[i], crushHold, clamp(crush*0.95,0,1));
        out[i]=s;
      }
    };

    sp.connect(wetGain);

    log("Mic ON âœ… (ì›ìŒ+FX+ë¹„ì£¼ì–¼)");
  }

  function micOff(){
    if(micSrc){ try{ micSrc.disconnect(); }catch(e){} micSrc=null; }
    if(micStream){ try{ micStream.getTracks().forEach(tr=>tr.stop()); }catch(e){} micStream=null; }
    log("Mic OFF");
  }

  // =========================
  // Beep / Panic
  // =========================
  function testBeep(){
    const osc=ctx.createOscillator();
    const g=ctx.createGain();
    osc.type="sine";
    osc.frequency.value=880;
    g.gain.value=0;
    g.connect(master);

    const t=ctx.currentTime;
    g.gain.setValueAtTime(0.0, t);
    g.gain.linearRampToValueAtTime(0.18, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.25);

    osc.connect(g);
    osc.start(t);
    osc.stop(t+0.26);

    log("BEEP ğŸ”ˆ (ì•ˆ ë“¤ë¦¬ë©´: íƒ­/ì‚¬ì´íŠ¸ ìŒì†Œê±°, OS ì¶œë ¥ ì¥ì¹˜, ë¸”ë£¨íˆ¬ìŠ¤ ì¶œë ¥ í™•ì¸)");
  }

  function panic(){
    const prev=master.gain.value;
    master.gain.value=0;
    setTimeout(()=>master.gain.value=prev, 250);
    log("PANIC");
  }

  // =========================
  // MIDI (TouchMe)
  // =========================
  async function initMIDI(){
    if(!navigator.requestMIDIAccess){
      log("MIDI âŒ (WebMIDI ë¯¸ì§€ì›)");
      return;
    }
    const access = await navigator.requestMIDIAccess({sysex:false});
    const inputs = Array.from(access.inputs.values());
    if(inputs.length===0){
      log("MIDI ì…ë ¥ ì—†ìŒ (TouchMe ì—°ê²° í™•ì¸)");
      return;
    }

    // ì²« ì…ë ¥ì— ì—°ê²°
    const inp = inputs[0];
    inp.onmidimessage = (msg)=>{
      const [st,,vel]=msg.data;
      const cmd = st & 0xF0;

      if(cmd===0x90 && vel>0){
        pressed++;
        midiVel = clamp(vel/127,0,1);
      } else if(cmd===0x80 || (cmd===0x90 && vel===0)){
        pressed = Math.max(0, pressed-1);
      }
    };

    log("MIDI âœ… connected: " + (inp.name || "input"));
  }

  // =========================
  // Visuals (dramatic)
  // =========================
  function drawWave(ctx2d, analyser, W, H){
    ctx2d.clearRect(0,0,W,H);
    if(!analyser) return {rms:0};

    const data=new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(data);

    // waveform
    ctx2d.strokeStyle="#eaeaea";
    ctx2d.lineWidth=2*dpr;
    ctx2d.beginPath();
    const mid=H/2;

    let rms=0;
    for(let i=0;i<data.length;i++){
      const x=(i/(data.length-1))*W;
      const v=(data[i]-128)/128;
      const y=mid + v*(H*0.42);
      if(i===0) ctx2d.moveTo(x,y); else ctx2d.lineTo(x,y);
      rms += v*v;
    }
    ctx2d.stroke();
    rms = Math.sqrt(rms/data.length);
    return {rms};
  }

  // Particle field
  const P=[];
  const N=320;

  function initParticles(){
    P.length=0;
    const W=cvField.width, H=cvField.height;
    for(let i=0;i<N;i++){
      P.push({
        x:Math.random()*W,
        y:Math.random()*H,
        vx:(Math.random()*2-1)*0.8*dpr,
        vy:(Math.random()*2-1)*0.8*dpr,
        w:Math.random()
      });
    }
  }

  // AGC + change detection for â€œê³„ì† ë“œë¼ë§ˆí‹±â€
  let rmsSm=0, rmsPrev=0;
  let burst=0; // accumulative â€œstrobe energyâ€
  let agc=1.0;

  function drawField(micRms){
    const W=cvField.width, H=cvField.height;

    // auto gain: ì‘ì€ ì†Œë¦¬ë„ í¬ê²Œ ë³´ì´ê²Œ
    // (ë„ˆë¬´ ì»¤ì§€ë©´ ì²œì²œíˆ ë‚®ì¶¤)
    const targetAgc = micRms > 0.001 ? clamp(0.12 / micRms, 0.7, 10.0) : 8.0;
    agc = lerp(agc, targetAgc, 0.03);

    rmsSm = lerp(rmsSm, micRms*agc, 0.10);
    const delta = Math.abs(rmsSm - rmsPrev);
    rmsPrev = rmsSm;

    // touch + deltaê°€ ë²„ìŠ¤íŠ¸ë¥¼ ë§Œë“ ë‹¤ (ì²« ì‹œì‘ë§Œ ì•„ë‹ˆê³  ê³„ì† â€œíˆ­íˆ­â€ íŠ)
    const strobe = norm($("strobe").value);
    const drama  = norm($("drama").value);
    const touch  = clamp(midiVel,0,1);
    const on = pressed>0 ? 1 : 0;

    // deltaê°€ ì‘ì•„ë„ ê³¼ì¥í•´ì„œ ëˆ„ì ì‹œí‚¤ê¸°
    const dBoost = Math.pow(clamp(delta*10.0,0,1), 0.55);
    const baseKick = 0.010 + 0.040*drama; // ë¬´ì¡°ê±´ ì•½ê°„ì˜ ì›€ì§ì„ ìœ ì§€
    const add = (baseKick + 0.45*dBoost)* (0.35 + 0.65*strobe) + on*(0.08 + 0.55*touch);
    burst = clamp(burst*0.92 + add, 0, 1.25);

    // background trail (burstê°€ ë†’ìœ¼ë©´ ë” ê°•í•˜ê²Œ í”ì )
    const trail = clamp(0.12 + 0.18*burst, 0.10, 0.34);
    gField.fillStyle=`rgba(10,10,10,${trail})`;
    gField.fillRect(0,0,W,H);

    // center influence
    const cx=W/2, cy=H/2;
    const energy = clamp(rmsSm*3.0,0,1);
    const k = clamp(0.10 + 0.90*(0.55*energy + 0.45*touch + 0.55*burst), 0, 1);

    const gather = (on ? (0.40 + 2.0*touch) : 0.10) * (0.35 + 1.05*k);

    // draw particles
    gField.strokeStyle="#eaeaea";
    gField.lineWidth=1*dpr;

    for(const p of P){
      const dx=cx-p.x, dy=cy-p.y;

      // turbulence: energy + burst drives â€œì˜ìƒ íŠâ€
      const turb = (0.4 + 6.5*energy + 9.0*burst) * (0.35 + 0.65*drama) * dpr;
      const nx=(Math.random()*2-1)*turb;
      const ny=(Math.random()*2-1)*turb;

      p.vx += (dx/W) * gather + nx;
      p.vy += (dy/H) * gather + ny;

      // damping lower when burst high => ë” íŠ„ë‹¤
      const damp = clamp(0.90 - 0.16*burst - 0.08*on*touch, 0.62, 0.92);
      p.vx *= damp;
      p.vy *= damp;

      p.x += p.vx;
      p.y += p.vy;

      // wrap
      if(p.x<0) p.x+=W; else if(p.x>W) p.x-=W;
      if(p.y<0) p.y+=H; else if(p.y>H) p.y-=H;

      const r = (0.7 + 3.2*(0.55*energy + 0.45*burst + 0.35*touch))*dpr;
      gField.globalAlpha = 0.12 + 0.78*(0.25*energy + 0.55*burst + 0.35*touch);
      gField.beginPath();
      gField.arc(p.x,p.y,r,0,Math.PI*2);
      gField.stroke();
    }
    gField.globalAlpha=1;

    // center ring
    gField.globalAlpha = 0.22 + 0.65*k;
    gField.lineWidth = (1 + 3.0*k)*dpr;
    const R = (18 + 200*k)*dpr;
    gField.beginPath();
    gField.arc(cx,cy,R,0,Math.PI*2);
    gField.stroke();
    gField.globalAlpha=1;

    // update mic bar with AGC energy too
    $("micBar").style.width = `${Math.round(clamp(energy,0,1)*100)}%`;
  }

  // =========================
  // Fullscreen (visual only)
  // =========================
  let fsOpen=false;
  let fsMirror=false;

  function openVisualFS(){
    fsOpen=true;
    $("fsOverlay").style.display="block";
    resizeCanvas();
    // attempt real fullscreen
    const el=$("fsOverlay");
    if(el.requestFullscreen) el.requestFullscreen().catch(()=>{});
  }
  function closeVisualFS(){
    fsOpen=false;
    $("fsOverlay").style.display="none";
    if(document.fullscreenElement) document.exitFullscreen().catch(()=>{});
  }

  function drawToFS(){
    if(!fsOpen) return;
    const W=cvFS.width, H=cvFS.height;
    gFS.clearRect(0,0,W,H);
    // draw field canvas scaled to full screen
    const src=cvField;
    if(!src.width || !src.height) return;

    gFS.save();
    if(fsMirror){
      gFS.translate(W,0);
      gFS.scale(-1,1);
    }
    gFS.drawImage(src, 0,0, src.width, src.height, 0,0, W,H);
    gFS.restore();
  }

  // =========================
  // Main loop
  // =========================
  function loop(){
    if(ctx){
      updateWetGate();

      // wave
      const W=cvMic.width, H=cvMic.height;
      const res = drawWave(gMic, anMic, W, H);

      // field
      drawField(res.rms);

      // mirror to fullscreen if open
      drawToFS();
    }
    requestAnimationFrame(loop);
  }

  // =========================
  // Start (í¬ë¡¬ ëŒ€ì‘: í™”ë©´ ì•„ë¬´ ê³³ 1íšŒ ì œìŠ¤ì²˜)
  // =========================
  async function startAll(ev){
    if(ctx) return;
    ev.preventDefault?.();
    ev.stopPropagation?.();

    // remove hint
    $("hint")?.remove();

    buildAudioGraph();
    await ctx.resume();

    // Try to autoplay monitor stream (mobile often needs this)
    try{ await monitor.play(); }catch(e){ log("monitor.play() blocked: â–¶ï¸ ëˆŒëŸ¬ì¤˜ì•¼ í•  ìˆ˜ ìˆìŒ"); }

    enableUI(true);
    updateParams();

    resizeCanvas();
    initParticles();
    window.addEventListener("resize", ()=>{ resizeCanvas(); initParticles(); });

    await refreshDevices();     // labels may be empty until mic allowed
    await initMIDI();           // TouchMe
    log("STARTED âœ…  state=" + ctx.state + "  sr=" + ctx.sampleRate);

    requestAnimationFrame(loop);
  }

  ["pointerdown","touchstart","mousedown"].forEach(t=>{
    window.addEventListener(t, startAll, {capture:true, passive:false});
  });

  // =========================
  // UI bindings
  // =========================
  enableUI(false);

  $("micBtn").addEventListener("click", async ()=>{
    try{
      await micOn();
      $("micBtn").disabled=true;
      $("micOffBtn").disabled=false;

      // after mic permission, refresh device labels (important for laptop "no input" debugging)
      await refreshDevices();
    }catch(e){
      log("Mic error: " + e.message);
    }
  });

  $("micOffBtn").addEventListener("click", ()=>{
    micOff();
    $("micBtn").disabled=false;
    $("micOffBtn").disabled=true;
  });

  $("beepBtn").addEventListener("click", ()=>{ if(ctx) testBeep(); });
  $("panicBtn").addEventListener("click", ()=>{ if(ctx) panic(); });

  ["dry","wetmax","smear","muffle","crush","drama","strobe"].forEach(id=>{
    $(id).addEventListener("input", updateParams);
  });

  $("outSel").addEventListener("change", (e)=> setOutputDevice(e.target.value));

  $("fsBtn").addEventListener("click", openVisualFS);
  $("fsExitBtn").addEventListener("click", closeVisualFS);
  $("fsMirrorBtn").addEventListener("click", ()=>{ fsMirror=!fsMirror; });

  document.addEventListener("fullscreenchange", ()=>{
    if(!document.fullscreenElement && fsOpen){
      // user exited fullscreen via system UI
      $("fsOverlay").style.display="none";
      fsOpen=false;
    }
  });

})();
</script>
</body>
</html>
