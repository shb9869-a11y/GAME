<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TouchMe â€“ Mic Monitor + Generating FX + I/O Select (Stable)</title>
  <style>
    :root{color-scheme:dark}
    html,body{height:100%}
    body{
      margin:0; padding:18px; background:#0b0b0b; color:#eee;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      touch-action:manipulation;
    }
    .wrap{max-width:1200px;margin:0 auto}
    .card{background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px;position:relative}
    h1{font-size:18px;margin:0 0 10px}
    p{opacity:.9;line-height:1.55;margin:8px 0}
    label{display:block;margin-top:10px;font-size:13px;opacity:.92}
    input,select,button{
      width:100%; margin-top:6px; padding:12px; border-radius:12px;
      border:1px solid #333; background:#0f0f0f; color:#eee
    }
    button{cursor:pointer; user-select:none; -webkit-tap-highlight-color:transparent}
    button:disabled{opacity:.55;cursor:not-allowed}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row>*{flex:1;min-width:240px}
    .hint{font-size:12px;opacity:.78;margin-top:6px}
    .mono{
      margin-top:12px;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      font-size:12px;background:#0f0f0f;border:1px solid #2a2a2a;border-radius:12px;
      padding:12px;white-space:pre-wrap
    }
    .meter{height:10px;border-radius:999px;background:#1a1a1a;border:1px solid #2a2a2a;overflow:hidden;margin-top:6px}
    .meter>div{height:100%;width:0%;background:#eaeaea;opacity:.9}
    .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:12px}
    @media(min-width:980px){ .grid{grid-template-columns:1fr 1fr} }
    .viz{background:#0f0f0f;border:1px solid #2a2a2a;border-radius:14px;padding:10px}
    canvas{width:100%;height:200px;display:block;border-radius:10px;background:#0a0a0a}
    audio{width:100%; margin-top:8px}
    /* Start ë²„íŠ¼ì´ ì–´ë–¤ ë ˆì´ì–´ì—ë„ ì•ˆ ë¨¹íˆê²Œ */
    #startBtn{position:relative; z-index:9999; pointer-events:auto; touch-action:manipulation; font-weight:800}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Mic Monitor(ì›ìŒ) + TouchMe ì œë„ˆë ˆì´íŒ… FX + I/O ì„ íƒ (í¬ë¡¬ ì•ˆì •íŒ)</h1>
    <p>
      ìˆœì„œ: <b>Start â†’ (Test Beep) â†’ Input/Output ì„ íƒ â†’ Mic On</b>.<br/>
      TouchMe ëˆ„ë¥´ëŠ” ë™ì•ˆë§Œ FXê°€ ì˜¬ë¼ê°€ê³ , ë–¼ë©´ ì›ìŒìœ¼ë¡œ ëŒì•„ê°€.
    </p>
    <p class="hint">
      ë§ˆì´í¬ëŠ” <b>HTTPS/localhost</b>ì—ì„œ ê°€ì¥ ì•ˆì •ì . ì´ì–´í°/í—¤ë“œí° ê¶Œì¥(í•˜ìš¸ë§ ë°©ì§€).
    </p>

    <div class="row">
      <button id="startBtn" type="button">Start</button>
      <button id="beepBtn" type="button" disabled>Test Beep (ì¶œë ¥ í™•ì¸)</button>
      <button id="micBtn" type="button" disabled>Mic On</button>
      <button id="micOffBtn" type="button" disabled>Mic Off</button>
    </div>

    <div class="row">
      <div>
        <label>Input Device (ë§ˆì´í¬)</label>
        <select id="inSel" disabled><option value="">(Start í›„ ë¡œë”©)</option></select>
        <div class="hint">Mic On ì „ì— ì›í•˜ëŠ” ë§ˆì´í¬ë¡œ ë°”ê¿€ ìˆ˜ ìˆì–´.</div>
      </div>
      <div>
        <label>Output Device (ìŠ¤í”¼ì»¤/í—¤ë“œí°)</label>
        <select id="outSel" disabled><option value="">(ê¸°ë³¸ ì¶œë ¥)</option></select>
        <div class="hint">Chrome/HTTPSì—ì„œë§Œ ì„ íƒ ê°€ëŠ¥í•œ ê²½ìš°ê°€ ë§ìŒ(setSinkId).</div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>MIDI Input (TouchMe)</label>
        <select id="midiIn" disabled><option>Start í›„ í™œì„±í™”</option></select>
        <div class="hint">TouchMe ë…¸íŠ¸ ON ë™ì•ˆ FX â†‘ / ë…¸íŠ¸ OFF ì‹œ FX â†“</div>
      </div>
      <div>
        <label>Monitor Output (ì´ ì˜¤ë””ì˜¤ê°€ ì‹¤ì œ ì¶œë ¥)</label>
        <audio id="monitor" controls autoplay playsinline></audio>
        <div class="hint">ì—¬ê¸°ì„œ â–¶ï¸ê°€ ë©ˆì¶°ìˆìœ¼ë©´ ì¶œë ¥ì´ ë¬´ìŒì¼ ìˆ˜ ìˆìŒ.</div>
      </div>
    </div>

    <div class="row">
      <div>
        <label class="small">Mic Level</label>
        <div class="meter"><div id="micBar"></div></div>
      </div>
      <div>
        <label class="small">TouchMe (velocity)</label>
        <div class="meter"><div id="midiBar"></div></div>
      </div>
    </div>

    <div class="row">
      <div><label>THRU (ì›ìŒ ë³¼ë¥¨)</label><input id="thruVol" type="range" min="0" max="100" value="80" disabled /></div>
      <div><label>FX Max (ëˆ„ë¥¼ ë•Œ FX ìµœëŒ€)</label><input id="fxMax" type="range" min="0" max="100" value="85" disabled /></div>
      <div><label>Distance (ë©€ì–´ì§/ìœ ë ¹í™”)</label><input id="distance" type="range" min="0" max="100" value="70" disabled /></div>
      <div><label>Crush (ë­‰ê°œì§)</label><input id="crush" type="range" min="0" max="100" value="40" disabled /></div>
    </div>

    <div class="row">
      <div><label>Grain ms</label><input id="grainMs" type="range" min="20" max="220" value="130" disabled /></div>
      <div><label>Shatter (íŒŒí¸/ì í”„)</label><input id="shatter" type="range" min="0" max="100" value="55" disabled /></div>
      <div><label>Voices</label><input id="voices" type="range" min="1" max="6" value="4" disabled /></div>
      <div><label>Output (ë§ˆìŠ¤í„°)</label><input id="outVol" type="range" min="0" max="100" value="85" disabled /></div>
    </div>

    <div class="grid">
      <div class="viz">
        <label>RAW MIC â€“ Wave</label>
        <canvas id="waveIn"></canvas>
      </div>
      <div class="viz">
        <label>OUTPUT (THRU+FX) â€“ Wave</label>
        <canvas id="waveOut"></canvas>
      </div>
    </div>

    <div id="log" class="mono">ëŒ€ê¸° ì¤‘â€¦</div>
  </div>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const logEl = $("log");
  const log = (m)=>{ logEl.textContent = m + "\n" + logEl.textContent; };

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const norm=(x)=>clamp(x/100,0,1);

  // --- audio state
  let ctx=null;

  // mic
  let micStream=null, micSrc=null;

  // nodes
  let thruGain=null, fxGain=null, master=null;
  let lp=null, delay=null, fb=null;
  let fxProc=null;

  // output: route WebAudio -> MediaStreamDestination -> <audio> (for setSinkId)
  let mediaDest=null;
  const monitor = $("monitor");

  // analysers
  let anIn=null, anOut=null;

  // ring buffer for FX
  let ring=null, ringLen=0, ringWrite=0;

  // MIDI
  let midiAccess=null, currentInput=null;
  let midiVel=0;   // 0..1
  let active=0;    // pressed count
  let fxGate=0;    // smoothed gate

  // voices
  let voices=[];
  let crushHold=0, crushCounter=0;

  function enableUI(on){
    ["beepBtn","micBtn","micOffBtn","inSel","outSel","midiIn",
     "thruVol","fxMax","distance","crush","grainMs","shatter","voices","outVol"
    ].forEach(id => $(id).disabled = !on);
  }

  // --- device enumeration
  async function refreshDevices(){
    if(!navigator.mediaDevices?.enumerateDevices){
      log("enumerateDevices ë¯¸ì§€ì›");
      return;
    }
    const devices = await navigator.mediaDevices.enumerateDevices();

    const ins = devices.filter(d=>d.kind==="audioinput");
    const outs= devices.filter(d=>d.kind==="audiooutput");

    const inSel = $("inSel");
    const outSel= $("outSel");

    inSel.innerHTML = `<option value="">(ê¸°ë³¸ ì…ë ¥)</option>`;
    ins.forEach((d,i)=>{
      const opt=document.createElement("option");
      opt.value=d.deviceId;
      opt.textContent=d.label || `Input ${i+1}`;
      inSel.appendChild(opt);
    });

    outSel.innerHTML = `<option value="">(ê¸°ë³¸ ì¶œë ¥)</option>`;
    outs.forEach((d,i)=>{
      const opt=document.createElement("option");
      opt.value=d.deviceId;
      opt.textContent=d.label || `Output ${i+1}`;
      outSel.appendChild(opt);
    });

    log(`Devices: in=${ins.length}, out=${outs.length} (ë¼ë²¨ì€ ê¶Œí•œ í›„ ë” ì˜ ëœ¸)`);
  }

  async function setOutputDevice(deviceId){
    if(typeof monitor.setSinkId !== "function"){
      log("setSinkId ë¯¸ì§€ì› ë˜ëŠ” ë¹„ë³´ì•ˆ(HTTPS ì•„ë‹˜)ì¼ ìˆ˜ ìˆìŒ");
      return;
    }
    try{
      await monitor.setSinkId(deviceId || "");
      log(deviceId ? "Output set âœ…" : "Output default âœ…");
    }catch(e){
      log("setSinkId error: " + e.message);
    }
  }

  // --- FX helpers
  function windowHann(t){ return 0.5 - 0.5*Math.cos(2*Math.PI*t); }

  function resetVoices(n){
    voices=[];
    for(let i=0;i<n;i++){
      voices.push({readPos:0, remain:0, grainLen:0, inc:1.0});
    }
  }

  function readRing(pos){
    let p=pos;
    while(p<0)p+=ringLen;
    while(p>=ringLen)p-=ringLen;
    const i0=p|0, i1=(i0+1)%ringLen;
    const f=p-i0;
    return ring[i0]*(1-f) + ring[i1]*f;
  }

  function scheduleGrain(v, grainSamples, intensity, dist, shat){
    const backMs   = lerp(50, 900, clamp(0.35*intensity + 0.65*shat,0,1));
    const jitterMs = lerp(6,  340, clamp(0.25*intensity + 0.75*shat,0,1));
    const backS = backMs * ctx.sampleRate / 1000;
    const jitS  = (Math.random()*2-1) * (jitterMs * ctx.sampleRate / 1000);

    const slow   = lerp(1.0, 0.40, dist);
    const wobble = lerp(0.00, 0.08, intensity);
    v.inc = slow + (Math.random()*2-1)*wobble;

    v.grainLen = grainSamples;
    v.remain   = grainSamples;
    v.readPos  = ringWrite - backS + jitS + (Math.random()*2-1)*(ctx.sampleRate*0.02);
  }

  function buildGraph(){
    // gains
    thruGain = ctx.createGain();
    fxGain   = ctx.createGain();
    master   = ctx.createGain();

    // FX space
    lp = ctx.createBiquadFilter();
    lp.type="lowpass"; lp.frequency.value=9000; lp.Q.value=0.7;

    delay = ctx.createDelay(1.0);
    delay.delayTime.value=0.18;

    fb = ctx.createGain();
    fb.gain.value=0.35;

    lp.connect(delay);
    delay.connect(fb);
    fb.connect(delay);

    // analysers
    anIn  = ctx.createAnalyser(); anIn.fftSize=2048;  anIn.smoothingTimeConstant=0.85;
    anOut = ctx.createAnalyser(); anOut.fftSize=2048; anOut.smoothingTimeConstant=0.85;

    // mix
    const sum = ctx.createGain();
    thruGain.connect(sum);
    fxGain.connect(sum);

    sum.connect(anOut);
    sum.connect(master);

    // route to audio element (and allow output select)
    mediaDest = ctx.createMediaStreamDestination();
    master.connect(mediaDest);
    monitor.srcObject = mediaDest.stream;

    // init gains
    thruGain.gain.value = norm($("thruVol").value);
    fxGain.gain.value   = 0.0;
    master.gain.value   = norm($("outVol").value);
  }

  function buildFXProcessor(){
    const bufSize=1024;
    fxProc = ctx.createScriptProcessor(bufSize, 1, 1);

    fxProc.onaudioprocess = (e)=>{
      const input = e.inputBuffer.getChannelData(0);
      const out   = e.outputBuffer.getChannelData(0);

      // write mic into ring
      for(let i=0;i<input.length;i++){
        ring[ringWrite]=input[i];
        ringWrite=(ringWrite+1)%ringLen;
      }

      const uiDist  = norm($("distance").value);
      const uiCrush = norm($("crush").value);
      const uiShat  = norm($("shatter").value);
      const gMs     = Number($("grainMs").value);

      const dist = clamp(uiDist*0.70 + midiVel*0.60, 0, 1);
      const shat = clamp(uiShat*0.75 + midiVel*0.65, 0, 1);
      const crush= clamp(uiCrush*0.85 + midiVel*0.40, 0, 1);

      // intensity mostly from touch + gate
      const intensity = clamp(0.25 + 0.90*midiVel, 0, 1);

      const grainSamples = Math.max(16, (gMs * ctx.sampleRate / 1000)|0);

      for(let i=0;i<out.length;i++){
        let s=0;

        for(const v of voices){
          if(v.remain<=0){
            const density = lerp(0.10, 0.96, intensity);
            if(Math.random() < density) scheduleGrain(v, grainSamples, intensity, dist, shat);
          }
          if(v.remain>0){
            const t = 1 - (v.remain / v.grainLen);
            s += readRing(v.readPos) * windowHann(t);
            v.readPos += v.inc;
            v.remain--;
          }
        }

        s *= voices.length ? 1.0/Math.sqrt(voices.length) : 0;

        // crush (sample/hold)
        const holdN = Math.max(1, (1 + crush*30)|0);
        if(crushCounter<=0){ crushHold=s; crushCounter=holdN; }
        else crushCounter--;
        s = lerp(s, crushHold, clamp(crush*0.9,0,1));

        out[i]=s;
      }
    };

    // FX routing: proc -> lp -> delay -> fxGain
    fxProc.connect(lp);
    delay.connect(fxGain);
  }

  function updateParams(){
    if(!ctx) return;
    thruGain.gain.value = norm($("thruVol").value);
    master.gain.value   = norm($("outVol").value);

    const dist = clamp(norm($("distance").value)*0.70 + midiVel*0.60, 0, 1);
    lp.frequency.value = lerp(15000, 1400, dist);
    delay.delayTime.value = lerp(0.06, 0.30, dist);
    fb.gain.value = clamp(lerp(0.10, 0.88, dist), 0, 0.92);
  }

  function updateFxGate(){
    const fxMax = norm($("fxMax").value);
    const pressed = active>0 ? 1 : 0;

    const target = pressed ? clamp(fxMax*(0.20 + 0.95*midiVel), 0, 1) : 0;
    fxGate = lerp(fxGate, target, pressed ? 0.18 : 0.08);
    fxGain.gain.value = fxGate;

    if(active===0) midiVel *= 0.985;
    $("midiBar").style.width = `${Math.round(midiVel*100)}%`;
  }

  // --- mic
  async function micOn(){
    const deviceId = $("inSel").value;
    const constraints = {
      audio: {
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false,
        ...(deviceId ? { deviceId: { exact: deviceId } } : {})
      }
    };

    micStream = await navigator.mediaDevices.getUserMedia(constraints);
    micSrc = ctx.createMediaStreamSource(micStream);

    // tap for analyser
    micSrc.connect(anIn);

    // THRU
    micSrc.connect(thruGain);

    // FX input
    micSrc.connect(fxProc);

    log("Mic ON âœ… (ì›ìŒ THRU + FX ì…ë ¥ ì—°ê²°ë¨)");
  }

  function micOff(){
    if(micSrc){ try{ micSrc.disconnect(); }catch(e){} micSrc=null; }
    if(micStream){ try{ micStream.getTracks().forEach(t=>t.stop()); }catch(e){} micStream=null; }
    log("Mic OFF");
  }

  // --- beep test (output check)
  function testBeep(){
    const osc = ctx.createOscillator();
    const g   = ctx.createGain();
    osc.type="sine";
    osc.frequency.value=880;
    g.gain.value=0.0;

    // go into master chain so it follows output element
    g.connect(master);

    const t = ctx.currentTime;
    g.gain.setValueAtTime(0.0, t);
    g.gain.linearRampToValueAtTime(0.18, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.25);

    osc.connect(g);
    osc.start(t);
    osc.stop(t+0.26);

    log("Beep ğŸ”ˆ (ì´ê²Œ ë“¤ë¦¬ë©´ ì¶œë ¥ì€ ì •ìƒ)");
  }

  // --- MIDI
  async function initMIDI(){
    const sel = $("midiIn");
    sel.innerHTML = "";
    if(!navigator.requestMIDIAccess){
      sel.innerHTML = `<option>WebMIDI ë¯¸ì§€ì›</option>`;
      log("WebMIDI ë¯¸ì§€ì›(Chrome ê¶Œì¥)");
      return;
    }
    midiAccess = await navigator.requestMIDIAccess({sysex:false});
    midiAccess.onstatechange = refreshMIDIInputs;
    refreshMIDIInputs();
    log("MIDI ready âœ…");
  }

  function refreshMIDIInputs(){
    const sel = $("midiIn");
    sel.innerHTML = "";
    const inputs = midiAccess ? Array.from(midiAccess.inputs.values()) : [];
    if(inputs.length===0){
      sel.innerHTML = `<option>ì—°ê²°ëœ MIDI ì—†ìŒ</option>`;
      return;
    }
    inputs.forEach(inp=>{
      const opt=document.createElement("option");
      opt.value=inp.id;
      opt.textContent = `${inp.name || "MIDI Input"}${inp.manufacturer ? " â€“ "+inp.manufacturer : ""}`;
      sel.appendChild(opt);
    });
    if(!currentInput){
      connectMIDI(inputs[0].id);
      sel.value = inputs[0].id;
    }
  }

  function connectMIDI(id){
    if(currentInput) currentInput.onmidimessage = null;
    currentInput = midiAccess.inputs.get(id);
    if(!currentInput) return;

    currentInput.onmidimessage = (msg)=>{
      const [status, , d2] = msg.data;
      const cmd = status & 0xF0;

      if(cmd===0x90){
        const vel=d2;
        if(vel===0){
          active=Math.max(0,active-1);
        }else{
          active++;
          midiVel = clamp(vel/127,0,1);
        }
      } else if(cmd===0x80){
        active=Math.max(0,active-1);
      }
      updateParams();
    };

    log("MIDI connected: " + (currentInput.name || id));
  }

  // --- viz
  const waveIn = $("waveIn");
  const waveOut= $("waveOut");
  const gIn = waveIn.getContext("2d");
  const gOut= waveOut.getContext("2d");

  function resizeCanvas(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    [waveIn,waveOut].forEach(cv=>{
      const r=cv.getBoundingClientRect();
      cv.width=Math.floor(r.width*dpr);
      cv.height=Math.floor(r.height*dpr);
    });
  }

  function drawWave(ctx2d, analyser){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const W=ctx2d.canvas.width, H=ctx2d.canvas.height;
    ctx2d.clearRect(0,0,W,H);
    if(!analyser) return 0;

    const data=new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(data);

    ctx2d.lineWidth=2*dpr;
    ctx2d.strokeStyle="#eaeaea";
    ctx2d.beginPath();
    const mid=H/2;
    for(let i=0;i<data.length;i++){
      const x=(i/(data.length-1))*W;
      const v=(data[i]-128)/128;
      const y=mid+v*(H*0.42);
      if(i===0) ctx2d.moveTo(x,y); else ctx2d.lineTo(x,y);
    }
    ctx2d.stroke();

    let rms=0;
    for(let i=0;i<data.length;i++){
      const v=(data[i]-128)/128;
      rms += v*v;
    }
    return Math.sqrt(rms/data.length);
  }

  let raf=null;
  function loop(){
    const rmsIn = drawWave(gIn, anIn) || 0;
    drawWave(gOut, anOut);

    $("micBar").style.width = `${Math.round(clamp(rmsIn*3.0,0,1)*100)}%`;

    updateFxGate();
    raf = requestAnimationFrame(loop);
  }

  // --- Start (robust)
  async function onStart(ev){
    ev.preventDefault();
    ev.stopPropagation();

    if(ctx) return;

    ctx = new (window.AudioContext||window.webkitAudioContext)();
    await ctx.resume();

    // autoplay unlock for monitor element
    try{ await monitor.play(); }catch(e){ /* user can press play */ }

    // ring
    ringLen = Math.floor(ctx.sampleRate * 4.0);
    ring = new Float32Array(ringLen);
    ringWrite = 0;

    buildGraph();
    resetVoices(Number($("voices").value));
    buildFXProcessor();

    enableUI(true);
    $("startBtn").disabled = true;
    $("micBtn").disabled = false;
    $("micOffBtn").disabled = true;

    // sliders
    ["thruVol","fxMax","distance","crush","grainMs","shatter","outVol"].forEach(id=>{
      $(id).addEventListener("input", updateParams);
    });
    $("voices").addEventListener("input", ()=>{
      resetVoices(Number($("voices").value));
      log("voices: " + $("voices").value);
    });

    // device lists (labels improve after mic permission too)
    await refreshDevices();

    // MIDI
    await initMIDI();

    // output selection
    $("outSel").addEventListener("change", async (e)=> setOutputDevice(e.target.value));
    $("midiIn").addEventListener("change", (e)=> connectMIDI(e.target.value));

    // start viz loop
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    raf = requestAnimationFrame(loop);

    updateParams();

    log("Start âœ…  ë‹¤ìŒ: Test Beep â†’ Mic On");
  }

  ["click","pointerdown","touchstart"].forEach(type=>{
    $("startBtn").addEventListener(type, onStart, {passive:false});
  });

  $("beepBtn").addEventListener("click", ()=>{
    if(!ctx) return;
    testBeep();
  });

  $("micBtn").addEventListener("click", async ()=>{
    try{
      await micOn();
      $("micBtn").disabled = true;
      $("micOffBtn").disabled = false;

      // labels update after permission
      await refreshDevices();
    }catch(e){
      log("Mic error: " + e.message);
    }
  });

  $("micOffBtn").addEventListener("click", ()=>{
    micOff();
    $("micBtn").disabled = false;
    $("micOffBtn").disabled = true;
  });

  // initial
  enableUI(false);
})();
</script>
</body>
</html>
