<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TouchMe – Mic Thru + TouchMe FX (RAW vs FX Viz)</title>
  <style>
    :root{color-scheme:dark}
    body{margin:0;padding:18px;background:#0b0b0b;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1200px;margin:0 auto}
    .card{background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px}
    h1{font-size:18px;margin:0 0 10px}
    p{opacity:.9;line-height:1.55;margin:8px 0}
    label{display:block;margin-top:10px;font-size:13px;opacity:.92}
    input,select,button{width:100%;margin-top:6px;padding:12px;border-radius:12px;border:1px solid #333;background:#0f0f0f;color:#eee}
    button{cursor:pointer}
    button:disabled{opacity:.55;cursor:not-allowed}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > *{flex:1;min-width:220px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:12px}
    @media(min-width:980px){ .grid{grid-template-columns:1fr 1fr} }
    .viz{background:#0f0f0f;border:1px solid #2a2a2a;border-radius:14px;padding:10px}
    canvas{width:100%;height:240px;display:block;border-radius:10px;background:#0a0a0a}
    .hint{font-size:12px;opacity:.78;margin-top:8px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:#0f0f0f;border:1px solid #2a2a2a;border-radius:12px;padding:12px;white-space:pre-wrap}
    .small{font-size:12px;opacity:.82}
    .meter{height:10px;border-radius:999px;background:#1a1a1a;border:1px solid #2a2a2a;overflow:hidden}
    .meter > div{height:100%;width:0%;background:#eaeaea;opacity:.9}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>마이크 ON = 원음 모니터링 / TouchMe 누르면 = 그 소리가 변형 (RAW vs FX 시각화)</h1>
    <p>
      ✅ <b>Mic On</b> 하면 기본 마이크 소리가 그대로 들려오고(원음 THRU),<br/>
      ✅ TouchMe를 <b>누르고 있는 동안만</b> 변형된 소리가 섞여서 나오도록 만들었어(떼면 원음으로 복귀).<br/>
      ※ 스피커로 하면 하울링 날 수 있으니 <b>이어폰/헤드폰</b> 추천.
    </p>

    <div class="row">
      <button id="startBtn">Start (AudioContext)</button>
      <button id="micBtn" disabled>Mic On</button>
      <button id="micOffBtn" disabled>Mic Off</button>
      <button id="panicBtn" disabled>Panic (Mute)</button>
    </div>

    <div class="row">
      <div>
        <label>MIDI Input (TouchMe)</label>
        <select id="midiIn" disabled><option>Start 후 활성화</option></select>
        <div class="hint">TouchMe 누르면(노트온) FX가 켜지고, 떼면(노트오프) FX가 꺼짐.</div>
      </div>
      <div>
        <label>Preset</label>
        <select id="preset" disabled>
          <option value="ghost" selected>Ghost (늘어짐+멀어짐)</option>
          <option value="shatter">Shatter (파편+깨짐)</option>
          <option value="cute">Cute (짧은 그레인)</option>
        </select>
        <div class="hint">Preset은 슬라이더 기본값을 같이 세팅</div>
      </div>
    </div>

    <div class="row">
      <div>
        <label class="small">TouchMe Pressure (velocity)</label>
        <div class="meter"><div id="midiBar"></div></div>
      </div>
      <div>
        <label class="small">Mic Level</label>
        <div class="meter"><div id="micBar"></div></div>
      </div>
    </div>

    <div class="grid">
      <div class="viz">
        <label>RAW MIC – Waveform</label>
        <canvas id="waveIn"></canvas>
        <div class="hint">원본 마이크 파형</div>
      </div>
      <div class="viz">
        <label>TRANSFORMED – Waveform</label>
        <canvas id="waveOut"></canvas>
        <div class="hint">TouchMe 눌렀을 때 변형된 출력 파형</div>
      </div>
      <div class="viz">
        <label>RAW MIC – Spectrum</label>
        <canvas id="specIn"></canvas>
      </div>
      <div class="viz">
        <label>TRANSFORMED – Spectrum</label>
        <canvas id="specOut"></canvas>
      </div>
    </div>

    <div class="row" style="margin-top:12px">
      <div>
        <label class="small">Intensity (변형 강도)</label>
        <input id="intensity" type="range" min="0" max="100" value="55" disabled />
      </div>
      <div>
        <label class="small">Distance (멀어짐/유령화)</label>
        <input id="distance" type="range" min="0" max="100" value="60" disabled />
      </div>
      <div>
        <label class="small">Shatter (파편/점프)</label>
        <input id="shatter" type="range" min="0" max="100" value="55" disabled />
      </div>
      <div>
        <label class="small">Crush (뭉개짐/깨짐)</label>
        <input id="crush" type="range" min="0" max="100" value="45" disabled />
      </div>
    </div>

    <div class="row">
      <div>
        <label class="small">Grain ms (그레인 길이)</label>
        <input id="grainMs" type="range" min="15" max="240" value="120" disabled />
      </div>
      <div>
        <label class="small">Voices (겹침 개수)</label>
        <input id="voices" type="range" min="1" max="6" value="4" disabled />
      </div>
      <div>
        <label class="small">THRU Volume (원음 볼륨)</label>
        <input id="thruVol" type="range" min="0" max="100" value="75" disabled />
      </div>
      <div>
        <label class="small">FX Max Mix (TouchMe 눌렀을 때 FX 최대치)</label>
        <input id="fxMax" type="range" min="0" max="100" value="85" disabled />
      </div>
    </div>

    <label>Log</label>
    <div id="log" class="mono">대기 중…</div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const log = (m) => { logEl.textContent = m + "\n" + logEl.textContent; };

  // ---------- helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const norm = (x)=>clamp(x/100,0,1);

  // ---------- audio state ----------
  let ctx = null;

  // mic
  let micStream = null;
  let micSrc = null;

  // analysers
  let anInTime=null, anInFreq=null, anOutTime=null, anOutFreq=null;

  // ring buffer
  let ring=null, ringLen=0, ringWrite=0;

  // nodes
  let proc=null;                 // FX generator (uses mic ring)
  let thruGain=null;             // raw mic monitoring
  let fxGain=null;               // fx output gain (auto by TouchMe)
  let sum=null;                  // sum -> analysers -> out
  let delay=null, fb=null, lp=null, outGain=null;

  // MIDI (TouchMe)
  let midiAccess=null, currentInput=null;
  let midiIntensity = 0;         // 0..1 (velocity)
  let activeNotes = 0;
  let fxGate = 0;                // 0..1 (smoothed on/off)

  // granular voices
  let voices = [];
  let crushHold=0, crushCounter=0;

  function enableUI(on){
    ["micBtn","micOffBtn","panicBtn","midiIn","preset",
     "intensity","distance","shatter","crush","grainMs","voices","thruVol","fxMax"
    ].forEach(id=> $(id).disabled = !on);
  }

  function resetVoices(n){
    voices = [];
    for(let i=0;i<n;i++){
      voices.push({ readPos:0, remain:0, grainLen:0, inc:1.0 });
    }
  }

  function windowHann(t){ return 0.5 - 0.5*Math.cos(2*Math.PI*t); }

  function readRing(pos){
    let p = pos;
    while(p < 0) p += ringLen;
    while(p >= ringLen) p -= ringLen;
    const i0 = p|0;
    const i1 = (i0+1)%ringLen;
    const f = p - i0;
    return ring[i0]*(1-f) + ring[i1]*f;
  }

  function scheduleGrain(v, grainSamples, intensity, dist, shat){
    const backMs   = lerp(60, 900, clamp(0.35*intensity + 0.65*shat,0,1));
    const jitterMs = lerp(6,  320, clamp(0.25*intensity + 0.75*shat,0,1));
    const backS = backMs * ctx.sampleRate / 1000;
    const jitS  = (Math.random()*2-1) * (jitterMs * ctx.sampleRate / 1000);

    const slow   = lerp(1.0, 0.40, dist);          // distance↑ => 늘어짐
    const wobble = lerp(0.00, 0.08, intensity);    // intensity↑ => 불안정
    v.inc = slow + (Math.random()*2-1)*wobble;

    v.grainLen = grainSamples;
    v.remain = grainSamples;

    v.readPos = ringWrite - backS + jitS + (Math.random()*2-1)*(ctx.sampleRate*0.02);
  }

  function applyPreset(name){
    if(name==="ghost"){
      $("intensity").value=55; $("distance").value=75; $("shatter").value=40; $("crush").value=28;
      $("grainMs").value=140; $("voices").value=4;
    } else if(name==="shatter"){
      $("intensity").value=70; $("distance").value=45; $("shatter").value=85; $("crush").value=72;
      $("grainMs").value=65; $("voices").value=3;
    } else { // cute
      $("intensity").value=45; $("distance").value=30; $("shatter").value=45; $("crush").value=22;
      $("grainMs").value=55; $("voices").value=2;
    }
    resetVoices(Number($("voices").value));
    updateParams();
    log("preset: " + name);
  }

  function buildGraph(){
    // mixers
    thruGain = ctx.createGain(); // raw mic -> thruGain -> sum
    fxGain   = ctx.createGain(); // fx proc -> fxGain -> sum (TouchMe gate)
    sum      = ctx.createGain();

    // space + distance (FX path only)
    delay = ctx.createDelay(1.0);
    delay.delayTime.value = 0.18;

    fb = ctx.createGain();
    fb.gain.value = 0.35;

    lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 9000;
    lp.Q.value = 0.7;

    outGain = ctx.createGain();
    outGain.gain.value = 0.92;

    // analysers
    anInTime = ctx.createAnalyser(); anInTime.fftSize = 2048; anInTime.smoothingTimeConstant = 0.85;
    anInFreq = ctx.createAnalyser(); anInFreq.fftSize = 2048; anInFreq.smoothingTimeConstant = 0.85;

    anOutTime = ctx.createAnalyser(); anOutTime.fftSize = 2048; anOutTime.smoothingTimeConstant = 0.85;
    anOutFreq = ctx.createAnalyser(); anOutFreq.fftSize = 2048; anOutFreq.smoothingTimeConstant = 0.85;

    // FX chain: (proc) -> lp -> delay -> fb -> delay ... then to fxGain -> sum
    // We'll build: proc -> lp -> delay ; delay -> fb -> delay (feedback) ; delay -> fxGain -> sum
    // (lp sits before delay so "distance" cuts high freq)
    lp.connect(delay);
    delay.connect(fb);
    fb.connect(delay);

    // sum: raw thru + fx
    thruGain.connect(sum);
    fxGain.connect(sum);

    // tap output for viz
    sum.connect(anOutTime);
    sum.connect(anOutFreq);

    // to speakers
    anOutFreq.connect(outGain);
    outGain.connect(ctx.destination);

    // init gains
    thruGain.gain.value = 0.75;
    fxGain.gain.value = 0.0; // TouchMe 없으면 FX 0
  }

  function buildProcessor(){
    const bufSize = 1024;
    proc = ctx.createScriptProcessor(bufSize, 1, 1);

    proc.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);

      // write mic into ring (for FX only)
      for(let i=0;i<input.length;i++){
        ring[ringWrite] = input[i];
        ringWrite = (ringWrite + 1) % ringLen;
      }

      // params
      const uiInt = norm($("intensity").value);
      const uiDist = norm($("distance").value);
      const uiShat = norm($("shatter").value);
      const uiCrush = norm($("crush").value);
      const gMs = Number($("grainMs").value);

      // TouchMe velocity boosts
      const intensity = clamp(uiInt*0.65 + midiIntensity*0.95, 0, 1);
      const dist      = clamp(uiDist*0.70 + midiIntensity*0.60, 0, 1);
      const shat      = clamp(uiShat*0.75 + midiIntensity*0.65, 0, 1);
      const crush     = clamp(uiCrush*0.85 + midiIntensity*0.40, 0, 1);

      const grainSamples = Math.max(16, (gMs * ctx.sampleRate / 1000) | 0);

      // generate FX signal
      for(let i=0;i<output.length;i++){
        let s = 0;

        for(const v of voices){
          if(v.remain <= 0){
            // density: intensity↑ => 더 자주 생성
            const density = lerp(0.10, 0.96, intensity);
            if(Math.random() < density) scheduleGrain(v, grainSamples, intensity, dist, shat);
          }

          if(v.remain > 0){
            const t = 1 - (v.remain / v.grainLen);
            const w = windowHann(t);
            s += readRing(v.readPos) * w;
            v.readPos += v.inc;
            v.remain--;
          }
        }

        s *= (voices.length ? 1.0 / Math.sqrt(voices.length) : 0);

        // crush (sample&hold)
        const holdN = Math.max(1, (1 + (crush * 30))|0);
        if(crushCounter <= 0){
          crushHold = s;
          crushCounter = holdN;
        } else {
          crushCounter--;
        }
        s = lerp(s, crushHold, clamp(crush*0.9,0,1));

        output[i] = s;
      }
    };

    // FX path wiring: proc -> lp -> delay -> fxGain -> sum
    proc.connect(lp);
    delay.connect(fxGain);

    // IMPORTANT: proc input comes from micSrc (set in micOn)

    // UI change hooks
    ["intensity","distance","shatter","crush","grainMs","thruVol","fxMax"].forEach(id=>{
      $(id).addEventListener("input", updateParams);
    });
    $("voices").addEventListener("input", ()=>{
      resetVoices(Number($("voices").value));
      log("voices: " + $("voices").value);
    });
  }

  function updateParams(){
    if(!ctx) return;

    // raw thru volume
    thruGain.gain.value = norm($("thruVol").value);

    // distance affects filter + delay feedback
    const dist = clamp(norm($("distance").value)*0.70 + midiIntensity*0.60, 0, 1);
    lp.frequency.value = lerp(15000, 1400, dist);
    delay.delayTime.value = lerp(0.06, 0.30, dist);
    fb.gain.value = clamp(lerp(0.10, 0.88, dist), 0, 0.92);

    // output overall (optional)
    outGain.gain.value = lerp(0.95, 0.78, dist);
  }

  // ---------- mic ----------
  async function micOn(){
    if(micStream) return;

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    micSrc = ctx.createMediaStreamSource(micStream);

    // RAW analyzers + THRU monitoring
    micSrc.connect(anInTime);
    micSrc.connect(anInFreq);

    // THRU path (원음이 바로 들리게)
    micSrc.connect(thruGain);

    // FX processor input
    micSrc.connect(proc);

    log("Mic ON ✅ (원음 들림 / TouchMe 누르면 FX 섞임)");
  }

  function micOff(){
    if(micSrc){
      try{ micSrc.disconnect(); }catch(e){}
      micSrc = null;
    }
    if(micStream){
      try{ micStream.getTracks().forEach(t=>t.stop()); }catch(e){}
      micStream = null;
    }
    log("Mic OFF");
  }

  function panic(){
    if(outGain){
      const prev = outGain.gain.value;
      outGain.gain.value = 0.0;
      setTimeout(()=>{ outGain.gain.value = prev; }, 220);
    }
    log("PANIC");
  }

  // ---------- MIDI (TouchMe gate: 누르면 FX 올라가고 떼면 내려감) ----------
  async function initMIDI(){
    const sel = $("midiIn");
    sel.innerHTML = "";
    if(!navigator.requestMIDIAccess){
      sel.innerHTML = `<option>WebMIDI 미지원</option>`;
      log("WebMIDI 미지원(Chrome 권장)");
      return;
    }
    midiAccess = await navigator.requestMIDIAccess({ sysex:false });
    midiAccess.onstatechange = refreshInputs;
    refreshInputs();
    log("MIDI ready ✅");
  }

  function refreshInputs(){
    const sel = $("midiIn");
    sel.innerHTML = "";
    const inputs = midiAccess ? Array.from(midiAccess.inputs.values()) : [];
    if(inputs.length === 0){
      sel.innerHTML = `<option>연결된 MIDI 없음</option>`;
      return;
    }
    inputs.forEach(inp=>{
      const opt = document.createElement("option");
      opt.value = inp.id;
      opt.textContent = `${inp.name || "MIDI Input"}${inp.manufacturer ? " – " + inp.manufacturer : ""}`;
      sel.appendChild(opt);
    });
    if(!currentInput){
      connectInput(inputs[0].id);
      sel.value = inputs[0].id;
    }
  }

  function connectInput(id){
    if(currentInput) currentInput.onmidimessage = null;
    currentInput = midiAccess.inputs.get(id);
    if(!currentInput) return;

    currentInput.onmidimessage = (msg)=>{
      const [status, d1, d2] = msg.data;
      const cmd = status & 0xF0;

      if(cmd === 0x90){
        const vel = d2;
        if(vel === 0){
          activeNotes = Math.max(0, activeNotes-1);
        } else {
          activeNotes++;
          midiIntensity = clamp(vel/127, 0, 1);
        }
      } else if(cmd === 0x80){
        activeNotes = Math.max(0, activeNotes-1);
      }

      // if holding at least 1 note, keep intensity; else it will decay in loop()
      updateParams();
    };

    log("MIDI input connected: " + (currentInput.name || id));
  }

  // ---------- Visualization ----------
  const cvs = {
    waveIn: $("waveIn"), waveOut: $("waveOut"),
    specIn: $("specIn"), specOut: $("specOut")
  };
  const g = {
    waveIn: cvs.waveIn.getContext("2d"),
    waveOut: cvs.waveOut.getContext("2d"),
    specIn: cvs.specIn.getContext("2d"),
    specOut: cvs.specOut.getContext("2d")
  };

  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    Object.values(cvs).forEach(cv=>{
      const r = cv.getBoundingClientRect();
      cv.width = Math.floor(r.width * dpr);
      cv.height = Math.floor(r.height * dpr);
    });
  }

  function drawWave(ctx2d, analyser){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const W = ctx2d.canvas.width, H = ctx2d.canvas.height;
    ctx2d.clearRect(0,0,W,H);

    if(!analyser){
      ctx2d.globalAlpha = 0.6;
      ctx2d.fillStyle = "#eaeaea";
      ctx2d.fillText("no signal", 12*dpr, 22*dpr);
      ctx2d.globalAlpha = 1;
      return 0;
    }

    const data = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(data);

    ctx2d.lineWidth = 2*dpr;
    ctx2d.strokeStyle = "#eaeaea";
    ctx2d.beginPath();
    const mid = H/2;
    for(let i=0;i<data.length;i++){
      const x = (i/(data.length-1))*W;
      const v = (data[i]-128)/128;
      const y = mid + v*(H*0.42);
      if(i===0) ctx2d.moveTo(x,y);
      else ctx2d.lineTo(x,y);
    }
    ctx2d.stroke();

    // RMS for mic meter
    let rms = 0;
    for(let i=0;i<data.length;i++){
      const v = (data[i]-128)/128;
      rms += v*v;
    }
    return Math.sqrt(rms / data.length);
  }

  function drawSpec(ctx2d, analyser){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const W = ctx2d.canvas.width, H = ctx2d.canvas.height;
    ctx2d.clearRect(0,0,W,H);

    if(!analyser){
      ctx2d.globalAlpha = 0.6;
      ctx2d.fillStyle = "#eaeaea";
      ctx2d.fillText("no signal", 12*dpr, 22*dpr);
      ctx2d.globalAlpha = 1;
      return;
    }

    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);

    const bars = 96;
    const step = Math.max(1, Math.floor(data.length / bars));
    const bw = W / bars;

    for(let i=0;i<bars;i++){
      let sum = 0;
      for(let k=0;k<step;k++) sum += data[i*step+k];
      const v = sum/(step*255);
      const h = v * H * 0.95;
      const x = i*bw;
      const y = H - h;

      ctx2d.fillStyle = "#eaeaea";
      ctx2d.globalAlpha = 0.16 + 0.78*v;
      ctx2d.fillRect(x+1*dpr, y, Math.max(1, bw-2*dpr), h);
    }
    ctx2d.globalAlpha = 1;
  }

  function updateFxGain(){
    // TouchMe 누르고 있을 때만 FX가 올라가게(게이트)
    const fxMax = norm($("fxMax").value); // 0..1
    const uiInt = norm($("intensity").value);

    // target: activeNotes>0 이면 올라감, 아니면 내려감
    const pressed = activeNotes > 0 ? 1 : 0;

    // pressed일 때도 velocity로 강도 가중
    const target = pressed
      ? clamp(fxMax * (0.35 + 0.85*(uiInt*0.55 + midiIntensity*0.85)), 0, 1)
      : 0;

    // smooth
    fxGate = lerp(fxGate, target, pressed ? 0.12 : 0.06);

    // set
    if(fxGain) fxGain.gain.value = fxGate;
  }

  let raf = null;
  function loop(){
    // meters and viz
    const rmsIn = drawWave(g.waveIn, anInTime) || 0;
    drawSpec(g.specIn, anInFreq);

    drawWave(g.waveOut, anOutTime);
    drawSpec(g.specOut, anOutFreq);

    // decay midiIntensity when not pressed
    if(activeNotes === 0) midiIntensity *= 0.985;

    // update FX gate
    updateFxGain();

    // meters
    $("midiBar").style.width = `${Math.round(midiIntensity*100)}%`;
    $("micBar").style.width = `${Math.round(clamp(rmsIn*3.0,0,1)*100)}%`;

    raf = requestAnimationFrame(loop);
  }

  // ---------- UI wiring ----------
  $("startBtn").addEventListener("click", async ()=>{
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // ring buffer 4s
    ringLen = Math.floor(ctx.sampleRate * 4.0);
    ring = new Float32Array(ringLen);
    ringWrite = 0;

    buildGraph();
    resetVoices(Number($("voices").value));
    buildProcessor();

    enableUI(true);
    $("micBtn").disabled = false;
    $("micOffBtn").disabled = true;
    $("panicBtn").disabled = false;

    await initMIDI();

    resizeCanvas();
    if(raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(loop);

    applyPreset($("preset").value);
    updateParams();

    log("Start ✅");
    $("startBtn").disabled = true;
  });

  $("micBtn").addEventListener("click", async ()=>{
    try{
      await micOn();
      $("micBtn").disabled = true;
      $("micOffBtn").disabled = false;
    }catch(e){
      log("Mic error: " + e.message);
    }
  });

  $("micOffBtn").addEventListener("click", ()=>{
    micOff();
    $("micBtn").disabled = false;
    $("micOffBtn").disabled = true;
  });

  $("panicBtn").addEventListener("click", panic);

  $("midiIn").addEventListener("change", (e)=> connectInput(e.target.value));

  $("preset").addEventListener("change", ()=> applyPreset($("preset").value));

  window.addEventListener("resize", resizeCanvas);

  enableUI(false);
})();
</script>
</body>
</html>
