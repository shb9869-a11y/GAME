<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
      content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
<title>SLEEEEEEEP – THE SECOND SLEEP</title>

<!-- 픽셀 게임 폰트 -->
<link rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SLEEP">
<meta name="theme-color" content="#000000">

<style>
:root{
  --appH: 100svh;
  --frame: clamp(16px, 4vmin, 40px);
  --ui-gap: 8px;

  --fs-body: clamp(12px, 2.2vmin, 16px);
  --fs-strong: clamp(14px, 2.8vmin, 20px);
  --fs-small: clamp(11px, 1.8vmin, 14px);

  --pad-btn-y: clamp(6px, 1.1vmin, 10px);
  --pad-btn-x: clamp(10px, 1.8vmin, 20px);

  --safe-t: env(safe-area-inset-top, 0px);
  --safe-b: env(safe-area-inset-bottom, 0px);
  --safe-l: env(safe-area-inset-left, 0px);
  --safe-r: env(safe-area-inset-right, 0px);

  --accent: #f5f5f5;
}

*{ box-sizing:border-box; margin:0; padding:0; user-select:none; }

html,body{
  width:100%;
  height:100%;
  overflow:hidden;
  touch-action:manipulation;
  background:#000;
  color:var(--accent);
}

.frameBox{
  position:fixed;
  left:var(--frame);
  right:var(--frame);
  top:var(--frame);
  bottom:var(--frame);
  border:2px solid rgba(255,255,255,0.8);
  pointer-events:none;
}

.hidden{ display:none !important; }

#blobCanvas{
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  image-rendering:pixelated;
  z-index:0;
}

/* GAME LAYOUT */
#gameLayout{
  position:fixed;
  inset:0;
  padding:calc(var(--frame) + 0px);
  z-index:20;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
}

#gameCard{
  width:100%;
  max-width:1120px;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:16px;
}

#gameScreenWrap{
  width:100%;
  max-width:720px;
  aspect-ratio:16/9;
  background:#001307;
  border:1px solid rgba(255,255,255,0.4);
  box-shadow:0 0 0 2px #000, 0 0 30px #000;
  position:relative;
  overflow:hidden;
  pointer-events:auto;
}

#gameCanvas{
  width:100%;
  height:100%;
  position:relative;
  z-index:1;
  image-rendering:pixelated;
}

#docVideo{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  z-index:0;
}

#dialogBar{
  width:100%;
  max-width:720px;
  background:rgba(0,0,0,0.8);
  border:1px solid rgba(255,255,255,0.6);
  padding:14px;
  box-shadow:0 0 20px #000;
  pointer-events:auto;
}

#dialogText{
  font-size:clamp(11px,2vmin,14px);
  font-family:"Courier New",ui-monospace;
  white-space:pre-wrap;
  line-height:1.7;
}

#dialogChoices{ margin-top:10px; display:flex; flex-wrap:wrap; gap:6px; }
.uiBtn{ color:white; background:rgba(0,0,0,0.7); border:1px solid #fff; padding:6px 10px; }
.uiBtn:active{ background:white; color:black; }

#dialogNext{ margin-left:auto; }

/* HUD */
#hudLeft{
  position:fixed;
  left:var(--frame);
  bottom:var(--frame);
  z-index:50;
}
.dpad{
  width:96px;
  height:96px;
  position:relative;
}
.dpad button{
  width:32px;
  height:32px;
  position:absolute;
  border-radius:6px;
  border:1px solid #fff;
  background:#000;
  color:white;
}
.dpad-up{ left:32px; top:0;}
.dpad-down{ left:32px; bottom:0;}
.dpad-left{ left:0; top:32px;}
.dpad-right{ right:0; top:32px;}

#hudRight{
  position:fixed;
  right:var(--frame);
  bottom:var(--frame);
  z-index:50;
}
#actionBtn{
  width:72px;
  height:72px;
  border-radius:50%;
  border:2px solid #fff;
  background:#a2192f;
  color:white;
  font-family:"Press Start 2P";
}

#stageFade{
  position:fixed;
  inset:0;
  background:black;
  z-index:200;
  opacity:0;
  pointer-events:none;
  transition:opacity .8s;
}
</style>
</head>
<body>

<canvas id="blobCanvas"></canvas>
<div class="frameBox"></div>

<!-- 게임 전체 -->
<div id="gameLayout" class="hidden">
  <div id="gameCard">
    <div id="gameScreenWrap">
      <canvas id="gameCanvas" width="320" height="180"></canvas>
      <video id="docVideo" class="hidden" playsinline webkit-playsinline></video>
    </div>

    <div id="dialogBar" class="hidden">
      <div id="dialogText"></div>
      <div id="dialogChoices" class="hidden"></div>
      <button id="dialogNext" class="uiBtn">NEXT</button>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="hudLeft" class="hidden">
  <div class="dpad">
    <button class="dpad-up" data-dir="up">▲</button>
    <button class="dpad-down" data-dir="down">▼</button>
    <button class="dpad-left" data-dir="left">◀</button>
    <button class="dpad-right" data-dir="right">▶</button>
  </div>
</div>
<div id="hudRight" class="hidden">
  <button id="actionBtn">A</button>
</div>

<div id="stageFade" class="hidden"></div>

<script>
(() => {
  const qs = s => document.querySelector(s);
  const sleep = ms => new Promise(r=>setTimeout(r,ms));
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  /* DOM */
  const gameLayout = qs('#gameLayout');
  const gameCanvas = qs('#gameCanvas');
  const gctx = gameCanvas.getContext('2d');
  const dialogBar = qs('#dialogBar');
  const dialogTextElem = qs('#dialogText');
  const dialogNextBtn = qs('#dialogNext');
  const dialogChoices = qs('#dialogChoices');
  const hudLeft = qs('#hudLeft');
  const hudRight = qs('#hudRight');
  const dpad = qs('#hudLeft .dpad');   /* 중복 문제 해결된 부분 */
  const actionBtn = qs('#actionBtn');
  const stageFade = qs('#stageFade');
  const docVideo = qs('#docVideo');

  /* 오디오 */
  let audioCtx = null;
  let musicRunning = false;

  function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    }
  }
  async function ensureResumed(){
    ensureAudio();
    if(audioCtx.state==='suspended'){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }

  /* 귀여운 시작 음악 */
  function playNote(freq, dur=0.15, vol=0.4, type='square'){
    try{
      ensureAudio();
      const ctx = audioCtx;
      const now = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(vol, now+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
      o.connect(g).connect(ctx.destination);
      o.start(now);
      o.stop(now+dur+0.05);
    }catch(e){}
  }

  function startBrightMusic(){
    if(musicRunning) return;
    musicRunning=true;
    const base=523.25;
    const pattern=[0,4,7,12,7,4,0,7,2,5,9,14,9,5,2,7];
    let idx=0;
    function step(){
      if(!musicRunning) return;
      const semi=pattern[idx%pattern.length];
      const f=base*Math.pow(2,semi/12);
      playNote(f,0.14,0.4);
      idx++;
      setTimeout(step,150);
    }
    step();
  }

  /* 미로 음악 */
  function startDarkMusic(){
    musicRunning=false;
    setTimeout(()=>{
      if(musicRunning) return;
      musicRunning=true;
      const base=440;
      const pattern=[0,3,7,10,3,7,0,-2];
      let idx=0;
      function step(){
        if(!musicRunning) return;
        const semi=pattern[idx%pattern.length];
        const f=base*Math.pow(2,semi/12);
        playNote(f,0.22,0.28,'sawtooth');
        idx++;
        setTimeout(step,260);
      }
      step();
    },400);
  }

  /* 우주 패드 */
  function startVideoAmbientMusic(){
    musicRunning=false;
    setTimeout(()=>{
      if(musicRunning) return;
      musicRunning=true;
      const base=220;
      const pattern=[0,7,12,5,0,-5];
      let idx=0;
      function step(){
        if(!musicRunning) return;
        const semi=pattern[idx%pattern.length];
        const f=base*Math.pow(2,semi/12);
        playNote(f,0.8,0.18,'sine');
        idx++;
        setTimeout(step,900);
      }
      step();
    },400);
  }

  /* ==== 이동 입력 ==== */
  let moveLeft=false, moveRight=false, moveUp=false, moveDown=false, actionPressed=false;

  if(dpad){
    dpad.addEventListener('pointerdown', e=>{
      const b=e.target.closest('button[data-dir]');
      if(!b) return;
      const d=b.dataset.dir;
      if(d==='left') moveLeft=true;
      if(d==='right') moveRight=true;
      if(d==='up') moveUp=true;
      if(d==='down') moveDown=true;
    });
    dpad.addEventListener('pointerup', e=>{
      const b=e.target.closest('button[data-dir]');
      if(!b) return;
      const d=b.dataset.dir;
      if(d==='left') moveLeft=false;
      if(d==='right') moveRight=false;
      if(d==='up') moveUp=false;
      if(d==='down') moveDown=false;
    });
  }

  actionBtn.addEventListener('pointerdown', ()=>actionPressed=true);
  actionBtn.addEventListener('pointerup', ()=>actionPressed=false);

  window.addEventListener('keydown', e=>{
    if(e.code==='ArrowLeft') moveLeft=true;
    if(e.code==='ArrowRight') moveRight=true;
    if(e.code==='ArrowUp') moveUp=true;
    if(e.code==='ArrowDown') moveDown=true;
    if(e.code==='Space') actionPressed=true;
  });
  window.addEventListener('keyup', e=>{
    if(e.code==='ArrowLeft') moveLeft=false;
    if(e.code==='ArrowRight') moveRight=false;
    if(e.code==='ArrowUp') moveUp=false;
    if(e.code==='ArrowDown') moveDown=false;
    if(e.code==='Space') actionPressed=false;
  });

  /* ==== 사이드뷰 ==== */
  const W=gameCanvas.width;
  const H=gameCanvas.height;

  const groundY=145;
  const sofaX=210;
  const sofaWidth=70;
  const sofaHeight=26;

  let playerX=40;
  let playerY=groundY-16;
  let playerVX=0;

  let gameState='introWalk';
  let gameStarted=false;

  function drawRedRabbit(ctx,x,y,scale=1){
    ctx.fillStyle='#ff3333';
    ctx.fillRect(x+2*scale,y+1*scale,4*scale,3*scale);
    ctx.fillRect(x+1*scale,y-1*scale,scale,3*scale);
    ctx.fillRect(x+4*scale,y-1*scale,scale,3*scale);
    ctx.fillRect(x+2*scale,y+4*scale,4*scale,3*scale);
    ctx.fillRect(x+6*scale,y+4*scale,2*scale,2*scale);
  }

  /* ==== 미로 ==== */
  const tileSize=16;
  const mazeMap=[
    "11111111111111111111",
    "10000001000000000001",
    "10111101011111111001",
    "10100100010000001001",
    "10100111110111101001",
    "10100000000100101001",
    "10101111110100101001",
    "10101000010100101001",
    "10101011110100101001",
    "10001000000000100001",
    "11111111111111111111"
  ];

  const mazeBlobs=[
    {tx:10,ty:2},
    {tx:10,ty:8},
    {tx:4, ty:5},
    {tx:16,ty:5},
    {tx:10,ty:5}
  ];
  let blobVisited=[false,false,false,false,false];

  const mazeStartTile={tx:1,ty:8};
  const mazeStartX=(mazeStartTile.tx+0.5)*tileSize;
  const mazeStartY=(mazeStartTile.ty+0.5)*tileSize;
  let mazePlayerX=mazeStartX, mazePlayerY=mazeStartY;
  const mazeSpeed=1.1;

  function isWall(px,py){
    const tx=Math.floor(px/tileSize);
    const ty=Math.floor(py/tileSize);
    if(ty<0||ty>=mazeMap.length) return true;
    if(tx<0||tx>=mazeMap[0].length) return true;
    return mazeMap[ty].charAt(tx)==='1';
  }

  /* ==== 대화 ==== */
  let currentLines=[];
  let currentIdx=0;
  let typing=false;
  let fullLine="";
  let dialogMode='normal';
  let onDialogDone=null;
  let currentBlobIndex=-1;

  function clearChoices(){
    dialogChoices.innerHTML="";
    dialogChoices.classList.add('hidden');
    dialogNextBtn.classList.remove('hidden');
  }

  async function showDialog(lines,cb=null){
    currentLines=lines;
    currentIdx=0;
    onDialogDone=cb;
    dialogBar.classList.remove('hidden');
    clearChoices();
    dialogTextElem.textContent="";
    await typeCurrent();
  }

  async function typeCurrent(){
    fullLine=currentLines[currentIdx]||"";
    typing=true;
    dialogTextElem.textContent="";
    for(let i=0;i<fullLine.length;i++){
      dialogTextElem.textContent+=fullLine[i];
      await sleep(40);
    }
    typing=false;
  }

  dialogNextBtn.addEventListener('click',()=>{
    if(typing){
      typing=false;
      dialogTextElem.textContent=fullLine;
      return;
    }
    currentIdx++;
    if(currentIdx>=currentLines.length){
      dialogBar.classList.add('hidden');
      if(onDialogDone) onDialogDone();
      return;
    }
    typeCurrent();
  });

  /* ==== 사이드뷰 루프 ==== */
  let introStart=0;

  function update(){
    if(!gameStarted) return;

    if(gameState==='introWalk'){
      const t=clamp((performance.now()-introStart)/1200,0,1);
      const start=-24, end=56;
      playerX = start + (end-start)*t;
      playerY = groundY-16;
      if(t>=1){
        gameState='introDialog';
        showDialog([
          "안녕?",
          "나는 너야.",
          "한 번 걸어볼까?",
          "저기 소파 보이지?"
        ],()=>{
          gameState='freeSofa';
        });
      }
      return;
    }

    if(gameState==='freeSofa'){
      let ax=0;
      if(moveLeft) ax-=0.14;
      if(moveRight) ax+=0.14;
      playerVX+=ax;
      playerVX*=0.85;
      playerX+=playerVX;

      if(playerX>sofaX-12 && actionPressed){
        sitSofa();
      }
      return;
    }

    if(gameState==='freeBlob'){
      let ax=0;
      if(moveLeft) ax-=0.14;
      if(moveRight) ax+=0.14;
      playerVX+=ax;
      playerVX*=0.85;
      playerX+=playerVX;
      if(Math.abs(playerX - (W/2)) <20 && actionPressed){
        enterBlob();
      }
      return;
    }

    if(gameState==='maze'){
      let dx=0,dy=0;
      if(moveLeft) dx-=mazeSpeed;
      if(moveRight) dx+=mazeSpeed;
      if(moveUp) dy-=mazeSpeed;
      if(moveDown) dy+=mazeSpeed;

      const nx=mazePlayerX+dx;
      const ny=mazePlayerY+dy;
      if(!isWall(nx,mazePlayerY)) mazePlayerX=nx;
      if(!isWall(mazePlayerX,ny)) mazePlayerY=ny;

      checkMazeBlobs();
      return;
    }
  }

  function draw(){
    const ctx=gctx;
    if(gameState==='maze'){
      drawMaze();
      return;
    }
    if(gameState==='blobVideo'){
      drawBlobVideoFrame();
      return;
    }
    if(gameState==='blobVideoBlack'){
      ctx.fillStyle='#000';
      ctx.fillRect(0,0,W,H);
      return;
    }
    drawSide();
  }

  function drawSide(){
    const ctx=gctx;
    ctx.fillStyle='#05210f';
    ctx.fillRect(0,0,W,H);

    ctx.fillStyle='#0b2f18';
    ctx.fillRect(0,groundY,W,H-groundY);

    // sofa
    ctx.save();
    ctx.translate(sofaX,groundY-sofaHeight);
    ctx.fillStyle='#e8c93b';
    ctx.fillRect(0,8,sofaWidth,sofaHeight-8);
    ctx.restore();

    drawRedRabbit(ctx,playerX,playerY,3);
  }

  function drawMaze(){
    const ctx=gctx;
    ctx.fillStyle='#001307';
    ctx.fillRect(0,0,W,H);

    for(let y=0;y<mazeMap.length;y++){
      for(let x=0;x<mazeMap[0].length;x++){
        const t=mazeMap[y].charAt(x);
        const px=x*tileSize;
        const py=y*tileSize;
        if(t==='1'){
          ctx.fillStyle='#062711';
          ctx.fillRect(px,py,tileSize,tileSize);
        }else{
          ctx.fillStyle='#07351a';
          ctx.fillRect(px,py,tileSize,tileSize);
        }
      }
    }

    mazeBlobs.forEach(b=>{
      const cx=(b.tx+0.5)*tileSize;
      const cy=(b.ty+0.5)*tileSize;
      ctx.beginPath();
      ctx.arc(cx,cy,5,0,Math.PI*2);
      ctx.fillStyle='#000';
      ctx.fill();
      ctx.strokeStyle='rgba(190,230,190,0.8)';
      ctx.stroke();
    });

    drawRedRabbit(ctx,mazePlayerX-6,mazePlayerY-6,1.2);
  }

  function checkMazeBlobs(){
    for(let i=0;i<mazeBlobs.length;i++){
      if(blobVisited[i]) continue;
      const b=mazeBlobs[i];
      const cx=(b.tx+0.5)*tileSize;
      const cy=(b.ty+0.5)*tileSize;
      const dx=mazePlayerX-cx;
      const dy=mazePlayerY-cy;
      const d=Math.hypot(dx,dy);
      if(d<10){
        blobVisited[i]=true;
        currentBlobIndex=i;
        showMazeBlobDialog(i);
        break;
      }
    }
  }

  function showMazeBlobDialog(i){
    gameState='mazeDialog';
    showDialog(["어어..? 소리가 들린다."],()=>{
      showChoices(i);
    });
  }

  function showChoices(i){
    dialogChoices.innerHTML="";
    dialogChoices.classList.remove('hidden');
    dialogNextBtn.classList.add('hidden');

    const btn1=document.createElement('button');
    btn1.className='uiBtn';
    btn1.textContent="들어보기";
    btn1.onclick=()=>playBlobStory(i);

    const btn2=document.createElement('button');
    btn2.className='uiBtn';
    btn2.textContent="무시하기";
    btn2.onclick=()=>{
      dialogBar.classList.add('hidden');
      gameState='maze';
    };

    dialogChoices.appendChild(btn1);
    dialogChoices.appendChild(btn2);
  }

  const blobStories=[
    "이곳이 나를 원하지 않는다면...",
    "표백공장의 더러운 물이 흘러든다...",
    "쓰레기 산 위에 까마귀가 맴돌았다...",
    "GPS 신발은 3500km를 이동했다...",
    "붕대는 발가락 대신 균형을 잡아준다..."
  ];

  function playBlobStory(i){
    dialogChoices.classList.add('hidden');
    dialogNextBtn.classList.remove('hidden');
    showDialog([blobStories[i]],()=>{
      askEnter(i);
    });
  }

  function askEnter(i){
    showDialog(["들어가볼까?"],()=>{
      dialogChoices.innerHTML="";
      dialogChoices.classList.remove('hidden');
      dialogNextBtn.classList.add('hidden');

      const b1=document.createElement('button');
      b1.className='uiBtn';
      b1.textContent="들어가지";
      b1.onclick=()=> startBlobVideo(i);

      const b2=document.createElement('button');
      b2.className='uiBtn';
      b2.textContent="더 둘러보기";
      b2.onclick=()=>{
        dialogBar.classList.add('hidden');
        gameState='maze';
      };

      dialogChoices.appendChild(b1);
      dialogChoices.appendChild(b2);
    });
  }

  /* ==== 비디오 ==== */
  function getBlobVideoSrc(i){
    return `video/blob${i+1}.mp4`;
  }

  function startBlobVideo(i){
    dialogBar.classList.add('hidden');
    musicRunning=false;
    startVideoAmbientMusic();

    const src=getBlobVideoSrc(i);
    docVideo.src=src;
    docVideo.classList.remove('hidden');
    ensureResumed().then(()=>docVideo.play().catch(()=>{}));

    docVideo.onended=()=>{
      docVideo.classList.add('hidden');
      gameState='blobVideoBlack';
      musicRunning=false;
    };

    gameState='blobVideo';
  }

  function drawBlobVideoFrame(){
    const ctx=gctx;
    ctx.clearRect(0,0,W,H);
    drawRedRabbit(ctx, W/2-12, H-40, 3);
  }

  /* ==== 소파 ==== */
  function sitSofa(){
    gameState='sofaTalk';
    showDialog([
      "좋아, 앉았네?",
      "제2장에 들어가보자.",
      "꿀렁이를 눌러줘."
    ],()=>{
      gameState='freeBlob';
    });
  }

  /* ==== 꿀렁이 ==== */
  function enterBlob(){
    dialogBar.classList.add('hidden');

    stageFade.classList.remove('hidden');
    requestAnimationFrame(()=> stageFade.style.opacity='1');

    musicRunning=false;
    startDarkMusic();

    setTimeout(()=>{
      stageFade.style.opacity='0';
      setTimeout(()=> stageFade.classList.add('hidden'),800);

      mazePlayerX=(mazeStartTile.tx-1)*tileSize;
      mazePlayerY=mazeStartY;
      gameState='maze';
    },900);
  }

  /* ==== 루프 ==== */
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  /* ==== 시작 ==== */
  window.addEventListener('load', async ()=>{
    ensureAudio();
    await ensureResumed();

    gameLayout.classList.remove('hidden');
    hudLeft.classList.remove('hidden');
    hudRight.classList.remove('hidden');

    introStart=performance.now();
    gameStarted=true;
    startBrightMusic();
  });

})();
</script>
</body>
</html>
