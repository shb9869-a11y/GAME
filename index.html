<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, interactive-widget=resizes-content"/>
<title>Pixel Maze — Stable Popup</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#000000">
<style>
  :root{
    --fg:#fff; --mut:#cfcfe8;
    --hud-pad: 16px;          /* 내부 패딩(고정) */
    --btnPx: 72px;            /* JS에서 stage 크기로 자동 보정 */
    --gap: 10px; --radius: 16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#0a0a0f;color:var(--fg);
    font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,"Noto Sans KR",Segoe UI,Roboto;-webkit-text-size-adjust:100%}
  body,button{-webkit-tap-highlight-color:transparent}
  *{-webkit-user-select:none;user-select:none}

  /* ===== Popup stage ===== */
  .wrap{position:fixed; inset:0; display:grid; place-items:center; padding:clamp(8px,3vmin,28px)}
  .stage{
    position:relative;
    width:min(96vw, 1200px);
    aspect-ratio:16/9;
    background:#000; border-radius:18px;
    border:1.2px solid rgba(255,255,255,.28);
    box-shadow:0 24px 80px rgba(0,0,0,.75), 0 0 0 1px rgba(255,255,255,.06) inset;
    overflow:hidden;
  }
  canvas{display:block; width:100%; height:100%; touch-action:none}

  /* ===== HUD in popup ===== */
  #hud{pointer-events:none}
  #hud,.corner{position:absolute; inset:0}
  .corner{display:flex; padding: calc(env(safe-area-inset-bottom,0) + var(--hud-pad)) var(--hud-pad) var(--hud-pad) var(--hud-pad)}
  .bl{justify-content:flex-start; align-items:flex-end}
  .br{justify-content:flex-end; align-items:flex-end}

  .dpad{
    pointer-events:auto; position:relative;
    width: calc(var(--btnPx) * 3 + var(--gap) * 2);
    height: calc(var(--btnPx) * 3 + var(--gap) * 2);
    display:grid; grid-template-columns: repeat(3,1fr); grid-template-rows: repeat(3,1fr);
    gap: var(--gap);
  }
  .dpad .spacer{opacity:0}
  .btn{
    pointer-events:auto; display:flex; align-items:center; justify-content:center;
    width: var(--btnPx); height: var(--btnPx);
    background: rgba(255,255,255,.04); border:1.2px solid #fff; color:#fff; border-radius: var(--radius);
    transition: transform .05s, background .2s, color .2s;
  }
  .btn:active{ transform:scale(.96); background:#fff; color:#000 }
  .btn .arrow{ width:0; height:0; border-style:solid }
  .btn[data-dir="up"]    .arrow{ border-width:0 12px 18px 12px;  border-color:transparent transparent currentColor transparent }
  .btn[data-dir="down"]  .arrow{ border-width:18px 12px 0 12px;  border-color:currentColor transparent transparent transparent }
  .btn[data-dir="left"]  .arrow{ border-width:12px 18px 12px 0;   border-color:transparent currentColor transparent transparent }
  .btn[data-dir="right"] .arrow{ border-width:12px 0 12px 18px;   border-color:transparent transparent transparent currentColor }

  .talk{
    pointer-events:auto; width: calc(var(--btnPx) * 1.2); height: calc(var(--btnPx) * 1.2);
    display:flex; align-items:center; justify-content:center;
    background: rgba(255,255,255,.04); border:1.2px solid #fff; border-radius:50%;
    transition: transform .05s, background .2s, color .2s;
  }
  .talk:active{ transform:scale(.96); background:#fff; color:#000 }
  .talk svg{ width:58%; height:58%; color:currentColor }

  #dialog{
    position:absolute; left:50%; bottom:12px; transform:translateX(-50%);
    max-width:min(720px,92%); background:#000; border:1px solid rgba(255,255,255,.22);
    border-radius:14px; padding:12px 14px; line-height:1.45; font-size:clamp(12px,1.8vmin,16px);
    display:none
  }
  #dialog strong{ color:var(--mut) }

  /* 세로일 때 안내 토스트(콘텐츠는 그대로 표시) */
  .toast{
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    background:rgba(0,0,0,.7); color:#fff; border:1px solid rgba(255,255,255,.25);
    border-radius:10px; padding:8px 12px; font-size:13px; z-index:5; display:none;
  }
  .toast.show{ display:block; }
</style>
</head>
<body>
<div id="toast" class="toast">가로모드에서 최적화됩니다. 기기를 눕혀주세요.</div>

<div class="wrap">
  <div id="stage" class="stage">
    <canvas id="game"></canvas>

    <div id="hud" aria-hidden="true">
      <div class="corner bl">
        <div class="dpad" id="dpad" role="group" aria-label="방향 패드">
          <button class="btn" data-dir="up"    style="grid-area:1/2" aria-label="위"><span class="arrow"></span></button>
          <button class="btn" data-dir="left"  style="grid-area:2/1" aria-label="왼쪽"><span class="arrow"></span></button>
          <div class="spacer" style="grid-area:2/2"></div>
          <button class="btn" data-dir="right" style="grid-area:2/3" aria-label="오른쪽"><span class="arrow"></span></button>
          <button class="btn" data-dir="down"  style="grid-area:3/2" aria-label="아래"><span class="arrow"></span></button>
        </div>
      </div>
      <div class="corner br">
        <button id="talkBtn" class="talk" aria-label="상호작용">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M21 6H5a2 2 0 0 0-2 2v12l4-4h14a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2Z"/></svg>
        </button>
      </div>
    </div>

    <div id="dialog" role="dialog" aria-live="polite"></div>
  </div>
</div>

<script>
(()=>{
  // ===== Stage / Canvas size (robust) =====
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));

  function sizeFromStage(){
    const r = stage.getBoundingClientRect();
    // 버튼 크기: 짧은 변의 18% (48~110px)
    const short = Math.min(r.width, r.height);
    const btn = Math.max(48, Math.min(110, Math.floor(short * 0.18)));
    document.documentElement.style.setProperty('--btnPx', btn + 'px');

    canvas.width  = Math.floor(r.width  * DPR);
    canvas.height = Math.floor(r.height * DPR);
  }
  new ResizeObserver(sizeFromStage).observe(stage);
  sizeFromStage();

  // 세로 안내 토스트(콘텐츠 숨기지 않음)
  const toast = document.getElementById('toast');
  function orientToast(){
    const portrait = window.innerHeight > window.innerWidth;
    toast.classList.toggle('show', portrait);
  }
  addEventListener('resize', orientToast, {passive:true}); orientToast();

  // ===== Palette & State =====
  const COL = { bg:'#1e1733', dot:'#3b2f63', wall:'#0a0814', outline:'#000', grave:'#2a2148', graveHL:'#6d59c7', white:'#fff', houseGrid:'#000', reed:'#e8e8f5' };
  const Scene={MAZE:0,FIELD:1,HOUSE:2};
  let scene=Scene.MAZE, inHouse=false;

  const CELL=32, WALL=6;           // Maze geometry
  const COLS=25, ROWS=17;
  const SPEED=2.0;

  const player={x:(Math.floor(COLS/2))*CELL+CELL/2, y:(ROWS-2)*CELL+CELL/2, r:8};

  const field={w:2200,h:1600};
  const house={x:field.w/2-160,y:140,w:320,h:320};
  const door ={x:house.x+house.w/2-30,y:house.y+house.h-60,w:60,h:60};
  let cam={x:0,y:0};

  // ===== Maze generation (DFS) =====
  const cells=Array.from({length:ROWS},(_,y)=>Array.from({length:COLS},(_,x)=>({x,y,v:false,w:[true,true,true,true]})));
  const stack=[]; let cur=cells[ROWS-2][Math.floor(COLS/2)]; cur.v=true; stack.push(cur);
  const dir4=[[0,-1,0],[1,0,1],[0,1,2],[-1,0,3]];
  while(stack.length){
    const c=stack[stack.length-1];
    const nbs=dir4.map(([dx,dy,wi],i)=>({dx,dy,wi,i,nx:c.x+dx,ny:c.y+dy}))
      .filter(n=>n.nx>0&&n.nx<COLS-1&&n.ny>0&&n.ny<ROWS-1&&!cells[n.ny][n.nx].v);
    if(nbs.length){
      const n=nbs[Math.floor(Math.random()*nbs.length)];
      const nx=cells[n.ny][n.nx];
      c.w[n.i]=false; nx.w[(n.i+2)%4]=false; nx.v=true; stack.push(nx);
    }else stack.pop();
  }
  const exitX=Math.floor(COLS/2);
  cells[0][exitX].w[0]=false;

  // 무덤 장식
  const graves=[];
  for(let y=1;y<ROWS-1;y++){
    for(let x=1;x<COLS-1;x++){
      const c=cells[y][x];
      const deadEnd = c.w.filter(Boolean).length===3;
      if(deadEnd && Math.random()<0.45){ graves.push({x:x*CELL+CELL/2, y:y*CELL+CELL/2}); }
    }
  }

  // ===== Input =====
  const keys={up:false,down:false,left:false,right:false};
  const mapKey={ArrowUp:'up',KeyW:'up',ArrowDown:'down',KeyS:'down',ArrowLeft:'left',KeyA:'left',ArrowRight:'right',KeyD:'right'};
  addEventListener('keydown',e=>{const d=mapKey[e.code]; if(d){keys[d]=true;e.preventDefault()} if(e.code==='KeyE') interact()},{passive:false});
  addEventListener('keyup',e=>{const d=mapKey[e.code]; if(d){keys[d]=false;e.preventDefault()}},{passive:false});

  const dpad=document.getElementById('dpad');
  let active=new Set();
  function setDir(d,v){keys[d]=v}
  dpad.querySelectorAll('.btn').forEach(b=>{
    const d=b.dataset.dir;
    const on=e=>{active.add(e.pointerId||'m');setDir(d,true);b.setPointerCapture?.(e.pointerId)};
    const off=e=>{active.delete(e.pointerId||'m');setDir(d,false)};
    b.addEventListener('pointerdown',on); b.addEventListener('pointerup',off);
    b.addEventListener('pointercancel',off); b.addEventListener('pointerleave',e=>{if(!active.size)setDir(d,false)});
  });
  document.getElementById('talkBtn').addEventListener('click', interact);

  // ===== Dialog =====
  const dialog=document.getElementById('dialog'); let dTimer=0;
  function say(t,ms=2300){dialog.textContent=''; const who=document.createElement('strong'); who.textContent='VOICE';
    dialog.appendChild(who); dialog.append(' · '+t); dialog.style.display='block';
    clearTimeout(dTimer); dTimer=setTimeout(()=>dialog.style.display='none',ms); }

  // ===== Helpers =====
  function hitRect(a,b){return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y}

  function stepMaze(nx,ny){
    const cx=Math.floor(player.x/CELL), cy=Math.floor(player.y/CELL);
    if(nx<player.x && cells[cy][cx].w[3]) nx=player.x;
    if(nx>player.x && cells[cy][cx].w[1]) nx=player.x;
    if(ny<player.y && cells[cy][cx].w[0]) ny=player.y;
    if(ny>player.y && cells[cy][cx].w[2]) ny=player.y;

    player.x=Math.max(CELL+player.r, Math.min(CELL*(COLS-1)-player.r, nx));
    player.y=Math.max(CELL+player.r, Math.min(CELL*(ROWS-1)-player.r, ny));

    if(player.y < CELL && !cells[0][Math.floor(player.x/CELL)].w[0]){
      scene=Scene.FIELD; player.x=field.w/2; player.y=field.h-140; say('들판으로 나왔다.',2000);
    }
  }

  function interact(){
    if(scene===Scene.MAZE){ say('위쪽 출구를 향해 이동'); return; }
    if(scene!==Scene.FIELD) return;
    const p={x:player.x-10,y:player.y-12,w:20,h:24};
    const near=hitRect(p,{x:door.x-8,y:door.y-8,w:door.w+16,h:door.h+16});
    if(!inHouse && near){ inHouse=true; say('집 안으로 들어왔다.'); }
    else if(inHouse){ inHouse=false; say('집 밖으로 나왔다.'); }
  }

  // ===== Loop =====
  let last=0;
  requestAnimationFrame(function loop(ts){
    const dt=(ts-last)||16; last=ts;
    const ax=(keys.right?1:0)-(keys.left?1:0);
    const ay=(keys.down?1:0)-(keys.up?1:0);
    const len=Math.hypot(ax,ay)||1;
    const v=SPEED*(dt/16)*2.0;

    if(scene===Scene.MAZE){
      stepMaze(player.x+(ax/len)*v, player.y+(ay/len)*v);
    }else if(scene===Scene.FIELD){
      if(!inHouse){
        player.x=Math.max(20,Math.min(field.w-20,player.x+(ax/len)*v*1.2));
        player.y=Math.max(20,Math.min(field.h-20,player.y+(ay/len)*v*1.2));
        const vw=canvas.width/DPR, vh=canvas.height/DPR;
        cam.x=Math.max(0,Math.min(field.w-vw,player.x-vw/2));
        cam.y=Math.max(0,Math.min(field.h-vh,player.y-vh/2));
      }else{
        player.x=Math.max(house.x+30,Math.min(house.x+house.w-30,player.x+(ax/len)*v));
        player.y=Math.max(house.y+40,Math.min(house.y+house.h-40,player.y+(ay/len)*v));
        cam.x=house.x; cam.y=house.y;
      }
    }

    render();
    requestAnimationFrame(loop);
  });

  // ===== Render (미로는 항상 중앙) =====
  function render(){
    const vw=canvas.width/DPR, vh=canvas.height/DPR;
    ctx.save(); ctx.scale(DPR,DPR);
    ctx.clearRect(0,0,vw,vh);

    if(scene===Scene.MAZE){
      const mazeW = COLS*CELL, mazeH = ROWS*CELL;
      const ox = Math.floor((vw - mazeW)/2);
      const oy = Math.floor((vh - mazeH)/2);

      ctx.fillStyle=COL.bg; ctx.fillRect(0,0,vw,vh);
      ctx.fillStyle=COL.dot; for(let i=0;i<700;i++){ const x=ox+((i*37)%mazeW); const y=oy+((i*89)%mazeH); ctx.fillRect(x,y,2,2); }
      ctx.strokeStyle=COL.outline; ctx.lineWidth=4; ctx.strokeRect(ox+4,oy+4,mazeW-8,mazeH-8);

      ctx.strokeStyle=COL.wall; ctx.lineWidth=WALL; ctx.lineCap='square';
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          const c=cells[y][x], sx=ox+x*CELL, sy=oy+y*CELL;
          if(c.w[0]){ctx.beginPath();ctx.moveTo(sx,sy);ctx.lineTo(sx+CELL,sy);ctx.stroke();}
          if(c.w[1]){ctx.beginPath();ctx.moveTo(sx+CELL,sy);ctx.lineTo(sx+CELL,sy+CELL);ctx.stroke();}
          if(c.w[2]){ctx.beginPath();ctx.moveTo(sx,sy+CELL);ctx.lineTo(sx+CELL,sy+CELL);ctx.stroke();}
          if(c.w[3]){ctx.beginPath();ctx.moveTo(sx,sy);ctx.lineTo(sx,sy+CELL);ctx.stroke();}
        }
      }
      graves.forEach(g=> drawGrave(ox + g.x, oy + g.y));
      drawPlayer(ox + player.x, oy + player.y);
    }

    if(scene===Scene.FIELD){
      const ox=cam.x, oy=cam.y;
      ctx.fillStyle='#120f20'; ctx.fillRect(0,0,vw,vh);

      if(!inHouse){
        ctx.strokeStyle=COL.reed; ctx.lineWidth=1;
        const spacing=60, margin=80;
        for(let gy=margin;gy<field.h-margin;gy+=spacing){
          for(let gx=margin;gx<field.w-margin;gx+=spacing){
            const x=gx-ox, y=gy-oy; if(x<-20||x>vw+20||y<-40||y>vh+40) continue;
            ctx.beginPath(); ctx.moveTo(x,y+16); ctx.lineTo(x,y-16); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x,y-16); ctx.lineTo(x+6,y-24); ctx.lineTo(x-6,y-24); ctx.closePath(); ctx.stroke();
          }
        }
        drawGridHouse(house.x-ox, house.y-oy, house.w, house.h);
        ctx.fillStyle='#000'; ctx.fillRect(door.x-ox, door.y-oy, door.w, door.h);
        ctx.strokeStyle='rgba(255,255,255,.65)'; ctx.strokeRect(door.x-ox, door.y-oy, door.w, door.h);
        drawPlayer(player.x-ox, player.y-oy);
      }else{
        const hx=house.x-ox, hy=house.y-oy;
        ctx.fillStyle='#111'; ctx.fillRect(0,0,vw,vh);
        ctx.fillStyle='#fff'; ctx.fillRect(hx,hy,house.w,house.h);
        ctx.strokeStyle='#000'; ctx.lineWidth=1;
        const s=30;
        for(let i=0;i<=house.w;i+=s){ctx.beginPath();ctx.moveTo(hx+i,hy);ctx.lineTo(hx+i,hy+house.h);ctx.stroke();}
        for(let j=0;j<=house.h;j+=s){ctx.beginPath();ctx.moveTo(hx,hy+j);ctx.lineTo(hx+house.w,hy+j);ctx.stroke();}
        ctx.fillStyle='#000'; ctx.fillRect(hx+house.w/2-30, hy+house.h-60, 60, 60);
        drawPlayer(player.x-ox, player.y-oy);
      }
    }

    ctx.restore();
  }

  // ===== Pixel sprites =====
  function drawPlayer(px,py){
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.ellipse(px, py+9, 9, 5, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#ff7a00'; ctx.fillRect(px-8,py-14,16,16);
    ctx.fillStyle='#ffa64d'; ctx.fillRect(px-8,py-14,16,6);
    ctx.fillStyle='#331400'; ctx.fillRect(px-10,py-4,4,6); ctx.fillRect(px+6,py-4,4,6);
    ctx.fillStyle='#351a00'; ctx.fillRect(px-7,py+2,6,10); ctx.fillRect(px+1,py+2,6,10);
    ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.strokeRect(px-8,py-14,16,16);
  }
  function drawGrave(x,y){
    const gx=x-10, gy=y-12;
    ctx.fillStyle='#2a2148'; ctx.fillRect(gx,gy,20,16);
    ctx.fillStyle='#000'; ctx.fillRect(gx+2,gy+14,16,4);
    ctx.fillStyle='#6d59c7'; ctx.fillRect(gx+3,gy+3,6,4);
    ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.strokeRect(gx,gy,20,16);
  }
  function drawGridHouse(x,y,w,h){
    ctx.fillStyle='#fff'; ctx.fillRect(x,y,w,h);
    ctx.strokeStyle:'#000'; ctx.lineWidth=1;
    const s=24;
    for(let i=0;i<=w;i+=s){ctx.beginPath();ctx.moveTo(x+i,y);ctx.lineTo(x+i,y+h);ctx.stroke();}
    for(let j=0;j<=h;j+=s){ctx.beginPath();ctx.moveTo(x,y+j);ctx.lineTo(x+w,y+j);ctx.stroke();}
  }

  // 안내 멘트
  setTimeout(()=>{ if(scene===Scene.MAZE) say('위쪽 출구로 이동하세요 · 문 앞에서 [E] 또는 말풍선 버튼'); }, 500);
})();
</script>
</body>
</html>
