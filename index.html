<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SLEEP â€“ 3D Red Field + Stable Links + TouchMe FX Morph (v4)</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;}

  #hint{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.72);
    color:#ddd; font-family:system-ui, -apple-system, sans-serif;
    text-align:center; padding:20px;
    z-index:50;
  }
  #hint .box{
    width:min(560px, 92vw);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:18px 16px;
    background:rgba(0,0,0,.55);
  }

  #topRight{
    position:fixed; right:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  .iconBtn{
    width:42px; height:42px;
    display:grid; place-items:center;
    background:rgba(0,0,0,.38);
    color:#eee;
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px;
    backdrop-filter: blur(10px);
    cursor:pointer;
    user-select:none;
    font-size:18px;
  }
  .iconBtn:hover{border-color:rgba(255,255,255,.30)}
  .iconBtn:active{transform:translateY(1px)}

  #ui{
    position:fixed; right:12px; top:62px;
    width:min(540px, calc(100vw - 24px));
    color:#ddd;
    font-family:system-ui, -apple-system, sans-serif;
    background:rgba(0,0,0,.42);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    box-shadow:0 0 0 1px rgba(255,255,255,.06) inset;
    backdrop-filter: blur(10px);
    overflow:hidden;
    z-index:40;
    transform-origin: top right;
  }
  #ui.hidden{display:none;}
  #bar{
    display:flex; align-items:center; gap:8px;
    padding:10px 10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  #bar .title{font-weight:750; font-size:13px; color:#eee;}
  #bar .pill{
    margin-left:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px; color:#bbb;
    padding:6px 8px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:999px;
    background:rgba(0,0,0,.25);
    white-space:nowrap;
  }

  button, select, input[type="text"], input[type="range"]{
    background:#0f0f0f; color:#eee;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:8px 10px;
    font-weight:650;
    outline:none;
  }
  input[type="range"]{ padding:8px 0; }
  button:hover, select:hover, input[type="text"]:hover{border-color:rgba(255,255,255,.32)}
  button:disabled, select:disabled, input:disabled{opacity:.5; cursor:not-allowed}

  #tabs{
    display:flex; gap:6px; padding:10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .tab{
    flex:1;
    padding:8px 10px;
    font-size:12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
    cursor:pointer;
    text-align:center;
    user-select:none;
  }
  .tab.active{
    border-color:rgba(255,255,255,.34);
    background:rgba(255,255,255,.06);
  }
  #panels{padding:10px;}
  .panel{display:none;}
  .panel.active{display:block;}

  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0;}
  .label{font-size:12px; color:#aaa; width:118px;}
  .grow{flex:1; min-width:180px;}

  .meter{
    height:10px; border-radius:999px;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .meter > i{
    display:block; height:100%;
    width:0%;
    background:rgba(255,255,255,.85);
  }

  .small{
    font-size:11px; color:#9aa;
    line-height:1.45;
  }
  .mono{
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    color:#bbb;
    white-space:pre-wrap;
    word-break:break-word;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:10px;
    padding:8px;
    max-height:160px;
    overflow:auto;
  }
</style>
</head>
<body>

<div id="hint">
  <div class="box">
    <div style="font-weight:800; font-size:16px; margin-bottom:10px;">SLEEP â€“ Start</div>
    <div class="small" style="margin-bottom:12px;">
      1) <b>Start Audio</b> â†’ ì˜¤ë””ì˜¤ ì–¸ë½<br/>
      2) <b>Mic ON</b> ë˜ëŠ” <b>Track Load</b> í›„ AUDIO íƒ­ì—ì„œ amp í™•ì¸<br/>
      3) TouchMeëŠ” MIDI íƒ­ì—ì„œ ë¡œê·¸ í™•ì¸
    </div>
    <div class="row">
      <button id="btnStartAudio">Start Audio</button>
      <button id="btnStartMic" disabled>Mic ON</button>
      <button id="btnStopMic" disabled>Mic OFF</button>
      <button id="btnFS">Fullscreen</button>
    </div>
    <div class="small" id="startStatus" style="opacity:.9"></div>
  </div>
</div>

<canvas id="c"></canvas>

<div id="topRight">
  <div class="iconBtn" id="btnGear" title="Settings">âš™ï¸</div>
  <div class="iconBtn" id="btnMuteQuick" title="Mute">ğŸ”‡</div>
  <div class="iconBtn" id="btnFSQuick" title="Fullscreen">â›¶</div>
</div>

<div id="ui" class="hidden">
  <div id="bar">
    <div class="title">Settings</div>
    <button id="btnHideUI" title="Close">ë‹«ê¸°</button>
    <div class="pill" id="topPill">audio:off | mic:off | track:off | midi:?</div>
  </div>

  <div id="tabs">
    <div class="tab active" data-tab="visual">VISUAL</div>
    <div class="tab" data-tab="audio">AUDIO</div>
    <div class="tab" data-tab="midi">MIDI</div>
    <div class="tab" data-tab="settings">SYSTEM</div>
  </div>

  <div id="panels">
    <div class="panel active" id="panel-visual">
      <div class="row">
        <div class="label">Particles</div>
        <select id="selN" class="grow">
          <option value="160">160</option>
          <option value="220" selected>220</option>
          <option value="320">320</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Keep in screen</div>
        <select id="selBounds" class="grow">
          <option value="soft" selected>Soft boundary</option>
          <option value="bounce">Bounce</option>
          <option value="wrap">Wrap</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Link density</div>
        <select id="selLink" class="grow">
          <option value="low">Low</option>
          <option value="mid" selected>Mid</option>
          <option value="high">High</option>
        </select>
      </div>

      <div class="small">
        ë¬´ìŒ: <b>ì›…ì¶• + ì‘ì€ ë¶‰ì€ ì </b> (í•˜ì§€ë§Œ <b>ì…ì²´ë¡œ ê³„ì† ì¡´ì¬</b>, ì‚¬ë¼ì§€ì§€ ì•ŠìŒ).<br/>
        í° ì†Œë¦¬ ë ‰ ë°©ì§€: ê³µê°„ í•´ì‹œ + ê±°ë¦¬ ìº¡ + <b>ì´ ë§í¬ ìˆ˜ ìƒí•œ</b> + ì˜¤ë””ì˜¤ ì»¤ë¸Œ <b>ìºì‹œ</b>.
      </div>
    </div>

    <div class="panel" id="panel-audio">
      <div class="row">
        <div class="label">Input level</div>
        <div class="grow"><div class="meter"><i id="meterIn"></i></div></div>
      </div>
      <div class="row">
        <div class="label">Amp / Î”</div>
        <div class="mono grow" id="txtAmp">amp: 0.000 | dAmp: 0.000</div>
      </div>
      <div class="row">
        <div class="label">FX (Touch)</div>
        <div class="mono grow" id="txtFx">â€”</div>
      </div>
      <div class="small">
        Touch ê°’ì´ ì˜¬ë¼ê°ˆìˆ˜ë¡: Drive/Wavefold/Filter Blend/Ring/Crusher/Widthê°€ í•¨ê»˜ <b>ë‹¤ì¸µ ëª¨í•‘</b>.
      </div>
    </div>

    <div class="panel" id="panel-midi">
      <div class="row">
        <div class="label">Touch value</div>
        <div class="grow"><div class="meter"><i id="meterTouch"></i></div></div>
      </div>
      <div class="row">
        <div class="label">MIDI log</div>
        <div class="mono grow" id="txtMIDI">Waitingâ€¦</div>
      </div>
    </div>

    <div class="panel" id="panel-settings">
      <div class="row">
        <div class="label">Audio context</div>
        <button id="btnResume" class="grow">Resume / Unlock Audio</button>
      </div>

      <div class="row">
        <div class="label">Route</div>
        <select id="selRoute" class="grow">
          <option value="both">Mic + Track</option>
          <option value="mic">Mic only</option>
          <option value="track">Track only</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Track file</div>
        <input id="fileTrack" class="grow" type="file" accept="audio/*" />
      </div>
      <div class="row">
        <div class="label">Track URL</div>
        <input id="inpTrackUrl" class="grow" type="text" placeholder="https://.../audio.mp3" />
        <button id="btnLoadUrl">Load</button>
      </div>
      <div class="row">
        <div class="label">Track control</div>
        <button id="btnTrackPlay" class="grow" disabled>Play</button>
        <button id="btnTrackPause" class="grow" disabled>Pause</button>
      </div>
      <div class="row">
        <div class="label">Track vol</div>
        <input id="rngTrackVol" class="grow" type="range" min="0" max="1" step="0.01" />
        <select id="selTrackLoop">
          <option value="1">Loop</option>
          <option value="0">No loop</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Mic input</div>
        <select id="selMic" class="grow" disabled>
          <option>ì¥ì¹˜ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</option>
        </select>
      </div>
      <div class="row">
        <div class="label">Speaker output</div>
        <select id="selSpk" class="grow" disabled>
          <option>ë¸Œë¼ìš°ì € ì§€ì› í™•ì¸ ì¤‘â€¦</option>
        </select>
      </div>
      <div class="row">
        <div class="label">Mic control</div>
        <button id="btnMicOn" class="grow" disabled>Mic ON</button>
        <button id="btnMicOff" class="grow" disabled>Mic OFF</button>
      </div>
      <div class="small" id="txtSupport"></div>
    </div>
  </div>
</div>

<script>
/* ==========================================================
   SETTINGS PERSISTENCE
========================================================== */
const STORE_KEY = "sleep_settings_v4";
function loadSettings(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
function saveSettings(obj){ localStorage.setItem(STORE_KEY, JSON.stringify(obj)); }
const S = loadSettings();

function applySelectValue(id, fallback){
  const el = document.getElementById(id);
  const v = (S[id] ?? fallback);
  if(el) el.value = v;
}
function hookSelectSave(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', ()=>{
    S[id] = el.value;
    saveSettings(S);
  });
}

/* ==========================================================
   HELPERS
========================================================== */
function startStatus(msg){
  const el=document.getElementById('startStatus');
  if(el) el.textContent=msg;
}
function toggleFullscreen(){
  const el=document.documentElement;
  if(!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
}

/* ==========================================================
   CANVAS
========================================================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  W = innerWidth|0; H = innerHeight|0;
  canvas.width  = (W*DPR)|0;
  canvas.height = (H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* ==========================================================
   AUDIO + AUDIOWORKLET BITCRUSHER
========================================================== */
let audioCtx;
let analyser, timeData;
let micStream=null, micSrc=null;
let masterGain, isMuted=false;

let preGain, driveWS, foldWS, postDriveGain;
let bp, notch, hp;
let gBP, gNotch, gHP;
let ringOsc, ringGain, ringMult;
let crusherNode, crusherMix, dryMix;
let splitter, dL, dR, merger, comp;

let amp=0, ampSmooth=0, ampDelta=0, prevAmp=0;

const CRUSHER_WORKLET = `
class BitCrusherProcessor extends AudioWorkletProcessor{
  static get parameterDescriptors(){
    return [
      { name: 'bitDepth', defaultValue: 16, minValue: 2, maxValue: 16, automationRate: 'k-rate' },
      { name: 'downSample', defaultValue: 1, minValue: 1, maxValue: 40, automationRate: 'k-rate' }
    ];
  }
  constructor(){ super(); this._phase=0; this._holdL=0; this._holdR=0; }
  process(inputs, outputs, params){
    const input=inputs[0], output=outputs[0];
    if(!input || input.length===0) return true;
    const inL=input[0], inR=input[1]||input[0];
    const outL=output[0], outR=output[1]||output[0];
    const bitDepth=params.bitDepth[0]||16;
    const downSample=params.downSample[0]||1;
    const step=Math.pow(0.5, bitDepth);
    for(let i=0;i<outL.length;i++){
      this._phase++;
      if(this._phase>=downSample){
        this._phase=0;
        this._holdL = Math.round(inL[i]/step)*step;
        this._holdR = Math.round(inR[i]/step)*step;
      }
      outL[i]=this._holdL; outR[i]=this._holdR;
    }
    return true;
  }
}
registerProcessor('bit-crusher', BitCrusherProcessor);
`;

/* ---- curve caching (fix big-sound GC lag) ---- */
const DRIVE_STEPS = 80;
const FOLD_STEPS  = 80;
const driveCurves = new Array(DRIVE_STEPS+1);
const foldCurves  = new Array(FOLD_STEPS+1);

function makeWaveshaperCurveSoft(amount=20){
  const n=2048, curve=new Float32Array(n);
  const k=amount;
  for(let i=0;i<n;i++){
    const x=(i*2/n)-1;
    curve[i] = (1+k)*x/(1+k*Math.abs(x));
  }
  return curve;
}
function makeWavefoldCurve(amount=2.0){
  const n=2048, curve=new Float32Array(n);
  for(let i=0;i<n;i++){
    let x=(i*2/n)-1;
    x *= amount;
    x = ((x + 1) % 4 + 4) % 4 - 1;
    if(x > 1) x = 2 - x;
    curve[i] = x;
  }
  return curve;
}
function getDriveCurve(t){
  const idx = Math.max(0, Math.min(DRIVE_STEPS, Math.round(t*DRIVE_STEPS)));
  if(!driveCurves[idx]){
    const amt = 6 + (idx/DRIVE_STEPS)*70;
    driveCurves[idx] = makeWaveshaperCurveSoft(amt);
  }
  return driveCurves[idx];
}
function getFoldCurve(t){
  const idx = Math.max(0, Math.min(FOLD_STEPS, Math.round(t*FOLD_STEPS)));
  if(!foldCurves[idx]){
    const foldAmt = 1.0 + Math.pow(idx/FOLD_STEPS, 1.5)*6.0;
    foldCurves[idx] = makeWavefoldCurve(foldAmt);
  }
  return foldCurves[idx];
}

/* ---- output routing ---- */
const monitorAudio = new Audio();
monitorAudio.autoplay = true;
monitorAudio.playsInline = true;
let monitorDest=null;
let outputSupported=false;

function setupOutputRouting(){
  if(!audioCtx) return;
  if(monitorDest) return;
  monitorDest = audioCtx.createMediaStreamDestination();
  masterGain.connect(monitorDest);
  monitorAudio.srcObject = monitorDest.stream;
}

/* ---- track source ---- */
let trackEl=null, trackSrc=null, trackGain=null;
let trackReady=false;

function ensureTrack(){
  if(trackEl) return;
  trackEl = new Audio();
  trackEl.crossOrigin = "anonymous";
  trackEl.preload = "auto";
  trackEl.playsInline = true;
  trackEl.loop = (S.selTrackLoop ?? "1") === "1";
}
function updateTrackButtons(){
  document.getElementById('btnTrackPlay').disabled = !audioCtx || !trackReady;
  document.getElementById('btnTrackPause').disabled = !audioCtx || !trackReady;
}
function connectTrackGraph(){
  if(!audioCtx) return;
  ensureTrack();
  if(trackSrc) return; // already connected
  try{
    trackSrc = audioCtx.createMediaElementSource(trackEl);
    trackGain = audioCtx.createGain();
    trackGain.gain.value = parseFloat(S.rngTrackVol ?? "0.75");
    trackSrc.connect(trackGain);
    // route to preGain (FX applies)
    trackGain.connect(preGain);
  }catch(e){
    console.warn("track graph connect failed:", e);
  }
}
async function loadTrackFromFile(file){
  await ensureAudio();
  ensureTrack();
  const url = URL.createObjectURL(file);
  trackEl.src = url;
  await trackEl.load?.();
  trackReady = true;
  connectTrackGraph();
  updateTrackButtons();
  updateTopPill();
  startStatus("Track loaded. Play ëˆŒëŸ¬ ì¬ìƒ!");
}
async function loadTrackFromURL(url){
  await ensureAudio();
  ensureTrack();
  trackEl.src = url;
  try{
    await trackEl.load?.();
    trackReady = true;
    connectTrackGraph();
    updateTrackButtons();
    updateTopPill();
    startStatus("Track URL loaded. Play ëˆŒëŸ¬ ì¬ìƒ!");
  }catch(e){
    alert("Track URL ë¡œë“œ ì‹¤íŒ¨(ì½”ë±/CORS/URL í™•ì¸).");
  }
}

async function ensureAudio(){
  if(audioCtx) return;

  audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  try{
    const blob = new Blob([CRUSHER_WORKLET], {type:'application/javascript'});
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
  }catch(e){
    console.warn("AudioWorklet load failed (crusher disabled):", e);
  }

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  timeData = new Uint8Array(analyser.fftSize);

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;

  preGain = audioCtx.createGain(); preGain.gain.value = 1.0;

  driveWS = audioCtx.createWaveShaper();
  driveWS.curve = getDriveCurve(0);
  driveWS.oversample = '4x';

  foldWS = audioCtx.createWaveShaper();
  foldWS.curve = getFoldCurve(0);
  foldWS.oversample = '4x';

  postDriveGain = audioCtx.createGain();
  postDriveGain.gain.value = 1.0;

  bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=900; bp.Q.value=2.0;
  notch = audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=900; notch.Q.value=1.0;
  hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=120; hp.Q.value=0.7;

  gBP = audioCtx.createGain(); gBP.gain.value=1;
  gNotch = audioCtx.createGain(); gNotch.gain.value=0;
  gHP = audioCtx.createGain(); gHP.gain.value=0;

  ringOsc = audioCtx.createOscillator();
  ringOsc.type='sine';
  ringOsc.frequency.value=35;

  ringGain = audioCtx.createGain(); ringGain.gain.value=0.0;
  ringMult = audioCtx.createGain(); ringMult.gain.value=1.0;

  ringOsc.connect(ringGain);
  ringGain.connect(ringMult.gain);

  dryMix = audioCtx.createGain(); dryMix.gain.value=1.0;
  crusherMix = audioCtx.createGain(); crusherMix.gain.value=0.0;

  splitter = audioCtx.createChannelSplitter(2);
  dL = audioCtx.createDelay(0.05);
  dR = audioCtx.createDelay(0.05);
  dL.delayTime.value=0.004;
  dR.delayTime.value=0.011;
  merger = audioCtx.createChannelMerger(2);

  comp = audioCtx.createDynamicsCompressor();
  comp.threshold.value=-18;
  comp.knee.value=24;
  comp.ratio.value=5;
  comp.attack.value=0.004;
  comp.release.value=0.12;

  // graph: preGain -> drive -> fold -> post -> (filters sum) -> ringMult -> (dry+crusher) -> widen -> comp -> analyser -> master -> out
  preGain.connect(driveWS);
  driveWS.connect(foldWS);
  foldWS.connect(postDriveGain);

  postDriveGain.connect(bp);    bp.connect(gBP);
  postDriveGain.connect(notch); notch.connect(gNotch);
  postDriveGain.connect(hp);    hp.connect(gHP);

  gBP.connect(ringMult);
  gNotch.connect(ringMult);
  gHP.connect(ringMult);

  ringMult.connect(dryMix);

  if(audioCtx.audioWorklet){
    try{
      crusherNode = new AudioWorkletNode(audioCtx, 'bit-crusher');
      ringMult.connect(crusherNode);
      crusherNode.connect(crusherMix);
    }catch(e){ crusherNode=null; }
  }

  const sum = audioCtx.createGain();
  dryMix.connect(sum);
  crusherMix.connect(sum);

  sum.connect(splitter);
  splitter.connect(dL,0);
  splitter.connect(dR,1);
  dL.connect(merger,0,0);
  dR.connect(merger,0,1);

  merger.connect(comp);
  comp.connect(analyser);
  analyser.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  ringOsc.start();
  setupOutputRouting();
  updateTopPill();

  // restore UI persisted
  document.getElementById('btnStartMic').disabled = false;
  document.getElementById('btnMicOn').disabled = false;

  // restore track settings
  document.getElementById('rngTrackVol').value = (S.rngTrackVol ?? "0.75");
  document.getElementById('selTrackLoop').value = (S.selTrackLoop ?? "1");
  document.getElementById('selRoute').value = (S.selRoute ?? "both");
}

/* ---- amp ---- */
function updateAmp(){
  if(!analyser) return;
  analyser.getByteTimeDomainData(timeData);
  let sum=0;
  for(let i=0;i<timeData.length;i++){
    const v=(timeData[i]-128)/128;
    sum+=v*v;
  }
  const rms=Math.sqrt(sum/timeData.length);
  ampSmooth += (rms-ampSmooth)*0.12;
  amp = ampSmooth;
  ampDelta = Math.abs(amp - prevAmp);
  prevAmp = amp;
}

/* ==========================================================
   DEVICES
========================================================== */
const selMic = document.getElementById('selMic');
const selSpk = document.getElementById('selSpk');
const txtSupport = document.getElementById('txtSupport');

let currentMicDeviceId = S.currentMicDeviceId ?? "default";

async function listDevices(){
  let devices=[];
  try{ devices = await navigator.mediaDevices.enumerateDevices(); }catch(e){}

  const mics = devices.filter(d=>d.kind==="audioinput");
  const spks = devices.filter(d=>d.kind==="audiooutput");

  selMic.innerHTML="";
  if(mics.length===0){
    selMic.disabled=true;
    selMic.innerHTML = `<option>ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ</option>`;
  }else{
    selMic.disabled=false;
    for(const d of mics){
      const opt=document.createElement('option');
      opt.value=d.deviceId;
      opt.textContent=d.label || `Mic (${d.deviceId.slice(0,6)}â€¦)`;
      if(d.deviceId===currentMicDeviceId) opt.selected=true;
      selMic.appendChild(opt);
    }
  }

  outputSupported = typeof monitorAudio.setSinkId === "function";
  selSpk.innerHTML="";
  if(!outputSupported){
    selSpk.disabled=true;
    selSpk.innerHTML = `<option>ë¸Œë¼ìš°ì €ê°€ ì¶œë ¥ ì„ íƒì„ ì§€ì›í•˜ì§€ ì•ŠìŒ</option>`;
  }else{
    selSpk.disabled=false;
    if(spks.length===0){
      selSpk.innerHTML = `<option value="default">default</option>`;
    }else{
      for(const d of spks){
        const opt=document.createElement('option');
        opt.value=d.deviceId;
        opt.textContent=d.label || `Speaker (${d.deviceId.slice(0,6)}â€¦)`;
        if(S.currentSpkDeviceId && d.deviceId===S.currentSpkDeviceId) opt.selected=true;
        selSpk.appendChild(opt);
      }
    }
    if(S.currentSpkDeviceId){
      try{ await monitorAudio.setSinkId(S.currentSpkDeviceId); }catch(e){}
    }
  }

  txtSupport.textContent =
    `ì§€ì› ìƒíƒœ: mic=${mics.length} | spk=${spks.length} | outputSelect=${outputSupported?'YES':'NO'} | crusher=${crusherNode?'YES':'NO'}\n`+
    `í° ì†Œë¦¬ ë ‰ ë°©ì§€: (1) ë§í¬ ìƒí•œ (2) í•´ì‹œ ê²€ìƒ‰ (3) ì»¤ë¸Œ ìºì‹œ.`;
}

selMic.addEventListener('change', async ()=>{
  currentMicDeviceId = selMic.value;
  S.currentMicDeviceId = currentMicDeviceId;
  saveSettings(S);
  if(micStream) await startMic(currentMicDeviceId);
});

selSpk.addEventListener('change', async ()=>{
  if(!outputSupported) return;
  S.currentSpkDeviceId = selSpk.value;
  saveSettings(S);
  try{ await monitorAudio.setSinkId(selSpk.value); }catch(e){
    alert("ì´ í™˜ê²½ì—ì„œëŠ” ìŠ¤í”¼ì»¤ ì¶œë ¥ ì„ íƒì´ ì‹¤íŒ¨í–ˆì–´ìš”.");
  }
});

/* ==========================================================
   MIC
========================================================== */
function setStartButtons(micOn){
  document.getElementById('btnStartMic').disabled = !audioCtx || micOn;
  document.getElementById('btnStopMic').disabled  = !micOn;
  document.getElementById('btnMicOn').disabled    = !audioCtx || micOn;
  document.getElementById('btnMicOff').disabled   = !micOn;
}

async function startMic(deviceId="default"){
  await ensureAudio();
  await audioCtx.resume();
  stopMic();

  try{
    micStream = await navigator.mediaDevices.getUserMedia({
      audio:{
        deviceId: deviceId ? {exact:deviceId} : undefined,
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false
      }
    });

    micSrc = audioCtx.createMediaStreamSource(micStream);

    // route option
    const route = document.getElementById('selRoute').value;
    if(route==="mic" || route==="both"){
      micSrc.connect(preGain);
    }

    await listDevices();
    updateTopPill();
    setStartButtons(true);
    startStatus("Mic ON. AUDIO íƒ­ì—ì„œ amp ì›€ì§ì´ëŠ”ì§€ í™•ì¸!");
  }catch(e){
    console.error(e);
    startStatus("Mic ON ì‹¤íŒ¨. ê¶Œí•œ/ì¥ì¹˜ ì„ íƒ í™•ì¸.");
    alert("ë§ˆì´í¬ ê¶Œí•œ ë˜ëŠ” ì¥ì¹˜ ì„ íƒ ì‹¤íŒ¨. í¬ë¡¬ ì‚¬ì´íŠ¸ ê¶Œí•œ í™•ì¸!");
  }
}

function stopMic(){
  if(micStream){
    micStream.getTracks().forEach(t=>t.stop());
    micStream=null;
  }
  if(micSrc){
    try{ micSrc.disconnect(); }catch(e){}
    micSrc=null;
  }
  updateTopPill();
  setStartButtons(false);
}

/* ==========================================================
   MIDI (TouchMe)
========================================================== */
let touch=0, touchSmooth=0;
let midiName="MIDI: ?";
let midiLog=[];

function pushMidiLog(line){
  midiLog.push(line);
  if(midiLog.length>18) midiLog.shift();
  document.getElementById('txtMIDI').textContent = `${midiName}\n` + midiLog.join('\n');
}

async function initMIDI(){
  if(!navigator.requestMIDIAccess){
    midiName="MIDI: not supported";
    pushMidiLog("requestMIDIAccess ì—†ìŒ");
    return;
  }
  try{
    const midi = await navigator.requestMIDIAccess({sysex:false});
    const inputs=[...midi.inputs.values()];
    if(inputs.length===0){
      midiName="MIDI: no inputs";
      pushMidiLog("MIDI ì…ë ¥ ì¥ì¹˜ ì—†ìŒ");
      return;
    }
    const input=inputs[0];
    midiName="MIDI: "+(input.name||"input");
    pushMidiLog("Connected: "+midiName);

    input.onmidimessage=(e)=>{
      const data=[...e.data];
      const v=data[2] ?? 0;
      touch = Math.max(0, Math.min(1, v/127));
      pushMidiLog(`data=[${data.join(',')}] -> touch=${touch.toFixed(3)}`);
    };
  }catch(e){
    console.error(e);
    midiName="MIDI: blocked";
    pushMidiLog("MIDI access failed");
  }
}
function updateTouch(){ touchSmooth += (touch-touchSmooth)*0.18; }

/* ==========================================================
   FX MORPH (TouchMe -> ë‹¤ì–‘í•œ ì™œê³¡ ë°©í–¥)
========================================================== */
function applyFX(){
  if(!audioCtx) return;
  const t = touchSmooth;

  // Drive/Fold curves via cache (NO per-frame allocations)
  driveWS.curve = getDriveCurve(t);
  foldWS.curve  = getFoldCurve(t);

  // gain compensation
  postDriveGain.gain.setTargetAtTime(0.95 - t*0.28, audioCtx.currentTime, 0.03);

  // filter motion (wider morph)
  const f = 120 + Math.pow(t, 1.7)*6200;
  bp.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.03);
  notch.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.03);
  hp.frequency.setTargetAtTime(70 + t*900, audioCtx.currentTime, 0.03);

  bp.Q.setTargetAtTime(1.4 + t*12, audioCtx.currentTime, 0.03);
  notch.Q.setTargetAtTime(0.7 + t*10, audioCtx.currentTime, 0.03);
  hp.Q.setTargetAtTime(0.7 + t*1.0, audioCtx.currentTime, 0.03);

  // blend: BP -> Notch -> HP + extra "weird zone"
  const bpMix = Math.max(0, 1 - t*1.35);
  const notchMix = Math.max(0, 1 - Math.abs(t-0.52)*3.2);
  const hpMix = Math.max(0, (t-0.50)*2.4);

  // add a small chaotic tremble near mid/high
  const wob = (Math.sin(performance.now()*0.0022) * 0.5 + 0.5);
  const wobAmt = (t>0.45)? (t-0.45)*0.35*wob : 0;

  gBP.gain.setTargetAtTime(bpMix*(1-wobAmt), audioCtx.currentTime, 0.03);
  gNotch.gain.setTargetAtTime(notchMix + wobAmt*0.45, audioCtx.currentTime, 0.03);
  gHP.gain.setTargetAtTime(hpMix + wobAmt*0.30, audioCtx.currentTime, 0.03);

  // ringmod metallicness
  const ringHz = 6 + t*320 + wobAmt*120;
  ringOsc.frequency.setTargetAtTime(ringHz, audioCtx.currentTime, 0.03);
  ringGain.gain.setTargetAtTime(Math.min(0.95, t*0.95), audioCtx.currentTime, 0.03);

  // crusher
  const crushMix = crusherNode ? Math.pow(t, 1.15) : 0;
  dryMix.gain.setTargetAtTime(1 - crushMix*0.60, audioCtx.currentTime, 0.03);
  crusherMix.gain.setTargetAtTime(crushMix*0.90, audioCtx.currentTime, 0.03);

  if(crusherNode){
    const bitDepth = 16 - Math.floor(t*12);     // 16 -> 4
    const downSample = 1 + Math.floor(t*20);    // 1 -> 21
    crusherNode.parameters.get('bitDepth')?.setValueAtTime(bitDepth, audioCtx.currentTime);
    crusherNode.parameters.get('downSample')?.setValueAtTime(downSample, audioCtx.currentTime);
  }

  // stereo widen
  const w = (Math.sin(performance.now()*0.0016)*0.5+0.5);
  dL.delayTime.setTargetAtTime(0.002 + t*0.012 + w*0.0008, audioCtx.currentTime, 0.05);
  dR.delayTime.setTargetAtTime(0.006 + t*0.018 + (1-w)*0.0010, audioCtx.currentTime, 0.05);

  document.getElementById('txtFx').textContent =
    `touch:${t.toFixed(3)} | f:${f.toFixed(0)}Hz | ring:${ringHz.toFixed(1)}Hz | crush:${crushMix.toFixed(2)} | wob:${wobAmt.toFixed(2)}`;
}

/* ==========================================================
   UI / TOGGLES
========================================================== */
const ui = document.getElementById('ui');

function setUIVisible(v){
  ui.classList.toggle('hidden', !v);
  S.uiVisible = v ? 1 : 0;
  saveSettings(S);
}

function updateTopPill(){
  const pill=document.getElementById('topPill');
  const a = audioCtx ? audioCtx.state : 'off';
  const mic = micStream ? 'on' : 'off';
  const track = (trackReady && trackEl && !trackEl.paused) ? 'on' : (trackReady ? 'ready' : 'off');
  const midi = midiName.includes('MIDI:') ? midiName.replace('MIDI: ','') : '?';
  pill.textContent = `audio:${a} | mic:${mic} | track:${track} | midi:${midi}`;
}

document.getElementById('btnGear').addEventListener('click', ()=> setUIVisible(ui.classList.contains('hidden')));
document.getElementById('btnHideUI').addEventListener('click', ()=> setUIVisible(false));
setUIVisible((S.uiVisible ?? 0)===1);

document.getElementById('btnFS').addEventListener('click', toggleFullscreen);
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

document.getElementById('btnMuteQuick').addEventListener('click', ()=>{
  if(!audioCtx) return;
  isMuted = !isMuted;
  masterGain.gain.setTargetAtTime(isMuted?0:0.9, audioCtx.currentTime, 0.02);
  document.getElementById('btnMuteQuick').textContent = isMuted ? 'ğŸ”ˆ' : 'ğŸ”‡';
});

document.getElementById('btnResume').addEventListener('click', async ()=>{
  await ensureAudio();
  await audioCtx.resume();
  await listDevices();
  setStartButtons(!!micStream);
  updateTopPill();
});

/* ---- Start Audio (FIXED) ---- */
document.getElementById('btnStartAudio').addEventListener('click', async ()=>{
  try{
    await ensureAudio();
    await audioCtx.resume();
    await initMIDI();
    await listDevices();

    // enable mic + track controls
    document.getElementById('btnStartMic').disabled = false;
    document.getElementById('btnMicOn').disabled = false;
    updateTrackButtons();

    setStartButtons(!!micStream);
    updateTopPill();
    startStatus("Audio unlocked. Mic ON ë˜ëŠ” Track Load í›„ amp í™•ì¸!");
  }catch(e){
    console.error(e);
    startStatus("Start Audio ì‹¤íŒ¨. ì½˜ì†” ì—ëŸ¬ í™•ì¸!");
    alert("Start Audio ì‹¤íŒ¨. ê°œë°œìë„êµ¬ Console ì—ëŸ¬ í™•ì¸!");
  }
});

document.getElementById('btnStartMic').addEventListener('click', async ()=>{
  await startMic(currentMicDeviceId);
  document.getElementById('hint').style.display='none';
});

document.getElementById('btnStopMic').addEventListener('click', ()=> stopMic());
document.getElementById('btnMicOn').addEventListener('click', async ()=> startMic(currentMicDeviceId));
document.getElementById('btnMicOff').addEventListener('click', ()=> stopMic());

/* ---- route select ---- */
const selRoute = document.getElementById('selRoute');
applySelectValue('selRoute','both');
hookSelectSave('selRoute');
selRoute.addEventListener('change', ()=>{
  // rewire mic quickly
  if(micSrc){
    try{ micSrc.disconnect(); }catch(e){}
    const route = selRoute.value;
    if(route==="mic" || route==="both") micSrc.connect(preGain);
  }
});

/* ---- track UI ---- */
const fileTrack = document.getElementById('fileTrack');
const inpTrackUrl = document.getElementById('inpTrackUrl');
const btnLoadUrl = document.getElementById('btnLoadUrl');
const btnTrackPlay = document.getElementById('btnTrackPlay');
const btnTrackPause = document.getElementById('btnTrackPause');
const rngTrackVol = document.getElementById('rngTrackVol');
const selTrackLoop = document.getElementById('selTrackLoop');

applySelectValue('selTrackLoop','1');
rngTrackVol.value = (S.rngTrackVol ?? "0.75");
selTrackLoop.value = (S.selTrackLoop ?? "1");
hookSelectSave('selTrackLoop');

selTrackLoop.addEventListener('change', ()=>{
  S.selTrackLoop = selTrackLoop.value; saveSettings(S);
  ensureTrack();
  trackEl.loop = selTrackLoop.value === "1";
});

rngTrackVol.addEventListener('input', ()=>{
  S.rngTrackVol = rngTrackVol.value; saveSettings(S);
  if(trackGain) trackGain.gain.setTargetAtTime(parseFloat(rngTrackVol.value), audioCtx.currentTime, 0.03);
});

fileTrack.addEventListener('change', async ()=>{
  const f = fileTrack.files && fileTrack.files[0];
  if(!f) return;
  await loadTrackFromFile(f);

  // route option: connect track if allowed
  const route = selRoute.value;
  if(route==="track" || route==="both"){
    connectTrackGraph();
  }else{
    // mic-only: disconnect trackGain -> preGain
    if(trackGain){ try{ trackGain.disconnect(); }catch(e){} }
  }
});

btnLoadUrl.addEventListener('click', async ()=>{
  const url = (inpTrackUrl.value||"").trim();
  if(!url) return;
  S.inpTrackUrl = url; saveSettings(S);
  await loadTrackFromURL(url);

  const route = selRoute.value;
  if(route==="track" || route==="both"){
    connectTrackGraph();
  }else{
    if(trackGain){ try{ trackGain.disconnect(); }catch(e){} }
  }
});

btnTrackPlay.addEventListener('click', async ()=>{
  await ensureAudio();
  await audioCtx.resume();
  ensureTrack();
  connectTrackGraph();

  // route switch obey
  const route = selRoute.value;
  if(route==="track" || route==="both"){
    // ok
  }else{
    alert("Routeê°€ Mic onlyë¼ì„œ íŠ¸ë™ ì†Œë¦¬ê°€ FXë¡œ ì•ˆ ë“¤ì–´ê°€ìš”. Routeë¥¼ Track/Bothë¡œ ë°”ê¿”!");
    return;
  }

  try{
    await trackEl.play();
    updateTopPill();
    startStatus("Track playing.");
  }catch(e){
    alert("Track play ì‹¤íŒ¨(ê¶Œí•œ/ì½”ë±/CORS). Start Audio í›„ ë‹¤ì‹œ ì‹œë„!");
  }
});

btnTrackPause.addEventListener('click', ()=>{
  if(trackEl) trackEl.pause();
  updateTopPill();
});

/* ==========================================================
   VISUAL: 3D red dots ALWAYS present + stable linking
========================================================== */
let N = 220;
let pts=[];
let rot=0;

// quiet: ì›…ì¶• + ì‘ì€ ì  (but always present)
const BASE_ALPHA = 0.24;
const BASE_RADIUS = 1.2;
const ACTIVE_RADIUS_GAIN = 3.0;

const ACTIVE_TH = 0.020;
const QUIET_TH  = 0.010;
const ONSET_TH  = 0.020;
let energy = 0;
let burstEnergy = 0;

const pr = []; // {x,y,k,z}
function initPoints(){
  pts=[];
  for(let i=0;i<N;i++){
    pts.push({
      x:(Math.random()*2-1)*(W*0.34),
      y:(Math.random()*2-1)*(H*0.34),
      z:(Math.random()*2-1)*360,
      vx:0,vy:0,vz:0
    });
  }
  pr.length = N;
  for(let i=0;i<N;i++) pr[i] = {x:0,y:0,k:1,z:0};
}
initPoints();

function projectInto(i){
  const p=pts[i];
  const s=Math.sin(rot), c=Math.cos(rot);
  const x = p.x*c - p.z*s;
  const z = p.x*s + p.z*c;
  const depth = 900;
  const k = depth/(depth+z);
  pr[i].x = x*k + W/2;
  pr[i].y = p.y*k + H/2;
  pr[i].k = k;
  pr[i].z = z;
}

function applyBounds(p, mode){
  if(mode==="wrap"){
    const maxX=W*0.65, maxY=H*0.65, maxZ=600;
    if(p.x> maxX) p.x=-maxX;
    if(p.x<-maxX) p.x= maxX;
    if(p.y> maxY) p.y=-maxY;
    if(p.y<-maxY) p.y= maxY;
    if(p.z> maxZ) p.z=-maxZ;
    if(p.z<-maxZ) p.z= maxZ;
    return;
  }
  const maxX=W*0.58, maxY=H*0.58, maxZ=600;
  if(mode==="bounce"){
    if(p.x> maxX){ p.x=maxX; p.vx*=-0.7; }
    if(p.x<-maxX){ p.x=-maxX; p.vx*=-0.7; }
    if(p.y> maxY){ p.y=maxY; p.vy*=-0.7; }
    if(p.y<-maxY){ p.y=-maxY; p.vy*=-0.7; }
    if(p.z> maxZ){ p.z=maxZ; p.vz*=-0.7; }
    if(p.z<-maxZ){ p.z=-maxZ; p.vz*=-0.7; }
    return;
  }
  const pull=0.0026;
  const edgeX=Math.max(0, Math.abs(p.x)-maxX);
  const edgeY=Math.max(0, Math.abs(p.y)-maxY);
  const edgeZ=Math.max(0, Math.abs(p.z)-maxZ);
  if(edgeX>0) p.vx += (-Math.sign(p.x))*edgeX*pull;
  if(edgeY>0) p.vy += (-Math.sign(p.y))*edgeY*pull;
  if(edgeZ>0) p.vz += (-Math.sign(p.z))*edgeZ*pull;
}

/* ---- Spatial hash for links (fix lag) ---- */
const grid = new Map();
function cellKey(cx,cy){ return (cx<<16) ^ (cy & 0xffff); }
function buildGrid(cellSize){
  grid.clear();
  const inv = 1/cellSize;
  for(let i=0;i<N;i++){
    const x = pr[i].x, y = pr[i].y;
    const cx = (x*inv)|0;
    const cy = (y*inv)|0;
    const k = cellKey(cx,cy);
    let arr = grid.get(k);
    if(!arr){ arr=[]; grid.set(k,arr); }
    arr.push(i);
  }
}

function drawLinks(linkDist, maxLinksPerPoint){
  const LD = Math.min(linkDist, 210);
  const cellSize = Math.max(30, LD);
  buildGrid(cellSize);

  const inv = 1/cellSize;
  const LD2 = LD*LD;

  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(255,40,40,0.85)";

  // global cap (strong anti-freeze)
  const GLOBAL_MAX_LINES = Math.min(2600, N*maxLinksPerPoint*2);
  let lines = 0;

  for(let i=0;i<N;i++){
    let links = 0;
    const ax = pr[i].x, ay = pr[i].y;
    const cx = (ax*inv)|0, cy = (ay*inv)|0;

    for(let oy=-1; oy<=1; oy++){
      for(let ox=-1; ox<=1; ox++){
        const k = cellKey(cx+ox, cy+oy);
        const arr = grid.get(k);
        if(!arr) continue;

        for(let idx=0; idx<arr.length; idx++){
          const j = arr[idx];
          if(j<=i) continue;
          const bx = pr[j].x, by = pr[j].y;
          const dx = ax-bx, dy = ay-by;
          const d2 = dx*dx + dy*dy;

          if(d2 < LD2){
            const alpha = 1 - (d2/LD2); // no sqrt
            ctx.globalAlpha = alpha * 0.9;

            ctx.beginPath();
            ctx.moveTo(ax,ay);
            ctx.lineTo(bx,by);
            ctx.stroke();

            links++; lines++;
            if(links >= maxLinksPerPoint) { oy=2; break; }
            if(lines >= GLOBAL_MAX_LINES){ ctx.globalAlpha=1; return; }
          }
        }
      }
    }
  }
  ctx.globalAlpha = 1;
}

document.getElementById('selN').addEventListener('change', (e)=>{
  N = parseInt(e.target.value,10);
  initPoints();
});

/* ==========================================================
   MAIN LOOP
========================================================== */
function loop(){
  ctx.fillStyle = "rgba(0,0,0,0.13)";
  ctx.fillRect(0,0,W,H);

  if(audioCtx) updateAmp();
  updateTouch();
  if(audioCtx) applyFX();

  const inPct = Math.max(0, Math.min(1, amp*6.0));
  document.getElementById('meterIn').style.width = (inPct*100).toFixed(1)+"%";
  document.getElementById('txtAmp').textContent = `amp: ${amp.toFixed(4)} | dAmp: ${ampDelta.toFixed(4)}`;
  document.getElementById('meterTouch').style.width = (touchSmooth*100).toFixed(1)+"%";

  const targetEnergy = (amp>ACTIVE_TH) ? 1 : (amp<QUIET_TH ? 0 : energy);
  energy += (targetEnergy-energy)*0.05;

  const onset = Math.max(0, ampDelta - ONSET_TH);
  burstEnergy += (onset*6.0 - burstEnergy)*0.12;
  burstEnergy *= 0.92;

  // quiet: ì›…ì¶•(ë” ê°•í•œ center pull) + ëŠë¦° drift
  const quietPull = 0.014;
  const activePull = 0.004;
  const centerPull = quietPull*(1-energy) + activePull*energy;

  const baseSpeed = 0.08 + energy*(0.18 + amp*3.0) + burstEnergy*0.08;
  const chaos = 0.6 + energy*((ampDelta*120) + touchSmooth*55 + burstEnergy*120);

  const t = performance.now()*0.001;
  const rotSpeed = 0.0011 + energy*0.010 + burstEnergy*0.008;
  rot += rotSpeed;

  // quiet slightly shrink, active breathe
  const breathe = 0.5 + 0.5*Math.sin(t*1.3);
  const scaleQuiet = 0.90;
  const scaleActive = 1.0 + (breathe-0.5)*0.22;
  const scale = scaleQuiet*(1-energy) + scaleActive*energy;

  const boundsMode = document.getElementById('selBounds').value;
  for(const p of pts){
    p.vx += (Math.random()-0.5)*chaos;
    p.vy += (Math.random()-0.5)*chaos;
    p.vz += (Math.random()-0.5)*chaos*0.55;

    // always pull to center (quiet stronger)
    p.vx += (-p.x)*centerPull;
    p.vy += (-p.y)*centerPull;
    p.vz += (-p.z)*centerPull*0.6;

    // active spread outward
    const spread = energy*(amp*0.020 + ampDelta*0.060 + touchSmooth*0.014 + burstEnergy*0.030);
    p.vx += p.x*spread;
    p.vy += p.y*spread;
    p.vz += p.z*spread*0.6;

    p.vx *= 0.90 - energy*0.05;
    p.vy *= 0.90 - energy*0.05;
    p.vz *= 0.92 - energy*0.04;

    p.x = (p.x + p.vx*baseSpeed) * scale + (1-scale)*p.x;
    p.y = (p.y + p.vy*baseSpeed) * scale + (1-scale)*p.y;
    p.z = (p.z + p.vz*baseSpeed) * (0.92 + 0.08*scale) + (1-(0.92 + 0.08*scale))*p.z;

    applyBounds(p, boundsMode);
  }

  for(let i=0;i<N;i++) projectInto(i);

  const linkMode = document.getElementById('selLink').value;
  const maxLinksPerPoint = (linkMode==="low") ? 4 : (linkMode==="mid" ? 7 : 10);

  // distance capped
  const linkDist = 40 + energy*(66 + amp*210 + touchSmooth*250 + burstEnergy*120);
  if(energy > 0.06) drawLinks(linkDist, maxLinksPerPoint);

  // points ALWAYS visible, RED
  for(let i=0;i<N;i++){
    const p = pr[i];
    const depthK = 0.8 + p.k*0.9;

    const rQuiet = BASE_RADIUS * depthK;
    const rActive = (BASE_RADIUS + ACTIVE_RADIUS_GAIN + amp*2.6 + touchSmooth*1.4 + burstEnergy*1.0) * depthK;
    const r = rQuiet*(1-energy) + rActive*energy;

    const aQuiet = BASE_ALPHA;
    const aActive = Math.min(1, 0.30 + amp*1.15 + touchSmooth*0.60 + burstEnergy*0.70);
    const a = aQuiet*(1-energy) + aActive*energy;

    ctx.globalAlpha = a;
    ctx.fillStyle = "rgba(255,60,60,1)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  updateTopPill();
  requestAnimationFrame(loop);
}
loop();

/* ==========================================================
   START SAFETY (audio resume on pointer)
========================================================== */
addEventListener('pointerdown', async ()=>{
  if(audioCtx && audioCtx.state==='suspended'){
    await audioCtx.resume();
    updateTopPill();
  }
},{passive:true});

/* ==========================================================
   TABS + RESTORE
========================================================== */
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    document.getElementById('panel-'+t.dataset.tab).classList.add('active');
    S.activeTab = t.dataset.tab;
    saveSettings(S);
  });
});
if(S.activeTab){
  const tabEl = document.querySelector(`.tab[data-tab="${S.activeTab}"]`);
  if(tabEl) tabEl.click();
}

applySelectValue('selN','220');
applySelectValue('selBounds','soft');
applySelectValue('selLink','mid');
['selN','selBounds','selLink'].forEach(hookSelectSave);

N = parseInt(document.getElementById('selN').value,10);
initPoints();

startStatus("Start Audioë¥¼ ë¨¼ì € ëˆ„ë¥´ê³  ì§„í–‰!");
updateTopPill();
</script>
</body>
</html>
