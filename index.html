<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport"
        content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
  <title>SLEEEEEEEP – PIXEL MAZE</title>

  <!-- 픽셀 게임 폰트 -->
  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SLEEP">
  <meta name="theme-color" content="#000000">

  <style>
    :root{
      --appH: 100svh;
      --frame: clamp(16px, 4vmin, 40px);
    }

    *{
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body{
      width: 100%;
      height: 100%;
      background: #000;
      color: #f5f5f5;
      font-family: "Press Start 2P", system-ui, sans-serif;
      overscroll-behavior: none;
      -webkit-font-smoothing: none;
      image-rendering: pixelated;
      touch-action: none;
    }

    body{
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--frame);
    }

    /* 화면 중앙의 플랫 직사각 프레임 */
    #frame{
      width: min(100vw - 2*var(--frame), 1100px);
      height: min(var(--appH) - 2*var(--frame), 700px);
      max-width: 1100px;
      max-height: 700px;

      border: 2px solid #777;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 내부 게임 창(네모 박스 안의 네모 박스 느낌) */
    #game-wrapper{
      width: 90%;
      max-width: 900px;
      aspect-ratio: 4 / 3;
      border: 1px solid #555;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #game-canvas{
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      touch-action: none;
      background: #000;
    }
  </style>
</head>
<body>
  <div id="frame">
    <div id="game-wrapper">
      <canvas id="game-canvas" width="320" height="240"></canvas>
    </div>
  </div>

<script>
/* =========================
   기본 상태
   ========================= */
const canvas = document.getElementById('game-canvas');
const ctx    = canvas.getContext('2d');

const WIDTH  = canvas.width;
const HEIGHT = canvas.height;

let lastTime = 0;

const STATE = {
  mode: 'maze',        // 'maze' | 'mission'
  player: {x: 0, y: 0},
  pointer: {x:0,y:0,down:false},
  currentGame: null,
  activeEndingKey: null,   // 'A','B',...
  activeEndingSymbol: null,// 'a','b',...
  activeMissionIndex: 0,
  endingProgress: {},      // 'A' -> index
  items: {},               // itemId -> {name, description}
};

/* =========================
   공통 유틸 (지금은 시각 출력 X)
   ========================= */
function setMessage(text){
  // 필요하면 콘솔에서만 확인
  // console.log(text);
}
function setDefaultControlMessage(){
  setMessage("조작법: 화면 위/아래/좌/우 영역을 탭해서 이동.");
}
function setChapterLabel(text){
  // 시각적 챕터 라벨 없음, 내부용
}

function getCanvasPos(evt){
  const rect = canvas.getBoundingClientRect();
  const cx = (evt.touches ? evt.touches[0].clientX : evt.clientX) - rect.left;
  const cy = (evt.touches ? evt.touches[0].clientY : evt.clientY) - rect.top;
  const x = cx * (canvas.width / rect.width);
  const y = cy * (canvas.height / rect.height);
  return {x, y};
}

function drawRedRabbit(x, y){
  const s = 8;
  ctx.fillStyle = '#ff3333';
  ctx.fillRect(x+2, y+1, s*4/8, s*3/8);
  ctx.fillRect(x+1, y-1, s*1/8, s*3/8);
  ctx.fillRect(x+4, y-1, s*1/8, s*3/8);
  ctx.fillRect(x+2, y+4, s*4/8, s*3/8);
  ctx.fillRect(x+6, y+4, s*2/8, s*2/8);
}

/* =========================
   미니게임 베이스
   ========================= */
class MiniGame {
  constructor(name, description){
    this.name = name;
    this.description = description;
    this.isDone = false;
    this.timer = 0;
  }
  init(){
    this.isDone = false;
    this.timer = 0;
    setMessage(this.description);
  }
  update(dt){
    this.timer += dt;
  }
  draw(ctx){}
  pointerDown(x,y){}
  pointerUp(x,y){}
}

/* =========================
   미니게임 구현들
   ========================= */

class WaveGame extends MiniGame {
  constructor(){
    super("정지한 파형", "파형이 거의 평평해지는 순간을 탭하세요.");
    this.t = 0;
  }
  init(){
    super.init();
    this.t = 0;
  }
  update(dt){
    super.update(dt);
    this.t += dt;
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const midY = HEIGHT/2;
    ctx.strokeStyle = "#f5f5f5";
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(0, midY);
    const baseAmp = 20;
    let amp = baseAmp * (0.3 + 0.7*Math.abs(Math.sin(this.t*0.5)));
    const phase = this.t * 0.5;
    if(Math.abs(Math.sin(phase*1.2)) < 0.2){
      amp = 2;
    }

    for(let x=0; x<WIDTH; x++){
      const t = (x/40) + phase;
      const y = midY + Math.sin(t)*amp;
      ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = "#777";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText("TAP WHEN FLAT", 6, 12);
  }
  pointerDown(){
    const phase = this.t * 0.5;
    const flatScore = Math.abs(Math.sin(phase*1.2));
    if(flatScore < 0.15){
      setMessage(`평평한 순간을 포착했습니다. (정확도: ${((1-flatScore)*100).toFixed(1)}%)`);
      this.isDone = true;
    }else{
      setMessage("조금 어긋났습니다. 다시 시도해보세요.");
    }
  }
}

class FadingPixelGame extends MiniGame {
  constructor(){
    super("사라지는 픽셀", "서서히 어두워지는 픽셀을 찾아 탭하세요.");
    this.gridSize = 5;
    this.specialIndex = 0;
    this.startTime = 0;
    this.found = false;
  }
  init(){
    super.init();
    this.gridSize = Math.random() < 0.5 ? 4 : 5;
    this.specialIndex = Math.floor(Math.random()*this.gridSize*this.gridSize);
    this.startTime = performance.now();
    this.found = false;
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const padding = 40;
    const size = Math.min(WIDTH, HEIGHT) - padding*2;
    const cell = size / this.gridSize;
    const offsetX = (WIDTH - size)/2;
    const offsetY = (HEIGHT - size)/2;

    const elapsed = (performance.now() - this.startTime)/1000;
    const darkFactor = Math.min(elapsed/3, 1);

    for(let i=0;i<this.gridSize*this.gridSize;i++){
      const gx = i % this.gridSize;
      const gy = Math.floor(i/this.gridSize);
      const x = offsetX + gx*cell;
      const y = offsetY + gy*cell;

      if(i === this.specialIndex){
        const v = 220 - darkFactor*140;
        ctx.fillStyle = `rgb(${v},${v},${v})`;
      }else{
        ctx.fillStyle = "#e0e0e0";
      }
      ctx.fillRect(x+2,y+2,cell-4,cell-4);
    }

    ctx.strokeStyle = "#555";
    ctx.strokeRect(offsetX-4, offsetY-4, size+8, size+8);
  }
  pointerDown(x,y){
    if(this.found) return;
    const padding = 40;
    const size = Math.min(WIDTH, HEIGHT) - padding*2;
    const cell = size / this.gridSize;
    const offsetX = (WIDTH - size)/2;
    const offsetY = (HEIGHT - size)/2;

    const gx = Math.floor((x - offsetX) / cell);
    const gy = Math.floor((y - offsetY) / cell);
    if(gx<0||gy<0||gx>=this.gridSize||gy>=this.gridSize) return;

    const idx = gy*this.gridSize + gx;
    const elapsed = (performance.now() - this.startTime)/1000;

    if(idx === this.specialIndex){
      this.found = true;
      this.isDone = true;
      setMessage(`변화를 ${elapsed.toFixed(2)}초 만에 발견했습니다.`);
    }else{
      setMessage("다른 픽셀입니다. 다시 시도해보세요.");
    }
  }
}

class OverlapGame extends MiniGame {
  constructor(){
    super("겹치는 곳", "두 도형이 정확히 겹쳐질 때를 탭하세요.");
    this.t = 0;
  }
  init(){
    super.init();
    this.t = 0;
  }
  update(dt){
    super.update(dt);
    this.t += dt;
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const centerY = HEIGHT/2;
    const size = 40;

    const progress = (Math.sin(this.t*0.3) + 1)/2;
    const leftX  = WIDTH*0.1 + progress*WIDTH*0.3;
    const rightX = WIDTH*0.9 - progress*WIDTH*0.3;

    ctx.lineWidth = 2;

    ctx.strokeStyle = "#f5f5f5";
    ctx.beginPath();
    ctx.moveTo(leftX, centerY - size/2);
    ctx.lineTo(leftX - size/2, centerY + size/2);
    ctx.lineTo(leftX + size/2, centerY + size/2);
    ctx.closePath();
    ctx.stroke();

    ctx.fillStyle = "#d0d0d0";
    ctx.beginPath();
    ctx.moveTo(rightX, centerY - size/2);
    ctx.lineTo(rightX - size/2, centerY + size/2);
    ctx.lineTo(rightX + size/2, centerY + size/2);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#777";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("TAP WHEN THEY OVERLAP", WIDTH/2, 20);
  }
  pointerDown(){
    const progress = (Math.sin(this.t*0.3) + 1)/2;
    const leftX  = WIDTH*0.1 + progress*WIDTH*0.3;
    const rightX = WIDTH*0.9 - progress*WIDTH*0.3;
    const dist = Math.abs(leftX - rightX);
    if(dist < 10){
      this.isDone = true;
      setMessage("겹치는 순간을 포착했습니다.");
    }else{
      setMessage("조금 어긋났습니다. 다시 시도해보세요.");
    }
  }
}

class FallingPixelsGame extends MiniGame {
  constructor(){
    super("떨어지는 픽셀", "떨어지는 흰 픽셀만 15개 이상 탭하세요.");
    this.pixels = [];
    this.spawnTimer = 0;
    this.collected = 0;
  }
  init(){
    super.init();
    this.pixels = [];
    this.spawnTimer = 0;
    this.collected = 0;
  }
  spawnPixel(){
    this.pixels.push({
      x: Math.random()*WIDTH,
      y: -10,
      vy: 30 + Math.random()*40,
      type: Math.random()<0.6 ? "white" : "gray",
      dead: false
    });
  }
  update(dt){
    super.update(dt);
    this.spawnTimer += dt;
    if(this.spawnTimer > 0.4){
      this.spawnTimer = 0;
      this.spawnPixel();
    }
    for(const p of this.pixels){
      p.y += p.vy*dt;
      if(p.y > HEIGHT+10) p.dead = true;
    }
    this.pixels = this.pixels.filter(p=>!p.dead);
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    for(const p of this.pixels){
      ctx.fillStyle = p.type==="white" ? "#ffffff" : "#777777";
      ctx.fillRect(p.x-3,p.y-3,6,6);
    }

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText(`WHITE: ${this.collected}/15`, 6, 14);
  }
  pointerDown(x,y){
    for(const p of this.pixels){
      const dx = p.x - x;
      const dy = p.y - y;
      if(Math.sqrt(dx*dx+dy*dy) < 10){
        if(p.type==="white"){
          this.collected++;
          p.dead = true;
          setMessage(`흰 픽셀을 포착했습니다. (${this.collected}/15)`);
          if(this.collected>=15){
            this.isDone = true;
            setMessage("충분한 픽셀을 포착했습니다.");
          }
        }else{
          setMessage("회색 픽셀입니다. 피부가 더 하얘지는 건 아닙니다.");
          this.collected = Math.max(0, this.collected-1);
        }
        break;
      }
    }
  }
}

class BlinkPixelsGame extends MiniGame {
  constructor(){
    super("픽셀 포착", "반짝이는 흰 픽셀을 예측해서 탭하세요.");
    this.points = [];
    this.success = 0;
    this.total = 0;
  }
  init(){
    super.init();
    this.points = [];
    this.success = 0;
    this.total = 0;
    for(let i=0;i<8;i++){
      this.points.push({
        x: 40 + Math.random()*(WIDTH-80),
        y: 40 + Math.random()*(HEIGHT-80),
        phase: Math.random()*Math.PI*2
      });
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const t = this.timer;

    for(const p of this.points){
      const wave = (Math.sin(t*4 + p.phase)+1)/2;
      const visible = wave>0.7;
      if(visible){
        const size = 5 + wave*4;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(p.x-size/2, p.y-size/2, size, size);
      }
    }

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    const rate = this.total>0 ? Math.round(this.success/this.total*100) : 0;
    ctx.fillText(`HIT: ${this.success}/${this.total} (${rate}%)`, 6, 14);
  }
  pointerDown(x,y){
    const t = this.timer;
    this.total++;
    let hit = false;
    for(const p of this.points){
      const wave = (Math.sin(t*4 + p.phase)+1)/2;
      const visible = wave>0.7;
      const dx = p.x - x;
      const dy = p.y - y;
      if(visible && Math.sqrt(dx*dx+dy*dy)<10){
        this.success++;
        hit = true;
        break;
      }
    }
    if(hit){
      setMessage("반짝이는 순간을 포착했습니다.");
    }else{
      setMessage("픽셀이 이미 사라졌습니다.");
    }
    if(this.success>=5){
      this.isDone = true;
      setMessage(`예측 성공률 ${(this.success/this.total*100).toFixed(1)}%`);
    }
  }
}

class StackGame extends MiniGame {
  constructor(){
    super("픽셀 쌓기", "떨어지는 블록들이 화면 절반 높이까지 쌓이도록 해보세요.");
    this.cols = 10;
    this.rows = 16;
    this.grid = [];
    this.current = null;
    this.dropTimer = 0;
    this.dropInterval = 0.5;
  }
  init(){
    super.init();
    this.grid = Array(this.rows).fill(0).map(()=>Array(this.cols).fill(0));
    this.spawnBlock();
    this.dropTimer = 0;
  }
  spawnBlock(){
    const shapes = [
      [[1,1,1,1]],
      [[1,1],[1,1]],
      [[1,1,0],[0,1,1]]
    ];
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    this.current = {
      shape,
      x: Math.floor(this.cols/2)-1,
      y: 0
    };
  }
  canMove(dx,dy){
    const s = this.current.shape;
    for(let r=0;r<s.length;r++){
      for(let c=0;c<s[0].length;c++){
        if(!s[r][c]) continue;
        const nx = this.current.x + c + dx;
        const ny = this.current.y + r + dy;
        if(nx<0||nx>=this.cols||ny<0||ny>=this.rows) return false;
        if(this.grid[ny][nx]) return false;
      }
    }
    return true;
  }
  lockBlock(){
    const s = this.current.shape;
    for(let r=0;r<s.length;r++){
      for(let c=0;c<s[0].length;c++){
        if(!s[r][c]) continue;
        const gx = this.current.x + c;
        const gy = this.current.y + r;
        if(gy>=0 && gy<this.rows) this.grid[gy][gx] = 1;
      }
    }
    this.current = null;
    this.spawnBlock();
  }
  update(dt){
    super.update(dt);
    this.dropTimer += dt;
    if(this.dropTimer>=this.dropInterval){
      this.dropTimer = 0;
      if(this.canMove(0,1)){
        this.current.y++;
      }else{
        this.lockBlock();
      }
    }

    let maxRow = 0;
    for(let r=0;r<this.rows;r++){
      if(this.grid[r].some(c=>c)) maxRow = this.rows-r;
    }
    if(maxRow >= this.rows/2){
      this.isDone = true;
      setMessage("충분히 쌓였습니다.");
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const cell = 12;
    const gridWidth = this.cols*cell;
    const gridHeight = this.rows*cell;
    const offsetX = (WIDTH - gridWidth)/2;
    const offsetY = (HEIGHT - gridHeight)/2;

    for(let r=0;r<this.rows;r++){
      for(let c=0;c<this.cols;c++){
        if(this.grid[r][c]){
          ctx.fillStyle = "#888";
          ctx.fillRect(offsetX+c*cell+1, offsetY+r*cell+1, cell-2, cell-2);
        }
      }
    }

    if(this.current){
      ctx.fillStyle = "#e0e0e0";
      const s = this.current.shape;
      for(let r=0;r<s.length;r++){
        for(let c=0;c<s[0].length;c++){
          if(!s[r][c]) continue;
          const gx = this.current.x + c;
          const gy = this.current.y + r;
          ctx.fillRect(offsetX+gx*cell+1, offsetY+gy*cell+1, cell-2, cell-2);
        }
      }
    }

    ctx.strokeStyle = "#555";
    ctx.strokeRect(offsetX-1, offsetY-1, gridWidth+2, gridHeight+2);
  }
  pointerDown(x,y){
    const left = x < WIDTH/2;
    if(left){
      if(this.canMove(-1,0)) this.current.x--;
    }else{
      if(this.canMove(1,0)) this.current.x++;
    }
  }
}

class LinkPixelsGame extends MiniGame {
  constructor(){
    super("연결된 픽셀", "같은 리듬으로 깜박이는 픽셀들을 이어보세요.");
    this.nodes = [];
    this.selected = null;
  }
  init(){
    super.init();
    this.nodes = [];
    const patterns = [0.8, 1.1, 1.5];
    for(let i=0;i<9;i++){
      this.nodes.push({
        x: 40 + Math.random()*(WIDTH-80),
        y: 40 + Math.random()*(HEIGHT-80),
        pattern: patterns[i%patterns.length],
        links: []
      });
    }
    this.selected = null;
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const t = this.timer;

    ctx.strokeStyle = "#777";
    ctx.lineWidth = 1;
    for(const n of this.nodes){
      for(const other of n.links){
        ctx.beginPath();
        ctx.moveTo(n.x, n.y);
        ctx.lineTo(other.x, other.y);
        ctx.stroke();
      }
    }

    for(const n of this.nodes){
      const wave = (Math.sin(t*4/n.pattern)+1)/2;
      const bright = wave>0.7;
      ctx.fillStyle = bright ? "#ffffff" : "#888888";
      ctx.beginPath();
      ctx.arc(n.x,n.y,6,0,Math.PI*2);
      ctx.fill();

      if(this.selected === n){
        ctx.strokeStyle = "#ff3333";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(n.x,n.y,9,0,Math.PI*2);
        ctx.stroke();
      }
    }

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText("SAME RHYTHM = LINK", 6, 14);
  }
  pointerDown(x,y){
    let hit = null;
    for(const n of this.nodes){
      const dx = n.x - x;
      const dy = n.y - y;
      if(Math.sqrt(dx*dx+dy*dy)<8){
        hit = n;
        break;
      }
    }
    if(!hit) return;

    if(!this.selected){
      this.selected = hit;
      setMessage("같은 리듬의 픽셀을 찾아 이어보세요.");
    }else{
      if(this.selected === hit) return;
      if(this.selected.pattern === hit.pattern){
        if(!this.selected.links.includes(hit)){
          this.selected.links.push(hit);
        }
        if(!hit.links.includes(this.selected)){
          hit.links.push(this.selected);
        }
        setMessage("연결되었습니다.");
      }else{
        setMessage("리듬이 다릅니다.");
      }
      this.selected = null;
    }

    let allLinked = true;
    for(const p of [0.8,1.1,1.5]){
      const group = this.nodes.filter(n=>n.pattern===p);
      const linkedCount = group.filter(n=>n.links.some(o=>o.pattern===p)).length;
      if(linkedCount < group.length){
        allLinked = false;
        break;
      }
    }
    if(allLinked){
      this.isDone = true;
      setMessage("연결된 리듬들이 하나의 지형이 되었습니다.");
    }
  }
}

class ClockArrowsGame extends MiniGame {
  constructor(){
    super("시계방향 시곗바늘", "모든 시곗바늘을 같은 방향으로 고정해보세요.");
    this.grid = [];
  }
  init(){
    super.init();
    this.grid = [];
    const size = 5;
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        this.grid.push({
          x, y,
          angle: Math.floor(Math.random()*4)*Math.PI/2,
          locked: false
        });
      }
    }
  }
  update(dt){
    super.update(dt);
    for(const a of this.grid){
      if(!a.locked){
        a.angle += dt*0.5;
      }
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const size = 5;
    const cell = 28;
    const gridWidth = size*cell;
    const offsetX = (WIDTH-gridWidth)/2;
    const offsetY = (HEIGHT-gridWidth)/2;

    for(const a of this.grid){
      const cx = offsetX + a.x*cell + cell/2;
      const cy = offsetY + a.y*cell + cell/2;
      const len = 10;
      const ax = cx + Math.cos(a.angle)*len;
      const ay = cy + Math.sin(a.angle)*len;

      ctx.strokeStyle = a.locked ? "#ffffff" : "#888888";
      ctx.lineWidth = a.locked?2:1;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(ax,ay);
      ctx.stroke();
    }

    ctx.strokeStyle = "#555";
    ctx.strokeRect(offsetX-2,offsetY-2,gridWidth+4,gridWidth+4);

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("TAP TO LOCK", WIDTH/2, 16);
  }
  pointerDown(x,y){
    const size = 5;
    const cell = 28;
    const gridWidth = size*cell;
    const offsetX = (WIDTH-gridWidth)/2;
    const offsetY = (HEIGHT-gridWidth)/2;

    for(const a of this.grid){
      const cx = offsetX + a.x*cell + cell/2;
      const cy = offsetY + a.y*cell + cell/2;
      if(Math.abs(x-cx)<cell/2 && Math.abs(y-cy)<cell/2){
        if(!a.locked){
          const dir = Math.round(a.angle/(Math.PI/2))%(4);
          a.angle = dir*(Math.PI/2);
          a.locked = true;
        }else{
          a.locked = false;
        }
        break;
      }
    }

    const allLocked = this.grid.every(a=>a.locked);
    if(allLocked){
      const first = this.grid[0].angle;
      const allSame = this.grid.every(a=>Math.abs(a.angle-first)<0.01);
      if(allSame){
        this.isDone = true;
        setMessage("모든 시곗바늘이 같은 시간을 가리킵니다.");
      }else{
        setMessage("아직 각도가 제각각입니다.");
      }
    }
  }
}

class PathGame extends MiniGame {
  constructor(){
    super("돌아가는 길", "한 번 탭, 두 번 탭, 길게 눌러 다른 점프를 만들어보세요.");
    this.rabbitX = 40;
    this.rabbitY = HEIGHT-40;
    this.vy = 0;
    this.platforms = [];
    this.goal = {x: WIDTH-40, y: HEIGHT-80};
    this.grounded = false;
    this.lastTapTime = 0;
    this.holdStart = null;
  }
  init(){
    super.init();
    this.rabbitX = 40;
    this.rabbitY = HEIGHT-40;
    this.vy = 0;
    this.platforms = [
      {x:60,y:HEIGHT-40,w:80},
      {x:160,y:HEIGHT-80,w:80},
      {x:240,y:HEIGHT-120,w:80},
    ];
    this.grounded = true;
    this.lastTapTime = 0;
    this.holdStart = null;
  }
  update(dt){
    super.update(dt);
    this.vy += 200*dt;
    this.rabbitY += this.vy*dt;

    this.grounded = false;
    for(const p of this.platforms){
      if(this.rabbitX>p.x && this.rabbitX<p.x+p.w){
        if(this.rabbitY>=p.y-8 && this.rabbitY<=p.y+4 && this.vy>0){
          this.rabbitY = p.y-8;
          this.vy = 0;
          this.grounded = true;
        }
      }
    }
    if(this.rabbitY>HEIGHT-16){
      this.rabbitY = HEIGHT-16;
      this.vy = 0;
      this.grounded = true;
    }

    const dx = this.rabbitX - this.goal.x;
    const dy = this.rabbitY - this.goal.y;
    if(Math.sqrt(dx*dx+dy*dy)<12){
      this.isDone = true;
      setMessage("토끼가 구멍 속으로 사라집니다.");
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    ctx.fillStyle = "#555";
    for(const p of this.platforms){
      ctx.fillRect(p.x, p.y, p.w, 4);
    }

    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(this.goal.x,this.goal.y+4,10,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "#777";
    ctx.stroke();

    drawRedRabbit(this.rabbitX-4, this.rabbitY-8);

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("TAP / DOUBLE TAP / HOLD", WIDTH/2, 16);
  }
  pointerDown(x,y){
    const now = performance.now();
    if(now - this.lastTapTime < 250){
      if(this.grounded){
        this.vy = -220;
        setMessage("두 번 점프! 더 멀리 날아갑니다.");
      }
    }else{
      this.holdStart = now;
      if(this.grounded){
        this.vy = -150;
        setMessage("작은 점프.");
      }
    }
    this.lastTapTime = now;
  }
  pointerUp(){
    if(this.holdStart){
      const dur = performance.now()-this.holdStart;
      if(dur>400 && this.grounded){
        this.vy = -280;
        setMessage("길게 눌러 높은 점프!");
      }
      this.holdStart = null;
    }
  }
}

/* =========================
   미션 클래스 매핑
   ========================= */
const MISSION_CLASSES = {
  WaveGame,
  FadingPixelGame,
  OverlapGame,
  FallingPixelsGame,
  BlinkPixelsGame,
  StackGame,
  LinkPixelsGame,
  ClockArrowsGame,
  PathGame,
};

/* =========================
   미로 & 엔딩 정의
   ========================= */

const MAZE_RAW = [
  "###############",
  "#S           #",
  "# # # # # # #",
  "#           #",
  "# # # # # # #",
  "#   a   b   #",
  "# # # # # # #",
  "#   c   d   #",
  "# # # # # # #",
  "#     e     #",
  "###############"
];

const MAZE = (() => {
  const width = MAZE_RAW[0].length;
  return MAZE_RAW.map(row => row.padEnd(width, "#"));
})();
const MAZE_H = MAZE.length;
const MAZE_W = MAZE[0].length;

const ENDINGS = {
  'a': {
    key: 'A',
    name: '급식실 산재 노동자',
    chapter: 'CH1',
    itemId: 'item_waveRecorder',
    itemName: '파형 기록기',
    itemDesc: '정지한 파형의 순간을 기록하는 장치.',
    missions: ['WaveGame', 'FadingPixelGame'],
    text: '급식실의 소음 사이, 잠깐 평평해진 순간이 저장되었습니다.'
  },
  'b': {
    key: 'B',
    name: '카메룬 내전 난민',
    chapter: 'CH1',
    itemId: 'item_overlapMap',
    itemName: '겹치는 지도',
    itemDesc: '겹쳐진 경계가 드러나는 지도.',
    missions: ['OverlapGame'],
    text: '길이 겹칠 때만 보이던 경계선이 손에 쥐어졌습니다.'
  },
  'c': {
    key: 'C',
    name: '인도 표백 노동자',
    chapter: 'CH2',
    itemId: 'item_bleachGloves',
    itemName: '표백 장갑',
    itemDesc: '얼룩이 지워지지 않는 하얀 장갑.',
    missions: ['FallingPixelsGame', 'BlinkPixelsGame'],
    text: '손에 남은 것은 밝아진 피부가 아니라, 지워지지 않는 얼룩입니다.'
  },
  'd': {
    key: 'D',
    name: '태국 쓰레기산',
    chapter: 'CH2',
    itemId: 'item_heapFragment',
    itemName: '쓰레기 탑 조각',
    itemDesc: '압축된 쓰레기 더미의 한 조각.',
    missions: ['StackGame', 'LinkPixelsGame'],
    text: '꼭대기에서 본 풍경은 아래에서 올려다본 것과 같은 모양입니다.'
  },
  'e': {
    key: 'E',
    name: '빅이슈 / 시간',
    chapter: 'CH3',
    itemId: 'item_timeZine',
    itemName: '접힌 시간의 잡지',
    itemDesc: '시간이 접힌 채 기록된 잡지.',
    missions: ['ClockArrowsGame', 'PathGame'],
    text: '여러 장면을 지나온 뒤, 손에 남은 것은 시간을 팔고 산 이들의 기록입니다.'
  }
};

/* =========================
   미로 그리기
   ========================= */
function chapterFromRow(y){
  if(y <= 3) return 'CH1';
  if(y <= 7) return 'CH2';
  return 'CH3';
}

function drawMaze(){
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  const cellSize = Math.min(WIDTH / MAZE_W, HEIGHT / MAZE_H);
  const mazeWidthPx = MAZE_W*cellSize;
  const mazeHeightPx = MAZE_H*cellSize;
  const offsetX = (WIDTH - mazeWidthPx)/2;
  const offsetY = (HEIGHT - mazeHeightPx)/2;

  // 바깥 박스
  ctx.strokeStyle = "#999";
  ctx.lineWidth = 1;
  ctx.strokeRect(offsetX-4, offsetY-4, mazeWidthPx+8, mazeHeightPx+8);

  for(let y=0;y<MAZE_H;y++){
    for(let x=0;x<MAZE_W;x++){
      const ch = MAZE[y][x];
      const sx = offsetX + x*cellSize;
      const sy = offsetY + y*cellSize;
      if(ch === '#'){
        ctx.fillStyle = "#151515";
        ctx.fillRect(sx,sy,cellSize,cellSize);
      }else{
        ctx.fillStyle = "#000";
        ctx.fillRect(sx,sy,cellSize,cellSize);
        if(ch === 'a' || ch === 'b' || ch === 'c' || ch === 'd' || ch === 'e'){
          ctx.strokeStyle = "#cccccc";
          ctx.lineWidth = 1;
          ctx.strokeRect(sx+2,sy+2,cellSize-4,cellSize-4);
          ctx.fillStyle = "#f5f5f5";
          ctx.font = `${cellSize*0.4}px 'Press Start 2P'`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(ch.toUpperCase(), sx+cellSize/2, sy+cellSize/2);
        }
      }
    }
  }

  // 플레이어
  const px = offsetX + STATE.player.x*cellSize;
  const py = offsetY + STATE.player.y*cellSize;
  drawRedRabbit(px + cellSize*0.3, py + cellSize*0.3);
}

/* =========================
   미로 이동 & 엔딩 진입
   ========================= */
function canMoveTo(x,y){
  if(x<0||y<0||x>=MAZE_W||y>=MAZE_H) return false;
  return MAZE[y][x] !== '#';
}

function updateChapterLabelByPos(){
  const ch = chapterFromRow(STATE.player.y);
  setChapterLabel(`${ch} MAZE`);
}

function movePlayer(dx,dy){
  const nx = STATE.player.x + dx;
  const ny = STATE.player.y + dy;
  if(!canMoveTo(nx,ny)) return;
  STATE.player.x = nx;
  STATE.player.y = ny;
  updateChapterLabelByPos();

  const ch = MAZE[ny][nx];
  if(ch === 'a' || ch === 'b' || ch === 'c' || ch === 'd' || ch === 'e'){
    const cfg = ENDINGS[ch];
    const hasItem = !!STATE.items[cfg.itemId];
    if(hasItem){
      setMessage(`${cfg.itemName}을 이미 획득했습니다.`);
    }else{
      startEndingMission(ch, cfg);
    }
  }else{
    setDefaultControlMessage();
  }
}

/* =========================
   엔딩 미션 시작/완료
   ========================= */
function startEndingMission(symbol, cfg){
  const key = cfg.key;
  const idx = STATE.endingProgress[key] || 0;
  const missionKey = cfg.missions[idx];
  const GameClass = MISSION_CLASSES[missionKey];
  if(!GameClass) return;

  STATE.mode = 'mission';
  STATE.activeEndingKey = key;
  STATE.activeEndingSymbol = symbol;
  STATE.activeMissionIndex = idx;

  const game = new GameClass();
  STATE.currentGame = game;
  game.init();
  setChapterLabel(`${cfg.chapter} ${cfg.name} – ${idx+1}/${cfg.missions.length}`);
}

function completeCurrentMission(){
  const symbol = STATE.activeEndingSymbol;
  const cfg = ENDINGS[symbol];
  const key = cfg.key;

  let idx = STATE.endingProgress[key] || 0;
  idx++;
  STATE.endingProgress[key] = idx;

  if(idx >= cfg.missions.length){
    if(!STATE.items[cfg.itemId]){
      STATE.items[cfg.itemId] = {
        name: cfg.itemName,
        description: cfg.itemDesc
      };
    }
    STATE.mode = 'maze';
    STATE.currentGame = null;
    STATE.activeEndingKey = null;
    STATE.activeEndingSymbol = null;
    STATE.activeMissionIndex = 0;

    updateChapterLabelByPos();
    setMessage(cfg.text);
  }else{
    startEndingMission(symbol, cfg);
  }
}

/* =========================
   입력 처리
   ========================= */
function handleMazeTap(x,y){
  const topRegion = (y < HEIGHT*0.25);
  const bottomRegion = (y > HEIGHT*0.75);
  const leftRegion = (y >= HEIGHT*0.25 && y <= HEIGHT*0.75 && x < WIDTH*0.33);
  const rightRegion = (y >= HEIGHT*0.25 && y <= HEIGHT*0.75 && x > WIDTH*0.67);

  if(topRegion){
    movePlayer(0,-1);
  }else if(bottomRegion){
    movePlayer(0,1);
  }else if(leftRegion){
    movePlayer(-1,0);
  }else if(rightRegion){
    movePlayer(1,0);
  }
}

canvas.addEventListener('mousedown', (e)=>{
  const pos = getCanvasPos(e);
  STATE.pointer = {x:pos.x,y:pos.y,down:true};
  if(STATE.mode === 'maze'){
    handleMazeTap(pos.x,pos.y);
  }else if(STATE.currentGame){
    STATE.currentGame.pointerDown(pos.x,pos.y);
  }
});
canvas.addEventListener('mouseup', (e)=>{
  STATE.pointer.down = false;
  if(STATE.mode === 'mission' && STATE.currentGame){
    STATE.currentGame.pointerUp();
  }
});
canvas.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  const pos = getCanvasPos(e);
  STATE.pointer = {x:pos.x,y:pos.y,down:true};
  if(STATE.mode === 'maze'){
    handleMazeTap(pos.x,pos.y);
  }else if(STATE.currentGame){
    STATE.currentGame.pointerDown(pos.x,pos.y);
  }
},{passive:false});
canvas.addEventListener('touchend', (e)=>{
  e.preventDefault();
  STATE.pointer.down = false;
  if(STATE.mode === 'mission' && STATE.currentGame){
    STATE.currentGame.pointerUp();
  }
},{passive:false});

/* =========================
   메인 루프
   ========================= */
function loop(timestamp){
  const dt = (timestamp-lastTime)/1000;
  lastTime = timestamp;

  if(STATE.mode === 'maze'){
    drawMaze();
  }else if(STATE.mode === 'mission' && STATE.currentGame){
    const g = STATE.currentGame;
    g.update(dt);
    g.draw(ctx);
    if(g.isDone){
      completeCurrentMission();
    }
  }

  requestAnimationFrame(loop);
}

/* =========================
   시작 위치 찾기 & 시작
   ========================= */
function findStart(){
  for(let y=0;y<MAZE_H;y++){
    for(let x=0;x<MAZE_W;x++){
      if(MAZE[y][x] === 'S'){
        STATE.player.x = x;
        STATE.player.y = y;
        return;
      }
    }
  }
  STATE.player = {x:1,y:1};
}

function start(){
  findStart();
  updateChapterLabelByPos();
  setDefaultControlMessage();
  requestAnimationFrame(loop);
}

start();
</script>
</body>
</html>
