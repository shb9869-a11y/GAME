<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>SPACE SCAN – IN-APP 3D VIEW</title>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<style>
  * { box-sizing:border-box; }
  body{
    margin:0;
    background:#000;
    color:#fff;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    height:100vh;
    overflow:hidden;
  }
  #topBar{
    width:100%;
    max-width:480px;
    padding:10px 16px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:14px;
  }
  #status{ color:#aaa; }
  #counter{ font-weight:bold; }
  #wrap{
    width:100%;
    max-width:480px;
    padding:0 16px 16px;
    display:flex;
    flex-direction:column;
    align-items:center;
  }
  video{
    width:100%;
    border:2px solid #fff;
    border-radius:8px;
    background:#111;
  }
  #controls{
    margin-top:12px;
    display:flex;
    gap:8px;
  }
  button{
    padding:10px 16px;
    border:none;
    border-radius:6px;
    font-size:14px;
    font-weight:600;
  }
  #startBtn{ background:#fff; color:#000; }
  #resetBtn{ background:#333; color:#fff; }

  #viewerContainer{
    display:none;
    width:100%;
    flex:1;
  }
  #threeCanvas{
    width:100%;
    height:100%;
    display:block;
  }
</style>
</head>
<body>

<div id="topBar">
  <div id="status">카메라 준비 중…</div>
  <div id="counter">0 / 100</div>
</div>

<div id="wrap">
  <video id="video" autoplay playsinline></video>
  <canvas id="hiddenCanvas" style="display:none;"></canvas>
  <div id="controls">
    <button id="startBtn">스캔 시작</button>
    <button id="resetBtn">리셋</button>
  </div>
</div>

<div id="viewerContainer">
  <!-- 3D 뷰 영역 (Three.js가 여기다 그림) -->
  <canvas id="threeCanvas"></canvas>
</div>

<!-- Three.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>

<script>
/* ================================
   1. 카메라 & 자동 연사 로직
================================ */
const video = document.getElementById("video");
const hiddenCanvas = document.getElementById("hiddenCanvas");
const statusEl = document.getElementById("status");
const counterEl = document.getElementById("counter");
const startBtn = document.getElementById("startBtn");
const resetBtn = document.getElementById("resetBtn");
const viewerContainer = document.getElementById("viewerContainer");

let stream = null;
let intervalId = null;
let captureCount = 0;
const MAX_COUNT = 100;
// 여기 저장된 이미지들로 3D 모델링 느낌 구현
let capturedImages = [];

async function initCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:"environment" },
      audio:false
    });
    video.srcObject = stream;
    statusEl.textContent = "카메라 준비 완료 – 공간을 천천히 훑어봐 주세요";
  }catch(err){
    console.error(err);
    statusEl.textContent = "카메라 접근 실패 (권한을 확인하세요)";
  }
}

function updateCounter(){
  counterEl.textContent = captureCount + " / " + MAX_COUNT;
}

function captureFrame(){
  if(!video.videoWidth || !video.videoHeight){
    console.log("비디오 크기 아직 안나옴");
    return;
  }
  if(captureCount >= MAX_COUNT) return;

  const cw = 320; // 캡처 해상도(너무 크면 메모리 터질 수 있음)
  const ch = Math.round(cw * video.videoHeight / video.videoWidth);

  hiddenCanvas.width = cw;
  hiddenCanvas.height = ch;
  const ctx = hiddenCanvas.getContext("2d");
  ctx.drawImage(video, 0, 0, cw, ch);

  const dataURL = hiddenCanvas.toDataURL("image/jpeg", 0.8);
  capturedImages.push(dataURL);

  captureCount++;
  updateCounter();

  if(captureCount >= MAX_COUNT){
    finishScan();
  }
}

function startScan(){
  if(!stream){
    alert("카메라가 아직 준비되지 않았습니다.");
    return;
  }
  capturedImages = [];
  captureCount = 0;
  updateCounter();
  statusEl.textContent = "자동 스캔 중… 공간을 천천히 돌면서 움직여 주세요.";
  startBtn.disabled = true;
  intervalId = setInterval(captureFrame, 800); // 0.8초마다 한 장
}

function stopCamera(){
  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
}

function finishScan(){
  clearInterval(intervalId);
  intervalId = null;
  stopCamera();
  statusEl.textContent = "스캔 완료 – 3D 공간으로 변환 중…";
  // 카메라 뷰 감추고 3D 뷰어로 전환
  document.getElementById("wrap").style.display = "none";
  viewerContainer.style.display = "block";
  // 3D 뷰어 시작
  build3DViewFromImages(capturedImages);
}

function resetAll(){
  // 초기 상태로 리셋
  clearInterval(intervalId);
  intervalId = null;
  captureCount = 0;
  capturedImages = [];
  updateCounter();
  statusEl.textContent = "카메라 재시작 중…";
  document.getElementById("wrap").style.display = "block";
  viewerContainer.style.display = "none";
  // 기존 three.js 내용은 단순히 페이지 새로고침이 제일 깔끔
  location.reload();
}

startBtn.addEventListener("click", startScan);
resetBtn.addEventListener("click", resetAll);

initCamera();

/* ================================
   2. 캡처된 이미지로 3D "공간 링" 만들기
   - 완전한 포토그래메트리는 아니지만
     이미지를 둘러놓은 3D 콜라주
================================ */

function build3DViewFromImages(images){
  const canvas = document.getElementById("threeCanvas");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 0, 4);

  renderer.setSize(window.innerWidth, window.innerHeight);

  // 라이트
  const light = new THREE.AmbientLight(0xffffff, 1);
  scene.add(light);

  // 이미지들을 원형으로 배치
  const radius = 4; // 공간 반경
  const planeWidth = 1.5;
  const planeHeight = 1.0;

  const loader = new THREE.TextureLoader();
  const count = images.length;
  for(let i=0; i<count; i++){
    const angle = (i / count) * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;

    const texture = loader.load(images[i]);
    texture.minFilter = THREE.LinearFilter;

    const geo = new THREE.PlaneGeometry(planeWidth, planeHeight);
    const mat = new THREE.MeshBasicMaterial({ map:texture, side:THREE.DoubleSide });
    const mesh = new THREE.Mesh(geo, mat);

    mesh.position.set(x, 0, z);
    mesh.lookAt(0, 0, 0); // 중심을 바라보게

    scene.add(mesh);
  }

  // 드래그로 회전할 수 있게 간단한 컨트롤
  let isDragging = false;
  let prevX = 0;
  let prevY = 0;
  let rotY = 0;
  let rotX = 0;

  function onPointerDown(e){
    isDragging = true;
    prevX = e.clientX || e.touches?.[0]?.clientX || 0;
    prevY = e.clientY || e.touches?.[0]?.clientY || 0;
  }
  function onPointerMove(e){
    if(!isDragging) return;
    const x = e.clientX || (e.touches && e.touches[0].clientX) || 0;
    const y = e.clientY || (e.touches && e.touches[0].clientY) || 0;
    const dx = x - prevX;
    const dy = y - prevY;
    prevX = x;
    prevY = y;

    rotY += dx * 0.005;
    rotX += dy * 0.005;
  }
  function onPointerUp(){
    isDragging = false;
  }

  canvas.addEventListener("mousedown", onPointerDown);
  canvas.addEventListener("mousemove", onPointerMove);
  window.addEventListener("mouseup", onPointerUp);
  canvas.addEventListener("touchstart", onPointerDown, {passive:true});
  canvas.addEventListener("touchmove", onPointerMove, {passive:true});
  window.addEventListener("touchend", onPointerUp);

  function animate(){
    requestAnimationFrame(animate);
    // 카메라를 회전시키는 느낌
    camera.position.x = Math.sin(rotY) * 4;
    camera.position.z = Math.cos(rotY) * 4;
    camera.position.y = THREE.MathUtils.clamp(rotX, -1.5, 1.5);
    camera.lookAt(0,0,0);
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}
</script>

</body>
</html>