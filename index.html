<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SLEEP â€“ Monitorable Sound/Touch Reactive Field</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;}

  #hint{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.72);
    color:#ddd; font-family:system-ui, -apple-system, sans-serif;
    text-align:center; padding:20px;
    z-index:50;
  }
  #hint .box{
    width:min(560px, 92vw);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:18px 16px;
    background:rgba(0,0,0,.55);
  }

  #topRight{
    position:fixed; right:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  .iconBtn{
    width:42px; height:42px;
    display:grid; place-items:center;
    background:rgba(0,0,0,.38);
    color:#eee;
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px;
    backdrop-filter: blur(10px);
    cursor:pointer;
    user-select:none;
    font-size:18px;
  }
  .iconBtn:hover{border-color:rgba(255,255,255,.30)}
  .iconBtn:active{transform:translateY(1px)}

  #ui{
    position:fixed; right:12px; top:62px;
    width:min(520px, calc(100vw - 24px));
    color:#ddd;
    font-family:system-ui, -apple-system, sans-serif;
    background:rgba(0,0,0,.42);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    box-shadow:0 0 0 1px rgba(255,255,255,.06) inset;
    backdrop-filter: blur(10px);
    overflow:hidden;
    z-index:40;
    transform-origin: top right;
  }
  #ui.hidden{display:none;}
  #bar{
    display:flex; align-items:center; gap:8px;
    padding:10px 10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  #bar .title{font-weight:750; font-size:13px; color:#eee;}
  #bar .pill{
    margin-left:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px; color:#bbb;
    padding:6px 8px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:999px;
    background:rgba(0,0,0,.25);
    white-space:nowrap;
  }

  button, select, input[type="range"]{
    background:#0f0f0f; color:#eee;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:8px 10px;
    font-weight:650;
    outline:none;
  }
  input[type="range"]{padding:6px 10px;}
  button:hover, select:hover{border-color:rgba(255,255,255,.32)}
  button:disabled, select:disabled{opacity:.5; cursor:not-allowed}

  #tabs{
    display:flex; gap:6px; padding:10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .tab{
    flex:1;
    padding:8px 10px;
    font-size:12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
    cursor:pointer;
    text-align:center;
    user-select:none;
  }
  .tab.active{
    border-color:rgba(255,255,255,.34);
    background:rgba(255,255,255,.06);
  }
  #panels{padding:10px;}
  .panel{display:none;}
  .panel.active{display:block;}

  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0;}
  .label{font-size:12px; color:#aaa; width:118px;}
  .grow{flex:1; min-width:180px;}

  .meter{
    height:10px; border-radius:999px;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .meter > i{
    display:block; height:100%;
    width:0%;
    background:rgba(255,255,255,.85);
  }

  .small{font-size:11px; color:#9aa; line-height:1.45;}
  .mono{
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    color:#bbb;
    white-space:pre-wrap;
    word-break:break-word;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:10px;
    padding:8px;
    max-height:160px;
    overflow:auto;
  }

  .fileLine{
    display:flex; gap:8px; align-items:center; flex-wrap:wrap;
  }
  .fileLine input[type="file"]{
    padding:6px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.22);
    color:#ddd;
  }

  .kv{display:flex; justify-content:space-between; gap:12px; width:100%;}
  .kv b{color:#eee;}
</style>
</head>
<body>

<div id="hint">
  <div class="box">
    <div style="font-weight:800; font-size:16px; margin-bottom:10px;">SLEEP â€“ Start</div>
    <div class="small" style="margin-bottom:12px;">
      1) <b>Start Audio</b>ë¡œ ì˜¤ë””ì˜¤ë¥¼ ì—´ê³ <br/>
      2) <b>Mic ON</b> ë˜ëŠ” <b>File</b> ì„ íƒ í›„ AUDIO íƒ­ì—ì„œ ë ˆë²¨ í™•ì¸<br/>
      3) TouchMe(MIDI) ê°’ì€ MIDI íƒ­ì—ì„œ í™•ì¸
    </div>
    <div class="row">
      <button id="btnStartAudio">Start Audio</button>
      <button id="btnStartMic" disabled>Mic ON</button>
      <button id="btnStopMic" disabled>Mic OFF</button>
      <button id="btnFS">Fullscreen</button>
    </div>
    <div class="small" id="startStatus" style="opacity:.9"></div>
  </div>
</div>

<canvas id="c"></canvas>

<div id="topRight">
  <div class="iconBtn" id="btnGear" title="Settings">âš™ï¸</div>
  <div class="iconBtn" id="btnMuteQuick" title="Mute">ğŸ”‡</div>
  <div class="iconBtn" id="btnFSQuick" title="Fullscreen">â›¶</div>
</div>

<div id="ui" class="hidden">
  <div id="bar">
    <div class="title">Settings</div>
    <button id="btnHideUI" title="Close">ë‹«ê¸°</button>
    <div class="pill" id="topPill">audio:off | src:off | q:1.00</div>
  </div>

  <div id="tabs">
    <div class="tab active" data-tab="visual">VISUAL</div>
    <div class="tab" data-tab="audio">AUDIO</div>
    <div class="tab" data-tab="midi">MIDI</div>
    <div class="tab" data-tab="settings">SYSTEM</div>
  </div>

  <div id="panels">
    <!-- VISUAL -->
    <div class="panel active" id="panel-visual">
      <div class="row">
        <div class="label">Mode</div>
        <select id="selMode" class="grow">
          <option value="calm">Calm (quiet 3D dots)</option>
          <option value="pulse" selected>Pulse (amp-driven)</option>
          <option value="burst">Burst (delta-driven)</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Particles</div>
        <select id="selN" class="grow">
          <option value="160">160</option>
          <option value="220" selected>220</option>
          <option value="320">320</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Keep in screen</div>
        <select id="selBounds" class="grow">
          <option value="soft" selected>Soft boundary</option>
          <option value="bounce">Bounce</option>
          <option value="wrap">Wrap</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Quiet lines</div>
        <select id="selQuietLines" class="grow">
          <option value="0">Off</option>
          <option value="1" selected>Very subtle</option>
          <option value="2">On</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Idle Drama</div>
        <div class="grow">
          <input id="rngIdleDrama" type="range" min="0" max="1" step="0.01" value="0.55" style="width:100%;">
          <div class="small" id="txtIdleDrama">idle drama: 0.55 (ë¬´ìŒ ìƒíƒœì˜ â€˜ì‚´ì•„ìˆìŒ/í˜¸í¡/íšŒì „â€™)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Visual Sens</div>
        <div class="grow">
          <input id="rngVisSens" type="range" min="0.6" max="2.6" step="0.01" value="1.55" style="width:100%;">
          <div class="small" id="txtVisSens">visual sens: 1.55Ã— (ampâ†’ì›€ì§ì„/ì—°ê²° ë°˜ì‘ ê°•ë„)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Line density</div>
        <div class="grow">
          <input id="rngLine" type="range" min="0.2" max="1.2" step="0.01" value="0.75" style="width:100%;">
          <div class="small" id="txtLine">line density: 0.75Ã— (ì„ /ì—°ê²°ëŸ‰)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Perf limit</div>
        <div class="grow">
          <input id="rngPerf" type="range" min="0.25" max="1" step="0.01" value="0.72" style="width:100%;">
          <div class="small" id="txtPerf">perf limit: 0.72 (ë ‰ ë°©ì§€ ìƒí•œ, ë‚®ì¶œìˆ˜ë¡ ë” ì•ˆì „)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">BG fade</div>
        <div class="grow">
          <input id="rngFade" type="range" min="0.02" max="0.20" step="0.005" value="0.09" style="width:100%;">
          <div class="small" id="txtFade">fade: 0.090 (ì”ìƒ/ë¶€ë“œëŸ¬ì›€; ë†’ì„ìˆ˜ë¡ ë¹¨ë¦¬ ì§€ì›€)</div>
        </div>
      </div>

      <div class="small">
        âœ… íŒ: ë ‰ì´ ì˜¤ë©´ <b>Perf limitâ†“</b> â†’ <b>Line densityâ†“</b> â†’ <b>Particlesâ†“</b> ìˆœìœ¼ë¡œ ë‚´ë¦¬ë©´ ê±°ì˜ ë°”ë¡œ ì•ˆì •ë©ë‹ˆë‹¤.
      </div>
    </div>

    <!-- AUDIO -->
    <div class="panel" id="panel-audio">
      <div class="row">
        <div class="label">Input level</div>
        <div class="grow"><div class="meter"><i id="meterIn"></i></div></div>
      </div>

      <div class="row">
        <div class="label">Media Gain</div>
        <div class="grow">
          <input id="rngMediaGain" type="range" min="0.2" max="3.0" step="0.01" value="1.00" style="width:100%;">
          <div class="small" id="txtMediaGain">media gain: 1.00Ã— (ë§ˆì´í¬/íŒŒì¼ ì…ë ¥ ë³¼ë¥¨)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Analysis Sens</div>
        <div class="grow">
          <input id="rngSens" type="range" min="1" max="12" step="0.1" value="7.0" style="width:100%;">
          <div class="small" id="txtSens">analysis sens: 7.0Ã— (amp ë¶„ì„ ë¯¼ê°ë„)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Gamma boost</div>
        <div class="grow">
          <input id="rngGamma" type="range" min="0.45" max="1.20" step="0.01" value="0.72" style="width:100%;">
          <div class="small" id="txtGamma">gamma: 0.72 (ì‘ì€ ì†Œë¦¬ ë¶€ìŠ¤íŠ¸; 1ë³´ë‹¤ ì‘ì„ìˆ˜ë¡ ë” ì˜ˆë¯¼)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Amp cap</div>
        <div class="grow">
          <input id="rngCap" type="range" min="0.10" max="0.70" step="0.01" value="0.42" style="width:100%;">
          <div class="small" id="txtCap">amp cap: 0.42 (í­ì£¼ ìƒí•œ; ë‚®ì¶”ë©´ í° ì†Œë¦¬ì—ì„œ ë” ì•ˆì •)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Amp / Î”</div>
        <div class="mono grow" id="txtAmp">amp: 0.0000 | dAmp: 0.0000</div>
      </div>
      <div class="row">
        <div class="label">FX (Touch)</div>
        <div class="mono grow" id="txtFx">drive: - | filter: - | ring: - | widen: -</div>
      </div>

      <div class="small">
        ë ‰ì´ ìƒê¸°ëŠ” êµ¬ê°„ì„ ì°¾ì„ ë•ŒëŠ” <b>Analysis Sensâ†‘</b> ëŒ€ì‹  <b>Visual Sensâ†‘</b>ë¡œ ì˜¬ë¦¬ëŠ” ê²Œ ë” ì•ˆì „í•œ ê²½ìš°ê°€ ë§ì•„ìš”.
      </div>
    </div>

    <!-- MIDI -->
    <div class="panel" id="panel-midi">
      <div class="row">
        <div class="label">Touch value</div>
        <div class="grow"><div class="meter"><i id="meterTouch"></i></div></div>
      </div>
      <div class="row">
        <div class="label">MIDI log</div>
        <div class="mono grow" id="txtMIDI">Waitingâ€¦</div>
      </div>
    </div>

    <!-- SYSTEM -->
    <div class="panel" id="panel-settings">
      <div class="row">
        <div class="label">Audio context</div>
        <button id="btnResume" class="grow">Resume / Unlock Audio</button>
      </div>

      <div class="row">
        <div class="label">Input source</div>
        <select id="selSrc" class="grow">
          <option value="mic" selected>Mic (Live input)</option>
          <option value="file">File (MP3/WAV)</option>
        </select>
      </div>

      <div class="row" id="rowMic">
        <div class="label">Mic input</div>
        <select id="selMic" class="grow" disabled>
          <option>ì¥ì¹˜ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</option>
        </select>
      </div>

      <div class="row" id="rowFile" style="display:none;">
        <div class="label">Audio file</div>
        <div class="grow">
          <div class="fileLine">
            <input id="fileAudio" type="file" accept="audio/*">
            <button id="btnFilePlay" disabled>Play</button>
            <button id="btnFilePause" disabled>Pause</button>
            <button id="btnFileStop" disabled>Stop</button>
          </div>
          <div class="small" id="txtFile">íŒŒì¼ì„ ì„ íƒí•˜ë©´ ì´ ì†ŒìŠ¤ê°€ ì…ë ¥ ì²´ì¸(preGainâ†’FXâ†’analyser)ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤.</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Speaker output</div>
        <select id="selSpk" class="grow" disabled>
          <option>ë¸Œë¼ìš°ì € ì§€ì› í™•ì¸ ì¤‘â€¦</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Mic control</div>
        <button id="btnMicOn" class="grow" disabled>Mic ON</button>
        <button id="btnMicOff" class="grow" disabled>Mic OFF</button>
      </div>

      <div class="small" id="txtSupport"></div>
    </div>
  </div>
</div>

<script>
/* ==========================================================
   SETTINGS PERSISTENCE (localStorage)
========================================================== */
const STORE_KEY = "sleep_settings_v5";
function loadSettings(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
function saveSettings(obj){ localStorage.setItem(STORE_KEY, JSON.stringify(obj)); }
const S = loadSettings();

function applySelectValue(id, fallback){
  const el = document.getElementById(id);
  const v = (S[id] ?? fallback);
  if(el) el.value = v;
}
function hookSelectSave(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', ()=>{ S[id] = el.value; saveSettings(S); });
}
function hookRangeSave(id, fallback){
  const el = document.getElementById(id);
  if(!el) return;
  el.value = (S[id] ?? fallback);
  el.addEventListener('input', ()=>{ S[id] = parseFloat(el.value); saveSettings(S); });
}

/* ==========================================================
   CANVAS / DPR
========================================================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let W=0,H=0,DPR=1;
function resize(){
  DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  W = innerWidth|0; H = innerHeight|0;
  canvas.width  = (W*DPR)|0;
  canvas.height = (H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* ==========================================================
   AUDIO CORE + ANALYSER
========================================================== */
let audioCtx;
let analyser, timeData;
let micStream = null;
let inputNode = null;

let masterGain, isMuted=false;

// FX nodes
let preGain, driveWS, driveGain, filter, ringOsc, ringGain, ringMult, dL, dR, merger, comp;
let splitter;

let amp=0, ampSmooth=0, ampDelta=0, prevAmp=0;

// file source
let fileAudioEl = null;
let fileNode = null;
let currentSource = S.currentSource ?? "mic"; // "mic" | "file"

function makeWaveshaper(amount=20){
  const n=2048;
  const curve=new Float32Array(n);
  const k=amount;
  for(let i=0;i<n;i++){
    const x = (i*2/n)-1;
    curve[i] = (1+k)*x/(1+k*Math.abs(x));
  }
  return curve;
}

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  timeData = new Uint8Array(analyser.fftSize);

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;

  preGain = audioCtx.createGain(); preGain.gain.value = 1.0;

  driveWS = audioCtx.createWaveShaper();
  driveWS.curve = makeWaveshaper(10);
  driveWS.oversample = '4x';
  driveGain = audioCtx.createGain(); driveGain.gain.value = 1.0;

  filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 900;
  filter.Q.value = 2.0;

  ringOsc = audioCtx.createOscillator();
  ringOsc.type = 'sine';
  ringOsc.frequency.value = 35;

  ringGain = audioCtx.createGain();
  ringGain.gain.value = 0.0;

  ringMult = audioCtx.createGain();
  ringMult.gain.value = 1.0;
  ringOsc.connect(ringGain);
  ringGain.connect(ringMult.gain);

  splitter = audioCtx.createChannelSplitter(2);

  dL = audioCtx.createDelay(0.05);
  dR = audioCtx.createDelay(0.05);
  dL.delayTime.value = 0.004;
  dR.delayTime.value = 0.011;

  merger = audioCtx.createChannelMerger(2);

  comp = audioCtx.createDynamicsCompressor();
  comp.threshold.value = -22;
  comp.knee.value = 28;
  comp.ratio.value = 7;
  comp.attack.value = 0.003;
  comp.release.value = 0.14;

  preGain.connect(driveWS);
  driveWS.connect(driveGain);
  driveGain.connect(filter);
  filter.connect(ringMult);

  ringMult.connect(splitter);
  splitter.connect(dL, 0);
  splitter.connect(dR, 1);
  dL.connect(merger, 0, 0);
  dR.connect(merger, 0, 1);

  merger.connect(comp);
  comp.connect(analyser);
  analyser.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  ringOsc.start();
  updateTopPill();
}

/* ==========================================================
   AUDIO CONTROLS (UI)
========================================================== */
hookRangeSave('rngMediaGain', 1.00);
hookRangeSave('rngSens', 7.0);
hookRangeSave('rngGamma', 0.72);
hookRangeSave('rngCap', 0.42);

const rngMediaGain = document.getElementById('rngMediaGain');
const rngSens = document.getElementById('rngSens');
const rngGamma = document.getElementById('rngGamma');
const rngCap = document.getElementById('rngCap');

const txtMediaGain = document.getElementById('txtMediaGain');
const txtSens = document.getElementById('txtSens');
const txtGamma = document.getElementById('txtGamma');
const txtCap = document.getElementById('txtCap');

function getMediaGain(){ return Math.max(0.2, Math.min(3.0, parseFloat(rngMediaGain.value)||1)); }
function getSens(){ return Math.max(1, Math.min(12, parseFloat(rngSens.value)||7)); }
function getGamma(){ return Math.max(0.45, Math.min(1.20, parseFloat(rngGamma.value)||0.72)); }
function getCap(){ return Math.max(0.10, Math.min(0.70, parseFloat(rngCap.value)||0.42)); }

function refreshAudioLabels(){
  txtMediaGain.textContent = `media gain: ${getMediaGain().toFixed(2)}Ã— (ë§ˆì´í¬/íŒŒì¼ ì…ë ¥ ë³¼ë¥¨)`;
  txtSens.textContent      = `analysis sens: ${getSens().toFixed(1)}Ã— (amp ë¶„ì„ ë¯¼ê°ë„)`;
  txtGamma.textContent     = `gamma: ${getGamma().toFixed(2)} (ì‘ì€ ì†Œë¦¬ ë¶€ìŠ¤íŠ¸; 1ë³´ë‹¤ ì‘ì„ìˆ˜ë¡ ë” ì˜ˆë¯¼)`;
  txtCap.textContent       = `amp cap: ${getCap().toFixed(2)} (í­ì£¼ ìƒí•œ; ë‚®ì¶”ë©´ í° ì†Œë¦¬ì—ì„œ ë” ì•ˆì •)`;
}
['input','change'].forEach(ev=>{
  rngMediaGain.addEventListener(ev, refreshAudioLabels);
  rngSens.addEventListener(ev, refreshAudioLabels);
  rngGamma.addEventListener(ev, refreshAudioLabels);
  rngCap.addEventListener(ev, refreshAudioLabels);
});
refreshAudioLabels();

function updateAmp(){
  if(!analyser) return;

  analyser.getByteTimeDomainData(timeData);
  let sum=0;
  for(let i=0;i<timeData.length;i++){
    const v=(timeData[i]-128)/128;
    sum+=v*v;
  }
  const rms=Math.sqrt(sum/timeData.length);

  // ì…ë ¥ ë³¼ë¥¨(ë§ˆì´í¬/íŒŒì¼ ë‘˜ ë‹¤)
  const g = getMediaGain();
  const rmsG = rms * g;

  ampSmooth += (rmsG-ampSmooth)*0.12;

  const sens = getSens();
  const gamma = getGamma();
  const cap = getCap();

  const boosted = Math.pow(Math.max(0, ampSmooth * sens), gamma);
  const scaled = Math.min(cap, boosted);

  amp = scaled;
  ampDelta = Math.abs(amp - prevAmp);
  prevAmp = amp;
}

/* ==========================================================
   OUTPUT ROUTING (optional)
========================================================== */
const selMic = document.getElementById('selMic');
const selSpk = document.getElementById('selSpk');
const txtSupport = document.getElementById('txtSupport');

let currentMicDeviceId = S.currentMicDeviceId ?? "default";
let outputSupported = false;

const monitorAudio = new Audio();
monitorAudio.autoplay = true;
monitorAudio.playsInline = true;
let monitorDest = null;

function setupOutputRouting(){
  if(!audioCtx) return;
  if(monitorDest) return;
  monitorDest = audioCtx.createMediaStreamDestination();
  masterGain.connect(monitorDest);
  monitorAudio.srcObject = monitorDest.stream;
}

async function listDevices(){
  let devices = [];
  try{ devices = await navigator.mediaDevices.enumerateDevices(); }catch(e){}

  const mics = devices.filter(d=>d.kind==="audioinput");
  const spks = devices.filter(d=>d.kind==="audiooutput");

  selMic.innerHTML = "";
  if(mics.length===0){
    selMic.disabled = true;
    selMic.innerHTML = `<option>ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ</option>`;
  }else{
    selMic.disabled = false;
    for(const d of mics){
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `Mic (${d.deviceId.slice(0,6)}â€¦)`;
      if(d.deviceId === currentMicDeviceId) opt.selected = true;
      selMic.appendChild(opt);
    }
  }

  outputSupported = typeof monitorAudio.setSinkId === "function";
  selSpk.innerHTML = "";
  if(!outputSupported){
    selSpk.disabled = true;
    selSpk.innerHTML = `<option>ë¸Œë¼ìš°ì €ê°€ ì¶œë ¥ ì„ íƒì„ ì§€ì›í•˜ì§€ ì•ŠìŒ</option>`;
  }else{
    selSpk.disabled = false;
    if(spks.length===0){
      selSpk.innerHTML = `<option value="default">default</option>`;
    }else{
      for(const d of spks){
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Speaker (${d.deviceId.slice(0,6)}â€¦)`;
        if(S.currentSpkDeviceId && d.deviceId===S.currentSpkDeviceId) opt.selected = true;
        selSpk.appendChild(opt);
      }
    }
  }

  txtSupport.textContent =
    `ì§€ì› ìƒíƒœ: mic=${mics.length} | spk=${spks.length} | outputSelect=${outputSupported ? 'YES' : 'NO'}\n`+
    `AUDIO/VISUALì—ì„œ ë ‰ ì•ˆ ë¨¹ëŠ” ì„ ì„ ì§ì ‘ íŠœë‹í•˜ì„¸ìš”.`;

  if(outputSupported && S.currentSpkDeviceId){
    try{
      setupOutputRouting();
      await monitorAudio.setSinkId(S.currentSpkDeviceId);
    }catch(e){}
  }
}

selMic.addEventListener('change', async ()=>{
  currentMicDeviceId = selMic.value;
  S.currentMicDeviceId = currentMicDeviceId;
  saveSettings(S);
  if(currentSource==="mic" && micStream) await startMic(currentMicDeviceId);
});

selSpk.addEventListener('change', async ()=>{
  if(!outputSupported) return;
  S.currentSpkDeviceId = selSpk.value;
  saveSettings(S);
  try{
    setupOutputRouting();
    await monitorAudio.setSinkId(selSpk.value);
  }catch(e){
    console.warn(e);
    alert("ì´ í™˜ê²½ì—ì„œëŠ” ìŠ¤í”¼ì»¤ ì¶œë ¥ ì„ íƒì´ ì‹¤íŒ¨í–ˆì–´ìš”.");
  }
});

/* ==========================================================
   INPUT SOURCE: MIC / FILE
========================================================== */
function disconnectInputs(){
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }
}

async function startMic(deviceId="default"){
  ensureAudio();
  await audioCtx.resume();
  setupOutputRouting();

  disconnectInputs();

  try{
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: deviceId ? { exact: deviceId } : undefined,
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false
      }
    });

    const src = audioCtx.createMediaStreamSource(micStream);
    inputNode = src;
    src.connect(preGain);

    await listDevices();
    setStartButtons(true);
    updateTopPill();
    startStatus("Mic ON. AUDIO íƒ­ì—ì„œ ë ˆë²¨/ë¯¼ê°ë„ ì¡°ì ˆ.");
  }catch(e){
    console.error(e);
    startStatus("Mic ON ì‹¤íŒ¨. ê¶Œí•œ/ì¥ì¹˜ ì„ íƒ í™•ì¸.");
    alert("ë§ˆì´í¬ ê¶Œí•œ ë˜ëŠ” ì¥ì¹˜ ì„ íƒì— ì‹¤íŒ¨í–ˆì–´ìš”. í¬ë¡¬ ê¶Œí•œ í™•ì¸!");
  }
}

function stopMic(){
  if(micStream){
    micStream.getTracks().forEach(t=>t.stop());
    micStream = null;
  }
  if(inputNode){
    try{ inputNode.disconnect(); }catch(e){}
    inputNode = null;
  }
  setStartButtons(false);
  updateTopPill();
}

function ensureFileAudioEl(){
  if(fileAudioEl) return;
  fileAudioEl = new Audio();
  fileAudioEl.crossOrigin = "anonymous";
  fileAudioEl.loop = true;
  fileAudioEl.preload = "auto";
  fileAudioEl.playsInline = true;
}

function connectFileToChain(){
  ensureAudio();
  ensureFileAudioEl();
  if(!fileAudioEl.src) return;

  disconnectInputs();

  try{
    fileNode = audioCtx.createMediaElementSource(fileAudioEl);
    fileNode.connect(preGain);
  }catch(e){
    try{
      const oldSrc = fileAudioEl.src;
      fileAudioEl.pause();
      fileAudioEl.srcObject = null;
      fileAudioEl = null;
      ensureFileAudioEl();
      fileAudioEl.src = oldSrc;
      fileNode = audioCtx.createMediaElementSource(fileAudioEl);
      fileNode.connect(preGain);
    }catch(err){
      console.error(err);
      alert("íŒŒì¼ ì†ŒìŠ¤ë¥¼ ì˜¤ë””ì˜¤ ì²´ì¸ì— ì—°ê²°í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆì–´ìš”.");
    }
  }

  setStartButtons(false);
  updateTopPill();
}

function setStartButtons(micOn){
  document.getElementById('btnStartMic').disabled = !audioCtx || micOn || (currentSource!=="mic");
  document.getElementById('btnStopMic').disabled  = !micOn;
  document.getElementById('btnMicOn').disabled    = !audioCtx || micOn || (currentSource!=="mic");
  document.getElementById('btnMicOff').disabled   = !micOn;
}

function startStatus(msg){
  const el = document.getElementById('startStatus');
  if(el) el.textContent = msg;
}

/* ==========================================================
   TOUCHME (MIDI) + LOG
========================================================== */
let touch=0, touchSmooth=0;
let midiName="MIDI: ?";
let midiLog = [];
function pushMidiLog(line){
  midiLog.push(line);
  if(midiLog.length>18) midiLog.shift();
  document.getElementById('txtMIDI').textContent = `${midiName}\n` + midiLog.join('\n');
}

async function initMIDI(){
  if(!navigator.requestMIDIAccess){
    midiName="MIDI: not supported";
    pushMidiLog("requestMIDIAccess ì—†ìŒ");
    return;
  }
  try{
    const midi = await navigator.requestMIDIAccess({sysex:false});
    const inputs = [...midi.inputs.values()];
    if(inputs.length===0){
      midiName="MIDI: no inputs";
      pushMidiLog("MIDI ì…ë ¥ ì¥ì¹˜ ì—†ìŒ");
      return;
    }
    const input = inputs[0];
    midiName = "MIDI: " + (input.name || "input");
    pushMidiLog("Connected: " + midiName);

    input.onmidimessage = (e)=>{
      const data = [...e.data];
      const v = data[2] ?? 0;
      touch = Math.max(0, Math.min(1, v/127));
      pushMidiLog(`data=[${data.join(',')}] -> touch=${touch.toFixed(3)}`);
    };
  }catch(e){
    console.error(e);
    midiName="MIDI: blocked";
    pushMidiLog("MIDI access failed");
  }
}
function updateTouch(){ touchSmooth += (touch-touchSmooth)*0.18; }

/* ==========================================================
   FX MAPPING
========================================================== */
function applyFX(){
  if(!audioCtx) return;
  const t = touchSmooth;

  const driveAmt = 6 + t*60;
  driveWS.curve = makeWaveshaper(driveAmt);
  preGain.gain.setTargetAtTime(0.9 + t*1.1, audioCtx.currentTime, 0.03);
  driveGain.gain.setTargetAtTime(1.0 + t*0.8, audioCtx.currentTime, 0.03);

  const f = 250 + Math.pow(t, 1.8) * 5200;
  const q = 1.2 + t*14;
  filter.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.03);
  filter.Q.setTargetAtTime(q, audioCtx.currentTime, 0.03);

  const ringHz = 12 + t*220;
  ringOsc.frequency.setTargetAtTime(ringHz, audioCtx.currentTime, 0.03);
  ringGain.gain.setTargetAtTime(t*0.85, audioCtx.currentTime, 0.03);

  const wob = (Math.sin(performance.now()*0.0015)*0.5+0.5);
  dL.delayTime.setTargetAtTime(0.002 + t*0.010 + wob*0.0007, audioCtx.currentTime, 0.05);
  dR.delayTime.setTargetAtTime(0.006 + t*0.015 + (1-wob)*0.0009, audioCtx.currentTime, 0.05);

  document.getElementById('txtFx').textContent =
    `drive:${driveAmt.toFixed(1)} | filter:${f.toFixed(0)}Hz Q:${q.toFixed(1)} | ring:${ringHz.toFixed(1)}Hz depth:${(t*0.85).toFixed(2)} | widen:${t.toFixed(2)}`;
}

/* ==========================================================
   VISUAL CONTROLS (UI)
========================================================== */
hookRangeSave('rngIdleDrama', 0.55);
hookRangeSave('rngVisSens', 1.55);
hookRangeSave('rngLine', 0.75);
hookRangeSave('rngPerf', 0.72);
hookRangeSave('rngFade', 0.09);

const rngIdleDrama = document.getElementById('rngIdleDrama');
const rngVisSens   = document.getElementById('rngVisSens');
const rngLine      = document.getElementById('rngLine');
const rngPerf      = document.getElementById('rngPerf');
const rngFade      = document.getElementById('rngFade');

const txtIdleDrama = document.getElementById('txtIdleDrama');
const txtVisSens   = document.getElementById('txtVisSens');
const txtLine      = document.getElementById('txtLine');
const txtPerf      = document.getElementById('txtPerf');
const txtFade      = document.getElementById('txtFade');

function getIdleDrama(){ return Math.max(0, Math.min(1, parseFloat(rngIdleDrama.value)||0.55)); }
function getVisSens(){ return Math.max(0.6, Math.min(2.6, parseFloat(rngVisSens.value)||1.55)); }
function getLineMul(){ return Math.max(0.2, Math.min(1.2, parseFloat(rngLine.value)||0.75)); }
function getPerfLim(){ return Math.max(0.25, Math.min(1.0, parseFloat(rngPerf.value)||0.72)); }
function getFade(){ return Math.max(0.02, Math.min(0.20, parseFloat(rngFade.value)||0.09)); }

function refreshVisualLabels(){
  txtIdleDrama.textContent = `idle drama: ${getIdleDrama().toFixed(2)} (ë¬´ìŒ ìƒíƒœì˜ â€˜ì‚´ì•„ìˆìŒ/í˜¸í¡/íšŒì „â€™)`;
  txtVisSens.textContent   = `visual sens: ${getVisSens().toFixed(2)}Ã— (ampâ†’ì›€ì§ì„/ì—°ê²° ë°˜ì‘ ê°•ë„)`;
  txtLine.textContent      = `line density: ${getLineMul().toFixed(2)}Ã— (ì„ /ì—°ê²°ëŸ‰)`;
  txtPerf.textContent      = `perf limit: ${getPerfLim().toFixed(2)} (ë ‰ ë°©ì§€ ìƒí•œ, ë‚®ì¶œìˆ˜ë¡ ë” ì•ˆì „)`;
  txtFade.textContent      = `fade: ${getFade().toFixed(3)} (ì”ìƒ/ë¶€ë“œëŸ¬ì›€; ë†’ì„ìˆ˜ë¡ ë¹¨ë¦¬ ì§€ì›€)`;
}
['input','change'].forEach(ev=>{
  rngIdleDrama.addEventListener(ev, refreshVisualLabels);
  rngVisSens.addEventListener(ev, refreshVisualLabels);
  rngLine.addEventListener(ev, refreshVisualLabels);
  rngPerf.addEventListener(ev, refreshVisualLabels);
  rngFade.addEventListener(ev, refreshVisualLabels);
});
refreshVisualLabels();

/* ==========================================================
   VISUAL FIELD
========================================================== */
let N = 220;
let pts = [];
let rot = 0;

// base thresholds (ë¯¼ê°í•œ ê¸°ë³¸ê°’)
const BASE_QUIET_TH = 0.0032;
const BASE_ACTIVE_TH = 0.0065;
const BASE_ONSET_TH  = 0.0060;

let energy = 0;
let burstEnergy = 0;

function initPoints(){
  pts = [];
  for(let i=0;i<N;i++){
    pts.push({
      x:(Math.random()*2-1)*(W*0.34),
      y:(Math.random()*2-1)*(H*0.34),
      z:(Math.random()*2-1)*340,
      vx:0,vy:0,vz:0
    });
  }
}
initPoints();

function project(p){
  const s=Math.sin(rot), c=Math.cos(rot);
  const x = p.x*c - p.z*s;
  const z = p.x*s + p.z*c;
  const depth = 900;
  const k = depth/(depth+z);
  return { x:x*k + W/2, y:p.y*k + H/2, k, z };
}

function applyBounds(p, mode){
  if(mode==="wrap"){
    const maxX=W*0.65, maxY=H*0.65, maxZ=560;
    if(p.x> maxX) p.x=-maxX;
    if(p.x<-maxX) p.x= maxX;
    if(p.y> maxY) p.y=-maxY;
    if(p.y<-maxY) p.y= maxY;
    if(p.z> maxZ) p.z=-maxZ;
    if(p.z<-maxZ) p.z= maxZ;
    return;
  }

  const maxX=W*0.58, maxY=H*0.58, maxZ=560;

  if(mode==="bounce"){
    if(p.x> maxX){ p.x=maxX; p.vx*=-0.7; }
    if(p.x<-maxX){ p.x=-maxX; p.vx*=-0.7; }
    if(p.y> maxY){ p.y=maxY; p.vy*=-0.7; }
    if(p.y<-maxY){ p.y=-maxY; p.vy*=-0.7; }
    if(p.z> maxZ){ p.z=maxZ; p.vz*=-0.7; }
    if(p.z<-maxZ){ p.z=-maxZ; p.vz*=-0.7; }
    return;
  }

  const pull = 0.0026;
  const edgeX = Math.max(0, Math.abs(p.x) - maxX);
  const edgeY = Math.max(0, Math.abs(p.y) - maxY);
  const edgeZ = Math.max(0, Math.abs(p.z) - maxZ);
  if(edgeX>0) p.vx += (-Math.sign(p.x)) * edgeX * pull;
  if(edgeY>0) p.vy += (-Math.sign(p.y)) * edgeY * pull;
  if(edgeZ>0) p.vz += (-Math.sign(p.z)) * edgeZ * pull;
}

/* ==========================================================
   UI / TOGGLES
========================================================== */
function updateTopPill(q=1){
  const pill = document.getElementById('topPill');
  const a = audioCtx ? audioCtx.state : 'off';
  const src = (currentSource==="mic")
    ? (micStream ? "mic:on" : "mic:off")
    : (fileAudioEl && fileAudioEl.src ? (fileAudioEl.paused ? "file:loaded" : "file:play") : "file:empty");
  pill.textContent = `audio:${a} | src:${src} | q:${q.toFixed(2)}`;
}

const ui = document.getElementById('ui');
const btnGear = document.getElementById('btnGear');
const btnHideUI = document.getElementById('btnHideUI');

function setUIVisible(v){
  ui.classList.toggle('hidden', !v);
  S.uiVisible = v ? 1 : 0;
  saveSettings(S);
}
btnGear.addEventListener('click', ()=> setUIVisible(ui.classList.contains('hidden')));
btnHideUI.addEventListener('click', ()=> setUIVisible(false));
setUIVisible( (S.uiVisible ?? 0) === 1 );

document.getElementById('btnMuteQuick').addEventListener('click', ()=>{
  if(!audioCtx) return;
  isMuted = !isMuted;
  masterGain.gain.setTargetAtTime(isMuted?0:0.9, audioCtx.currentTime, 0.02);
  document.getElementById('btnMuteQuick').textContent = isMuted ? 'ğŸ”ˆ' : 'ğŸ”‡';
});
function toggleFullscreen(){
  const el = document.documentElement;
  if(!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
}
document.getElementById('btnFS').addEventListener('click', toggleFullscreen);
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

document.getElementById('btnResume').addEventListener('click', async ()=>{
  ensureAudio();
  await audioCtx.resume();
  await listDevices();
  setStartButtons(!!micStream);
  updateTopPill(1);
});

document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    document.getElementById('panel-'+t.dataset.tab).classList.add('active');
    S.activeTab = t.dataset.tab;
    saveSettings(S);
  });
});
if(S.activeTab){
  const tabEl = document.querySelector(`.tab[data-tab="${S.activeTab}"]`);
  if(tabEl) tabEl.click();
}

// restore selects + saves
applySelectValue('selMode', 'pulse');
applySelectValue('selN', '220');
applySelectValue('selBounds', 'soft');
applySelectValue('selQuietLines', '1');
applySelectValue('selSrc', (S.currentSource ?? 'mic'));
['selMode','selN','selBounds','selQuietLines','selSrc'].forEach(hookSelectSave);

document.getElementById('selN').addEventListener('change', (e)=>{
  N = parseInt(e.target.value,10);
  initPoints();
});

/* ==========================================================
   SOURCE SELECT UI
========================================================== */
const selSrc = document.getElementById('selSrc');
const rowMic = document.getElementById('rowMic');
const rowFile = document.getElementById('rowFile');

function applySourceUI(){
  currentSource = selSrc.value;
  S.currentSource = currentSource;
  saveSettings(S);

  rowMic.style.display = (currentSource==="mic") ? "" : "none";
  rowFile.style.display = (currentSource==="file") ? "" : "none";

  setStartButtons(!!micStream);
  updateTopPill(1);
}
selSrc.addEventListener('change', async ()=>{
  applySourceUI();
  if(currentSource==="mic"){
    if(fileAudioEl){ try{ fileAudioEl.pause(); }catch(e){} }
    disconnectInputs();
    ampSmooth=amp=ampDelta=prevAmp=0;
  }else{
    stopMic();
    disconnectInputs();
    ampSmooth=amp=ampDelta=prevAmp=0;
    if(fileAudioEl && fileAudioEl.src){
      ensureAudio(); await audioCtx.resume();
      connectFileToChain();
    }
  }
});
applySourceUI();

/* ==========================================================
   FILE CONTROLS
========================================================== */
const fileAudio = document.getElementById('fileAudio');
const btnFilePlay = document.getElementById('btnFilePlay');
const btnFilePause = document.getElementById('btnFilePause');
const btnFileStop = document.getElementById('btnFileStop');
const txtFile = document.getElementById('txtFile');

function setFileBtns(enabled){
  btnFilePlay.disabled = !enabled;
  btnFilePause.disabled = !enabled;
  btnFileStop.disabled = !enabled;
}
setFileBtns(false);

fileAudio.addEventListener('change', async ()=>{
  const f = fileAudio.files && fileAudio.files[0];
  if(!f) return;

  ensureAudio();
  await audioCtx.resume();
  setupOutputRouting();
  ensureFileAudioEl();

  const url = URL.createObjectURL(f);
  try{ fileAudioEl.pause(); }catch(e){}
  fileAudioEl.src = url;
  fileAudioEl.loop = true;

  txtFile.textContent = `loaded: ${f.name} (${Math.round(f.size/1024)} KB)`;

  if(currentSource!=="file"){
    selSrc.value = "file";
    applySourceUI();
  }

  connectFileToChain();
  setFileBtns(true);
  updateTopPill(1);
});

btnFilePlay.addEventListener('click', async ()=>{
  if(!fileAudioEl || !fileAudioEl.src) return;
  ensureAudio(); await audioCtx.resume();
  connectFileToChain();
  try{ await fileAudioEl.play(); }catch(e){
    alert("ì¬ìƒì´ ë§‰í˜”ì–´ìš”. í™”ë©´ì„ í•œë²ˆ í„°ì¹˜/í´ë¦­í•œ ë’¤ ë‹¤ì‹œ Play ëˆŒëŸ¬ì£¼ì„¸ìš”.");
  }
  updateTopPill(1);
});
btnFilePause.addEventListener('click', ()=>{
  if(!fileAudioEl) return;
  try{ fileAudioEl.pause(); }catch(e){}
  updateTopPill(1);
});
btnFileStop.addEventListener('click', ()=>{
  if(!fileAudioEl) return;
  try{ fileAudioEl.pause(); fileAudioEl.currentTime = 0; }catch(e){}
  updateTopPill(1);
});

/* ==========================================================
   START
========================================================== */
document.getElementById('btnStartAudio').addEventListener('click', async ()=>{
  ensureAudio();
  await audioCtx.resume();
  await initMIDI();
  await listDevices();

  document.getElementById('btnStartMic').disabled = (currentSource!=="mic");
  document.getElementById('btnMicOn').disabled = (currentSource!=="mic");
  setStartButtons(!!micStream);
  updateTopPill(1);
  startStatus("Audio unlocked. Mic ON ë˜ëŠ” SYSTEMì—ì„œ File ì„ íƒ.");
});

document.getElementById('btnStartMic').addEventListener('click', async ()=>{
  if(currentSource!=="mic") return;
  await startMic(currentMicDeviceId);
  document.getElementById('hint').style.display='none';
});

document.getElementById('btnStopMic').addEventListener('click', ()=> stopMic());
document.getElementById('btnMicOn').addEventListener('click', async ()=>{
  if(currentSource!=="mic") return;
  await startMic(currentMicDeviceId);
});
document.getElementById('btnMicOff').addEventListener('click', ()=> stopMic());

// audio unlock safety
addEventListener('pointerdown', async ()=>{
  if(audioCtx && audioCtx.state==='suspended'){
    await audioCtx.resume();
  }
},{passive:true});

/* ==========================================================
   MAIN LOOP (Adaptive Quality + User Tuning)
========================================================== */
let lastUiT = 0;
let lastFrameT = performance.now();
let frameMsSmooth = 16.7;

function loop(){
  const now = performance.now();
  const dt = now - lastFrameT;
  lastFrameT = now;
  frameMsSmooth += (dt - frameMsSmooth) * 0.08;

  // Adaptive quality by frame time
  let qAuto = 1 - Math.max(0, (frameMsSmooth - 16) / 45);
  qAuto = Math.max(0.28, Math.min(1, qAuto));

  // User perf limit clamps it (ë” ê°•ë ¥í•œ ë ‰ ë°©ì§€)
  const q = Math.min(qAuto, getPerfLim());

  // BG fade controllable
  ctx.fillStyle = `rgba(0,0,0,${getFade().toFixed(3)})`;
  ctx.fillRect(0,0,W,H);

  if(audioCtx) updateAmp();
  updateTouch();
  if(audioCtx) applyFX();

  if(now - lastUiT > 110){
    lastUiT = now;
    const inPct = Math.max(0, Math.min(1, amp*6.0));
    document.getElementById('meterIn').style.width = (inPct*100).toFixed(1)+"%";
    document.getElementById('txtAmp').textContent =
      `amp: ${amp.toFixed(4)} | dAmp: ${ampDelta.toFixed(4)} | frame:${frameMsSmooth.toFixed(1)}ms | q:${q.toFixed(2)}`;
    document.getElementById('meterTouch').style.width = (touchSmooth*100).toFixed(1)+"%";
    updateTopPill(q);
  }

  // --- STATE
  const visSens = getVisSens();
  const idleDrama = getIdleDrama();

  // thresholdëŠ” visSensê°€ ë†’ì„ìˆ˜ë¡ ë” ì‰½ê²Œ activeë¡œ
  const QUIET_TH = BASE_QUIET_TH / visSens;
  const ACTIVE_TH = BASE_ACTIVE_TH / visSens;
  const ONSET_TH  = BASE_ONSET_TH / visSens;

  const targetEnergy = (amp > ACTIVE_TH) ? 1 : (amp < QUIET_TH ? 0 : energy);
  energy += (targetEnergy - energy) * 0.05;

  // idle dramaê°€ ë†’ìœ¼ë©´ ì—ë„ˆì§€ ë°”ë‹¥ì„ ì˜¬ë ¤ â€œë¬´ìŒ ë“œë¼ë§ˆâ€ ìœ ì§€
  const energyFloor = 0.04 + idleDrama * 0.20; // 0.04~0.24
  energy = Math.max(energyFloor, energy);

  const onset = Math.max(0, (ampDelta - ONSET_TH));
  burstEnergy += (onset*8.0 - burstEnergy) * 0.12;
  burstEnergy *= 0.92;
  burstEnergy = Math.min(1.5, burstEnergy);

  const mode = document.getElementById('selMode').value;
  const boundsMode = document.getElementById('selBounds').value;
  const quietLines = parseInt(document.getElementById('selQuietLines').value,10);

  const t = now*0.001;
  const breathe = 0.5 + 0.5*Math.sin(t*1.2);

  const baseSpeedQuiet = 0.10 + idleDrama*0.05;
  const baseChaosQuiet = 0.55 + idleDrama*1.10;

  const baseSpeedActive = (0.12 + Math.min(0.30, amp*2.6)) * visSens;
  const baseChaosActive = Math.min(22, (ampDelta*90) + (touchSmooth*34) + burstEnergy*42) * visSens;

  let speed = baseSpeedQuiet*(1-energy) + baseSpeedActive*energy;
  let chaos = baseChaosQuiet*(1-energy) + baseChaosActive*energy;

  if(mode==="calm"){ speed *= 0.88; chaos *= 0.75; }
  if(mode==="burst"){ speed *= 1.05; chaos *= 1.18; }

  // link distance controlled by line density
  const lineMul = getLineMul();
  const linkDistQuiet = 26 + idleDrama*10;
  const linkDistActiveRaw = (64 + amp*240 + touchSmooth*280 + burstEnergy*110) * lineMul * visSens;
  const linkDistActive = Math.min(160, linkDistActiveRaw);
  const linkDist = linkDistQuiet*(1-energy) + linkDistActive*energy;

  const centerPull = (0.008 + touchSmooth*0.018) * (1.0 - Math.min(1, amp*1.2)) * (0.75 + idleDrama*0.6);
  const burst = (amp*0.017 + ampDelta*0.056 + touchSmooth*0.010 + burstEnergy*0.020) * visSens;

  const freeze = energy * Math.max(0, 1 - (ampDelta*20));
  const rotSpeedBase = (0.0012 + energy*0.010 + burstEnergy*0.008) * (1 - 0.7*freeze);
  const rotSpeed = rotSpeedBase * (0.65 + idleDrama*0.8);
  rot += rotSpeed;

  const scale = 1.0 + energy*(breathe-0.5)*0.25;

  for(const p of pts){
    p.vx += (Math.random()-0.5)*chaos;
    p.vy += (Math.random()-0.5)*chaos;
    p.vz += (Math.random()-0.5)*chaos*0.55;

    p.vx += (-p.x)*centerPull*(0.9 - energy*0.4);
    p.vy += (-p.y)*centerPull*(0.9 - energy*0.4);
    p.vz += (-p.z)*centerPull*(0.6 - energy*0.2);

    p.vx += (p.x)*burst*energy;
    p.vy += (p.y)*burst*energy;
    p.vz += (p.z)*burst*energy*0.6;

    p.vx *= 0.90 - energy*0.05;
    p.vy *= 0.90 - energy*0.05;
    p.vz *= 0.92 - energy*0.04;

    p.x = (p.x + p.vx*speed) * scale + (1-scale)*p.x;
    p.y = (p.y + p.vy*speed) * scale + (1-scale)*p.y;
    p.z = (p.z + p.vz*speed) * (0.92 + 0.08*scale) + (1-(0.92 + 0.08*scale))*p.z;

    applyBounds(p, boundsMode);
  }

  const pr = pts.map(project);

  // lines: bucket + adaptive + user density & perf clamp
  if(energy > 0.05 || quietLines>0){
    const cell = Math.max(22, Math.floor(linkDist));
    const inv = 1 / cell;
    const grid = new Map();

    for(let i=0;i<N;i++){
      const a = pr[i];
      const cx = (a.x*inv)|0;
      const cy = (a.y*inv)|0;
      const key = (cx<<16) ^ (cy & 0xffff);
      let arr = grid.get(key);
      if(!arr){ arr=[]; grid.set(key, arr); }
      arr.push(i);
    }

    // user controls line density and perf
    const baseMax = (1200 + energy*900 + burstEnergy*800) * lineMul;
    const maxLines = Math.floor(baseMax * q);

    let linesDrawn = 0;
    const stride = (q < 0.45) ? 2 : 1;

    for(let i=0;i<N;i+=stride){
      if(linesDrawn >= maxLines) break;
      const a = pr[i];
      const cx = (a.x*inv)|0;
      const cy = (a.y*inv)|0;

      for(let oy=-1; oy<=1; oy++){
        for(let ox=-1; ox<=1; ox++){
          if(linesDrawn >= maxLines) break;

          const k = ((cx+ox)<<16) ^ ((cy+oy) & 0xffff);
          const bucket = grid.get(k);
          if(!bucket) continue;

          for(let bi=0; bi<bucket.length; bi++){
            const j = bucket[bi];
            if(j<=i) continue;

            const b = pr[j];
            const dx=a.x-b.x, dy=a.y-b.y;
            const d = Math.hypot(dx,dy);
            if(d<linkDist){
              const alpha = 1 - d/linkDist;

              const quietGain = (quietLines===0) ? 0 : (quietLines===1 ? 0.14 : 0.28);
              const onGain = 0.38 + amp*1.6*visSens + burstEnergy*1.7*visSens;
              const punch = Math.min(1, alpha * (quietGain*(1-energy) + onGain*energy));

              ctx.globalAlpha = punch;
              ctx.strokeStyle = "rgba(255,255,255,0.9)";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(a.x,a.y);
              ctx.lineTo(b.x,b.y);
              ctx.stroke();

              linesDrawn++;
              if(linesDrawn >= maxLines) break;
            }
          }
        }
      }
    }
  }

  // points: quietì—ì„œë„ í™•ì‹¤íˆ ì‚´ì•„ìˆê²Œ + visSensë¡œ ë°˜ì‘ ê°•í™”
  for(let i=0;i<N;i++){
    const p = pr[i];
    const baseR = 1.0 + p.k*0.6;

    const rQuiet = Math.max(1.4, baseR * (1.05 + idleDrama*0.20));
    const rActive = baseR * (1.25 + amp*3.0*visSens + touchSmooth*1.2 + burstEnergy*0.9);
    const r = rQuiet*(1-energy) + rActive*energy;

    const aQuiet = 0.36 + idleDrama*0.16; // 0.36~0.52
    const aActive = Math.min(1, 0.45 + amp*1.05*visSens + touchSmooth*0.55 + burstEnergy*0.7);
    const a = aQuiet*(1-energy) + aActive*energy;

    ctx.globalAlpha = a;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  requestAnimationFrame(loop);
}
loop();

/* ==========================================================
   MUTE/FS QUICK
========================================================== */
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

/* ==========================================================
   INIT
========================================================== */
N = parseInt(document.getElementById('selN').value,10);
initPoints();
</script>
</body>
</html>
