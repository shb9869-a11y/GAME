<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>SLEEP – Sound / Touch Reactive Field</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
canvas{display:block}
#hint{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  color:#aaa; font-family:sans-serif;
  background:rgba(0,0,0,.6);
}
</style>
</head>
<body>

<div id="hint">화면을 한 번 터치 / 클릭</div>
<canvas id="c"></canvas>

<script>
/* ======================
   BASIC SETUP
====================== */
const canvas = document.getElementById("c");
const ctx2d = canvas.getContext("2d");
let w,h,dpr;

function resize(){
  dpr = window.devicePixelRatio||1;
  w = canvas.width = innerWidth*dpr;
  h = canvas.height = innerHeight*dpr;
}
window.addEventListener("resize",resize);
resize();

/* ======================
   AUDIO (AMPLITUDE ONLY)
====================== */
let audioCtx, analyser, data;
let amp = 0, ampSmooth = 0, ampDelta = 0;

async function initMic(){
  audioCtx = new AudioContext();
  const stream = await navigator.mediaDevices.getUserMedia({audio:true});
  const src = audioCtx.createMediaStreamSource(stream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  data = new Uint8Array(analyser.fftSize);
  src.connect(analyser);
}

function updateAmp(){
  if(!analyser) return;
  analyser.getByteTimeDomainData(data);
  let sum=0;
  for(let i=0;i<data.length;i++){
    const v=(data[i]-128)/128;
    sum+=v*v;
  }
  const rms=Math.sqrt(sum/data.length);
  ampDelta = Math.abs(rms-ampSmooth);
  ampSmooth += (rms-ampSmooth)*0.15;
  amp = ampSmooth;
}

/* ======================
   TOUCHME (MIDI FLOW)
====================== */
let touch=0, touchSmooth=0;

if(navigator.requestMIDIAccess){
  navigator.requestMIDIAccess().then(midi=>{
    for(const input of midi.inputs.values()){
      input.onmidimessage=e=>{
        const [, ,v]=e.data;
        touch = v/127;
      };
      break;
    }
  });
}

function updateTouch(){
  touchSmooth += (touch-touchSmooth)*0.2;
}

/* ======================
   POINT FIELD
====================== */
const N=180;
const pts=[];
for(let i=0;i<N;i++){
  pts.push({
    x:Math.random()*w,
    y:Math.random()*h,
    vx:0, vy:0
  });
}

function draw(){
  updateAmp();
  updateTouch();

  ctx2d.fillStyle="rgba(0,0,0,0.15)";
  ctx2d.fillRect(0,0,w,h);

  const speed = 0.2 + amp*12;
  const linkDist = 40 + amp*180 + touchSmooth*220;
  const chaos = ampDelta*120 + touchSmooth*60;

  for(const p of pts){
    p.vx += (Math.random()-0.5)*chaos;
    p.vy += (Math.random()-0.5)*chaos;
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.x += p.vx*speed;
    p.y += p.vy*speed;

    if(p.x<0)p.x+=w; if(p.x>w)p.x-=w;
    if(p.y<0)p.y+=h; if(p.y>h)p.y-=h;
  }

  // connections
  ctx2d.strokeStyle="rgba(255,255,255,0.25)";
  ctx2d.lineWidth=1*dpr;

  for(let i=0;i<N;i++){
    for(let j=i+1;j<N;j++){
      const a=pts[i], b=pts[j];
      const dx=a.x-b.x, dy=a.y-b.y;
      const d=Math.hypot(dx,dy);
      if(d<linkDist){
        ctx2d.globalAlpha = 1 - d/linkDist;
        ctx2d.beginPath();
        ctx2d.moveTo(a.x,a.y);
        ctx2d.lineTo(b.x,b.y);
        ctx2d.stroke();
      }
    }
  }

  // points
  ctx2d.fillStyle="#fff";
  ctx2d.globalAlpha=0.8;
  for(const p of pts){
    ctx2d.beginPath();
    ctx2d.arc(p.x,p.y,(1.5+amp*3)*dpr,0,Math.PI*2);
    ctx2d.fill();
  }
  ctx2d.globalAlpha=1;

  requestAnimationFrame(draw);
}

/* ======================
   START
====================== */
async function start(){
  document.getElementById("hint").remove();
  await initMic();
  draw();
}
["pointerdown","touchstart","mousedown"].forEach(e=>{
  window.addEventListener(e,start,{once:true});
});
</script>
</body>
</html>
