<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Grave Run — 술래잡기</title>
<meta name="theme-color" content="#140c1c" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Grave Run" />
<style>
  :root{
    --bg:#0a0812; --fg:#eae6ff;
    --violet:#6d58a5; --violet2:#4a3b76; --violet3:#2a2144; --shadow:#000000;
    --accent:#ff7a33;
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bot: env(safe-area-inset-bottom, 0px);
    --safe-left: env(safe-area-inset-left, 0px);
    --safe-right: env(safe-area-inset-right, 0px);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
  body{display:grid;place-items:center;font-family: ui-monospace,"SF Mono",Menlo,Consolas,monospace;}
  #wrap{
    position:relative; width:100vw; height:100svh; overflow:hidden; background:var(--bg);
    padding:var(--safe-top) var(--safe-right) var(--safe-bot) var(--safe-left);
  }
  /* 중앙 고정 */
  canvas{
    position:absolute; left:50%; top:50%;
    transform: translate(-50%, -50%);
    image-rendering:pixelated; image-rendering:crisp-edges; touch-action:none;
  }

  /* 조이스틱 */
  .pad{ position:absolute; bottom:calc(16px + var(--safe-bot)); left:calc(16px + var(--safe-left)); width:150px; height:150px; opacity:.95; filter: drop-shadow(0 2px 8px rgba(0,0,0,.6)); }
  .pad .ring{ position:absolute; inset:0; border-radius:50%; border:2px dashed rgba(255,255,255,.18); background: radial-gradient(circle, rgba(255,255,255,.06), rgba(255,255,255,.02)); }
  .pad .stick{ position:absolute; width:66px; height:66px; left:42px; top:42px; border-radius:50%; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.3);}

  .badge{ position:absolute; right:calc(10px + var(--safe-right)); top:calc(8px + var(--safe-top)); font-size:12px; opacity:.8; background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.15); padding:4px 8px; border-radius:8px; }

  /* E 버튼 + 대화창 */
  .btnE{ position:absolute; right:calc(16px + var(--safe-right)); bottom:calc(16px + var(--safe-bot));
         width:120px; height:52px; border-radius:12px; border:1px solid rgba(255,255,255,.25);
         background:rgba(0,0,0,.38); color:#fff; display:none; place-items:center;
         font:600 13px ui-monospace,monospace; letter-spacing:.2px; }
  .dialog{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); }
  .dialog .box{ min-width:260px; max-width:86vw; background:#1b142a; color:#eee; border:1px solid rgba(255,255,255,.2); border-radius:10px; padding:12px; box-shadow:0 10px 24px rgba(0,0,0,.6); font:12px/1.6 ui-monospace,monospace; }
  .dialog .box h3{ margin:0 0 8px; font:700 12px ui-monospace,monospace; color:#ffd4a6; }
  .choices{ display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
  .choices button{ padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.25); background:#33265a; color:#fff; font:600 12px ui-monospace,monospace; }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="256" height="256"></canvas>
    <div class="pad" id="pad" aria-hidden="true">
      <div class="ring"></div>
      <div class="stick" id="stick"></div>
    </div>
    <div class="badge">Pac-style tag · 중앙 로봇=대화 상대 · 우상단 주황=플레이어</div>

    <button id="btnE" class="btnE">E: 상호작용</button>
    <div id="dialog" class="dialog" role="dialog" aria-modal="true">
      <div class="box">
        <h3 id="dgTitle">기록</h3>
        <div id="dgBody">...</div>
        <div id="dgChoices" class="choices"></div>
      </div>
    </div>
  </div>
<script>
(()=>{
  // ===== PWA 최소 셋업 =====
  const manifest = {name:"Grave Run", short_name:"GraveRun", start_url:".", display:"standalone", background_color:"#140c1c", theme_color:"#140c1c"};
  const manURL = URL.createObjectURL(new Blob([JSON.stringify(manifest)], {type:'application/json'}));
  const link = document.createElement('link'); link.rel='manifest'; link.href=manURL; document.head.appendChild(link);
  if ('serviceWorker' in navigator){
    const swCode = `const C='graverun-v1';self.addEventListener('install',e=>e.waitUntil(caches.open(C).then(c=>c.addAll(['./']))));self.addEventListener('activate',e=>e.waitUntil(caches.keys().then(K=>Promise.all(K.map(k=>k!==C&&caches.delete(k))))));self.addEventListener('fetch',e=>{const u=new URL(e.request.url);if(u.origin===location.origin){e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request).then(res=>{const cc=res.clone();caches.open(C).then(c=>c.put(e.request,cc));return res;}).catch(()=>caches.match('./'))))}});`;
    const url = URL.createObjectURL(new Blob([swCode], {type:'text/javascript'}));
    navigator.serviceWorker.register(url, {scope:'./'}).catch(()=>{});
  }
  // 첫 터치에 오디오/전체화면 준비(안드로이드)
  window.addEventListener('pointerdown', ()=>{
    const el=document.documentElement;
    if(!document.fullscreenElement && el.requestFullscreen) el.requestFullscreen();
    unlockAudio();
  },{once:true, passive:true});

  // ===== 8bit SFX =====
  let AC, masterGain, unlocked=false;
  function initAudio(){
    if(unlocked) return;
    AC = AC || new (window.AudioContext||window.webkitAudioContext)();
    masterGain = masterGain || AC.createGain();
    masterGain.gain.value = 0.22;
    masterGain.connect(AC.destination);
    unlocked = true;
  }
  async function unlockAudio(){
    initAudio();
    try{ if(AC.state === 'suspended') await AC.resume(); }catch(e){}
  }
  ['pointerdown','touchstart','keydown'].forEach(ev=>{
    window.addEventListener(ev, unlockAudio, {once:false, passive:true});
  });
  function beep({freq=440, type='square', dur=0.12, attack=0.002, release=0.08, vol=0.35, slide=0}={}){
    if(!unlocked) return;
    const now = AC.currentTime;
    const osc = AC.createOscillator();
    const gain = AC.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, now);
    if (slide) osc.frequency.exponentialRampToValueAtTime(Math.max(40, freq*slide), now+dur*0.9);
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(vol, now+attack);
    gain.gain.linearRampToValueAtTime(0.0001, now+dur+release);
    osc.connect(gain); gain.connect(masterGain);
    osc.start(now); osc.stop(now+dur+release+0.01);
  }
  const SFX = {
    step(i=0){ const f = i%2 ? 520 : 460; beep({freq:f, dur:0.06, attack:0.001, release:0.05, vol:0.2}); },
    interact(){ beep({freq:880, dur:0.08, vol:0.26}); beep({freq:1320, dur:0.08, vol:0.22, slide:0.8}); },
    select(){ beep({freq:660, dur:0.07, vol:0.22}); },
  };

  // ===== 캔버스/스케일 =====
  const wrap = document.getElementById('wrap');
  const game = document.getElementById('game');
  const g = game.getContext('2d', { alpha:false });
  g.imageSmoothingEnabled = false;
  const TILE = 16, MAP_W = 16, MAP_H = 16;

  function fit(){
    const {clientWidth:cw, clientHeight:ch} = wrap;
    const scale = Math.max(1, Math.floor(Math.min(cw/game.width, ch/game.height)));
    game.style.width = (game.width*scale)+"px";
    game.style.height = (game.height*scale)+"px";
  }
  new ResizeObserver(fit).observe(wrap);

  // ===== 팔레트 =====
  const C = {
    bg:'#201335', plate:'#6d58a5', plate2:'#584787', border:'#2a2144', dot:'#3a2c5d',
    grave:'#7c6ac0', graveDark:'#362a56', shadow:'rgba(0,0,0,.55)',
    seeker:'#cfe6ff', seekerEye:'#37a5ff', seekerBody:'#aab9cc',
    player:'#ff7a33', playerDark:'#b74f14'
  };

  // ===== 맵(1=비석, 0=빈칸) =====
  const LEVEL = [
    "1111111111111111",
    "1000000000000001",
    "1011111111111101",
    "1011111111111101",
    "1010110110110101",
    "1011111111111101",
    "1011111111111101",
    "1010110110110101",
    "1011111111111101",
    "1011111111111101",
    "1010110110110101",
    "1011111111111101",
    "1011111111111101",
    "1000000000000001",
    "1000000000000001",
    "1111110000111111"
  ].map(r=>r.split('').map(d=>+d));
  // 스폰/중앙/입구 비우기
  for(let y=1;y<5;y++) for(let x=12;x<15;x++) LEVEL[y][x]=0;
  LEVEL[8][8]=0; LEVEL[7][8]=0; LEVEL[8][7]=0; LEVEL[8][9]=0;
  LEVEL[15][6]=0; LEVEL[15][7]=0; LEVEL[15][8]=0; LEVEL[15][9]=0;

  // ===== 엔티티 =====
  function makePlayer(x,y){ return {x,y, spd:0.09, anim:0, stepTimer:0, stepPhase:0}; }
  function makeSeeker(x,y){ return {x,y, spd:0.08, t:0}; }

  const players = [ makePlayer(13.5, 2.5) ];
  const seeker = makeSeeker(8.5, 8.5);

  const P = Math.max(1, Math.min(4, +(new URLSearchParams(location.search).get('p')||1)));
  while (players.length < P) players.push(makePlayer(14.5-(players.length*0.8), 3.2+(players.length*0.6)));

  // ===== 입력 (키보드 + 조이스틱) =====
  const keys = new Set();
  addEventListener('keydown', e=>{ const k=e.key.toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','e'].includes(k)) e.preventDefault(); keys.add(k); });
  addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));
  const pad = document.getElementById('pad');
  const stick = document.getElementById('stick');
  let joy={ax:0,ay:0,active:false};
  function padStart(e){ joy.active=true; moveStick(e); }
  function padMove(e){ if(joy.active) moveStick(e); }
  function padEnd(){ joy.active=false; stick.style.left='42px'; stick.style.top='42px'; joy.ax=0; joy.ay=0; }
  function moveStick(e){
    const r=pad.getBoundingClientRect(); const cx=r.left+r.width/2, cy=r.top+r.height/2; const p=e.touches?e.touches[0]:e;
    let dx=p.clientX-cx, dy=p.clientY-cy; const m=Math.hypot(dx,dy), max=44; if(m>max){dx*=max/m; dy*=max/m;}
    stick.style.left=(r.width/2+dx-33)+'px'; stick.style.top=(r.height/2+dy-33)+'px'; joy.ax = dx/max; joy.ay = dy/max;
  }
  for (const ev of ['pointerdown','pointermove','pointerup','pointercancel']) pad.addEventListener(ev, {pointerdown:padStart,pointermove:padMove,pointerup:padEnd,pointercancel:padEnd}[ev]);
  function updatePadVisibility(){ pad.style.display = matchMedia('(pointer: coarse)').matches? 'block':'none'; }
  updatePadVisibility();

  // ===== 충돌/이동 =====
  function solidAt(tx,ty){
    // 맵 밖
    if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return true;
    // 외곽 벽 (하단 입구 제외)
    if (ty===0 || ty===MAP_H-1 || tx===0 || tx===MAP_W-1){
      if (ty===MAP_H-1 && tx>=6 && tx<=9) return false;
      return true;
    }
    // 내부 비석은 충돌
    return LEVEL[ty][tx]===1;
  }
  function moveEntity(e, ax, ay){
    const spd = e.spd; let nx = e.x + ax*spd, ny = e.y + ay*spd;
    // X축
    if (!solidAt(nx|0, e.y|0)) e.x = nx;
    // Y축
    if (!solidAt(e.x|0, ny|0)) e.y = ny;
  }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  // ===== UI: 대화/비석 =====
  const btnE = document.getElementById('btnE');
  const dialog = document.getElementById('dialog');
  const dgTitle = document.getElementById('dgTitle');
  const dgBody  = document.getElementById('dgBody');
  const dgChoices = document.getElementById('dgChoices');

  function closeDialog(){ dialog.style.display='none'; dgChoices.innerHTML=''; }
  dialog.addEventListener('click', (e)=>{ if(e.target===dialog) closeDialog(); });

  function graveText(gv){
    const lines=[
      "나는 얼굴을 잃고, 귀로만 걷는다.","빛이 고요를 문질러 소리가 났다.","오차가 감정이고, 잔향이 초상이다.",
      "돌은 서 있고, 이야기는 흘러간다.","너와 나 사이, 빈칸이 숨을 쉰다.","시간의 모서리에 귀를 댔다.",
      "여기 눕힌 건 말들이다.","망각의 틈에서 작은 불이 켜진다."
    ];
    const idx = (gv.x*31 + gv.y*17) % lines.length; return lines[idx];
  }
  function nearestGrave(px,py){
    let best=null, bd=1e9;
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL[y][x]===1){
      const cx=x+0.5, cy=y+0.5; const d=Math.hypot(px-cx, py-cy);
      if(d<bd){bd=d; best={x,y,cx,cy};}
    }
    return {grave:best, dist:bd};
  }

  // ===== 로봇 대화 시스템(3턴) =====
  const convo = [
    {
      npc: "……신호 포착. 너는 소리를 어떻게 듣지?",
      choices: ["몸으로 먼저 듣는다.", "기억으로 해석한다."],
      replies: ["좋아. 몸은 진실을 숨기지 않지.", "그래, 기억은 언제나 편집본이야."]
    },
    {
      npc: "여기 비석들은 잊힌 말들의 좌표야.",
      choices: ["좌표를 따라가면 어디에 닿을까?", "말이 사라지면 무엇이 남지?"],
      replies: ["아마 네가 모르는 너에게.", "침묵. 그리고 방향."]
    },
    {
      npc: "마지막 질문. 너는 왜 계속 걷고 있어?",
      choices: ["누군가의 잔향을 찾고 있어.", "멈추면, 들리지 않을까 봐."],
      replies: ["그 잔향이 네 지도를 바꿀 거야.", "걷는 침묵은 언제나 열려 있지."]
    }
  ];
  let inConvo = false, stepIdx = 0;

  function openRobotConvo(){
    inConvo = true; stepIdx = 0; renderConvoStep();
    dialog.style.display='flex'; SFX.interact();
  }
  function renderConvoStep(){
    dgTitle.textContent = '로봇';
    const step = convo[stepIdx];
    dgBody.innerHTML = `<div style="white-space:pre-wrap">${step.npc}</div>`;
    dgChoices.innerHTML = '';
    step.choices.forEach((text,i)=>{
      const b=document.createElement('button');
      b.textContent = text;
      b.onclick = ()=>{
        SFX.select();
        // 선택 반영
        const reply = step.replies[i];
        dgBody.innerHTML += `\n\n> 너: ${text}\n로봇: ${reply}`;
        // 다음 단계
        stepIdx++;
        if(stepIdx < convo.length){
          setTimeout(()=>renderConvoStep(), 420);
        }else{
          // 종료 버튼
          dgChoices.innerHTML='';
          const done=document.createElement('button');
          done.textContent='끝내기';
          done.onclick=()=>{ inConvo=false; closeDialog(); };
          dgChoices.appendChild(done);
        }
      };
      dgChoices.appendChild(b);
    });
  }

  // ===== 로봇 이동(온건) =====
  function stepSeeker(){
    if(inConvo) return; // 대화 중 정지
    // 플레이어 쪽으로 살짝 다가오지만 공격 없음
    const p = players[0];
    const dx = p.x - seeker.x, dy = p.y - seeker.y;
    const m = Math.hypot(dx,dy);
    if(m>0.9){ // 너무 붙지 않게
      const ax = dx/m, ay = dy/m;
      moveEntity(seeker, ax, ay);
    }
  }

  // ===== 렌더링 =====
  function drawBoard(){
    g.fillStyle = C.bg; g.fillRect(0,0,game.width,game.height);
    g.fillStyle = C.border; g.fillRect(6,6,game.width-12,game.height-12);
    g.fillStyle = C.plate; g.fillRect(12,12,game.width-24,game.height-24);
    g.fillStyle = C.dot; for(let i=0;i<190;i++){ const x=12+Math.random()*(game.width-24)|0; const y=12+Math.random()*(game.height-24)|0; g.fillRect(x,y,1,1); }
    // 비석(충돌 O)
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL[y][x]===1) drawGrave(x*TILE, y*TILE);
    // 하단 통로 표시
    g.fillStyle = C.plate2; g.fillRect(6*TILE, 15*TILE, 4*TILE, TILE);
  }
  function drawGrave(px,py){
    g.fillStyle=C.shadow; g.fillRect(px+2,py+TILE-3,TILE-2,2);
    g.fillStyle=C.graveDark; g.fillRect(px+3,py+3,TILE-6,TILE-6);
    g.fillStyle=C.grave; g.fillRect(px+2,py+4,TILE-6,TILE-7);
    g.fillStyle='rgba(255,255,255,.08)'; g.fillRect(px+3,py+4,TILE-8,1);
  }
  function drawSeeker(){
    const px = Math.round((seeker.x*TILE)-(TILE/2));
    const py = Math.round((seeker.y*TILE)-(TILE/2));
    g.fillStyle = C.seekerBody; g.fillRect(px+3, py+6, 10, 6);
    g.fillStyle = '#ffffff'; g.fillRect(px+2, py+4, 12, 6);
    g.fillStyle = C.seekerEye; g.fillRect(px+5, py+6, 2, 2); g.fillRect(px+9, py+6, 2, 2);
    g.fillStyle = '#111'; g.fillRect(px+1, py+8, 2,3); g.fillRect(px+13, py+8, 2,3);
  }
  function drawPlayer(p){
    const px = Math.round((p.x*TILE)-(TILE/2));
    const py = Math.round((p.y*TILE)-(TILE/2));
    g.fillStyle=C.shadow; g.fillRect(px+2, py+TILE-2, TILE-4, 2);
    g.fillStyle = C.player; g.fillRect(px+4, py+5, 8, 7);
    g.fillStyle = C.playerDark; g.fillRect(px+4, py+4, 8, 2);
    if(((p.anim*10)|0)%20<10){ g.fillStyle='#000'; g.fillRect(px+6, py+7, 1,1); g.fillRect(px+9, py+7, 1,1); }
  }

  // ===== 루프 =====
  let last=0;
  function loop(t){ requestAnimationFrame(loop); const dt=Math.min(32,(t-last)||16); last=t; update(dt/16); render(); }

  function update(dt){
    // 이동 입력
    let ax=0, ay=0;
    if(keys.has('a')||keys.has('arrowleft')) ax-=1; if(keys.has('d')||keys.has('arrowright')) ax+=1;
    if(keys.has('w')||keys.has('arrowup')) ay-=1; if(keys.has('s')||keys.has('arrowdown')) ay+=1;
    ax+=joy.ax; ay+=joy.ay; const m=Math.hypot(ax,ay)||1; ax/=m; ay/=m;

    // 플레이어 이동 + 발걸음 소리
    const moving = Math.hypot(ax,ay) > 0.1 && !inConvo;
    for(const p of players){
      if(!inConvo) moveEntity(p, ax, ay);
      p.anim += dt;
      if(moving){
        p.stepTimer += dt*1000;
        const interval = 180;
        if(p.stepTimer >= interval){ p.stepTimer = 0; SFX.step(p.stepPhase++); }
      }else{ p.stepTimer = 0; }
    }

    // 로봇 이동(공격 없음)
    stepSeeker();

    // 상호작용 UI
    const p0 = players[0]; let label="", action=null;
    if(!inConvo && dist(p0, seeker) < 0.85){ label='E: 대화'; action=()=> openRobotConvo(); }
    else{
      const ng = nearestGrave(p0.x, p0.y);
      if(!inConvo && ng.grave && ng.dist < 1.1){
        label='E: 귀 기울이기';
        action=()=>{
          SFX.interact();
          dgTitle.textContent='비석의 기록';
          dgBody.textContent = graveText(ng.grave);
          dgChoices.innerHTML = '';
          dialog.style.display='flex';
        };
      }
    }
    if(action){ btnE.style.display='grid'; btnE.textContent=label; btnE.onclick=action; }
    else { btnE.style.display='none'; btnE.onclick=null; }
  }

  function render(){
    g.clearRect(0,0,game.width,game.height);
    drawBoard();
    drawSeeker();
    for(const p of players) drawPlayer(p);
    // HUD
    g.fillStyle = 'rgba(0,0,0,.55)'; g.fillRect(8,8,64,10);
    g.fillStyle = '#ddd'; g.font = '8px ui-monospace, monospace'; g.fillText('PLAYERS '+players.length, 12, 16);
  }

  // 입력: 키보드 E도 상호작용
  addEventListener('keydown', (e)=>{ if((e.key==='e'||e.key==='E') && btnE.style.display!=='none'){ e.preventDefault(); btnE.click(); } });

  fit(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
