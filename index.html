<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>LIMEN WORKSHOP â€“ Monitorable Sound/Touch Reactive Field</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;}

  /* Hint / Entry */
  #hint{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.72);
    color:#ddd; font-family:system-ui, -apple-system, sans-serif;
    text-align:center; padding:20px;
    z-index:50;
    pointer-events:auto; /* âœ… í˜¹ì‹œ ëª¨ë¥¼ í´ë¦­ ë§‰í˜ ë°©ì§€ */
  }
  #hint .box{
    width:min(720px, 94vw);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:18px 16px;
    background:rgba(0,0,0,.55);
    text-align:left;
  }

  /* Top-left / Top-right buttons */
  #topLeft{
    position:fixed; left:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  #topRight{
    position:fixed; right:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  .iconBtn{
    width:42px; height:42px;
    display:grid; place-items:center;
    background:rgba(0,0,0,.38);
    color:#eee;
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px;
    backdrop-filter: blur(10px);
    cursor:pointer;
    user-select:none;
    font-size:18px;
  }
  .iconBtn:hover{border-color:rgba(255,255,255,.30)}
  .iconBtn:active{transform:translateY(1px)}
  .iconBtn.danger{
    border-color:rgba(255,80,80,.55);
    color:#ffb9b9;
  }
  .iconBtn.danger:hover{border-color:rgba(255,120,120,.75)}

  button, select, input[type="range"], input[type="number"]{
    background:#0f0f0f; color:#eee;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:8px 10px;
    font-weight:650;
    outline:none;
  }
  input[type="range"]{padding:6px 10px;}
  button:hover, select:hover{border-color:rgba(255,255,255,.32)}
  button:disabled, select:disabled{opacity:.5; cursor:not-allowed}

  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0;}
  .label{font-size:12px; color:#aaa; width:132px;}
  .grow{flex:1; min-width:200px;}

  .meter{
    height:10px; border-radius:999px;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .meter > i{
    display:block; height:100%;
    width:0%;
    background:rgba(255,255,255,.85);
  }

  .small{font-size:11px; color:#9aa; line-height:1.45;}
  .mono{
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    color:#bbb;
    white-space:pre-wrap;
    word-break:break-word;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:10px;
    padding:8px;
    max-height:190px;
    overflow:auto;
  }

  .fileLine{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .fileLine input[type="file"]{
    padding:6px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.22);
    color:#ddd;
  }

  /* tiny HUD for touch */
  #touchHUD{
    position:fixed; left:12px; bottom:12px;
    z-index:39;
    color:#ddd;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:8px 10px;
    backdrop-filter: blur(10px);
    pointer-events:none;
  }
  #touchHUD .bar{height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;border:1px solid rgba(255,255,255,.10);margin-top:6px;}
  #touchHUD .bar i{display:block;height:100%;width:0%;background:rgba(255,80,80,.90);}

  /* Entry header */
  .entryTitle{font-weight:900; font-size:16px; margin-bottom:10px;}
  .entryGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  @media (min-width:720px){
    .entryGrid{grid-template-columns: 1fr 1fr;}
  }
  .entryCard{
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px;
    background:rgba(0,0,0,.20);
  }
</style>
</head>
<body>

<!-- ENTRY (ë ‰ ì‹œ ì—¬ê¸°ë¡œ ë˜ëŒì•„ì˜´) -->
<div id="hint">
  <div class="box">
    <div class="entryTitle">LIMEN WORKSHOP â€“ Entry</div>
    <div class="small" style="margin-bottom:12px;">
      1) <b>Start Audio</b>ë¡œ ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œ<br/>
      2) ì—¬ê¸°ì„œ <b>Mic / File</b> ì„ íƒ í›„ <b>Mic ON</b> ë˜ëŠ” <b>Play</b>ë¡œ ì…ì¥<br/>
      3) TouchMeëŠ” ì…ì¥ í›„(ë˜ëŠ” ì§€ê¸ˆë„) âš™ï¸ â†’ íŒì—… ì»¨íŠ¸ë¡¤ íƒ€ì›Œì—ì„œ <b>MIDI Connect / LEARN</b>
    </div>

    <div class="row" style="justify-content:space-between;">
      <div class="row" style="margin:0;">
        <button id="btnStartAudio">Start Audio</button>
        <button id="btnFS">Fullscreen</button>
      </div>
      <div class="small" id="startStatus" style="opacity:.9; margin-left:10px;"></div>
    </div>

    <div class="entryGrid">
      <!-- MIC/FILE ENTRY -->
      <div class="entryCard">
        <div class="row" style="margin-top:0;">
          <div class="label">Input</div>
          <select id="entrySelSrc" class="grow">
            <option value="mic" selected>Mic (Live input)</option>
            <option value="file">File (MP3/WAV)</option>
          </select>
        </div>

        <div id="entryMicBox">
          <div class="row">
            <div class="label">Mic device</div>
            <select id="entrySelMic" class="grow" disabled>
              <option>Start Audio í›„ ëª©ë¡ ë¡œë“œ</option>
            </select>
          </div>
          <div class="row">
            <button id="entryMicOn" class="grow" disabled>Mic ON (Enter)</button>
            <button id="entryMicOff" class="grow" disabled>Mic OFF</button>
          </div>
          <div class="small">Mic ONì„ ëˆ„ë¥´ë©´ Entry í™”ë©´ì´ ë‹«íˆê³ (ì…ì¥) ë¹„ì£¼ì–¼ì´ ì‹œì‘ë©ë‹ˆë‹¤.</div>
        </div>

        <div id="entryFileBox" style="display:none;">
          <div class="row">
            <div class="label">Audio file</div>
            <div class="grow">
              <div class="fileLine">
                <input id="entryFileAudio" type="file" accept="audio/*">
              </div>
              <div class="small" id="entryFileTxt">íŒŒì¼ ì„ íƒ í›„ Playë¡œ ì…ì¥</div>
            </div>
          </div>
          <div class="row">
            <button id="entryFilePlay" class="grow" disabled>Play (Enter)</button>
            <button id="entryFilePause" class="grow" disabled>Pause</button>
            <button id="entryFileStop" class="grow" disabled>Stop</button>
          </div>
        </div>
      </div>

      <!-- QUICK INFO -->
      <div class="entryCard">
        <div class="small" style="margin-bottom:8px;">
          âœ… ë ‰(í”„ë¦¬ì¦ˆ/ê³¼ë¶€í•˜) ê°ì§€ ì‹œ <b>ìë™ìœ¼ë¡œ ì´ Entry í™”ë©´ìœ¼ë¡œ ë˜ëŒì•„ì˜µë‹ˆë‹¤</b>.<br/>
          (í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ì´ ì•„ë‹ˆë¼ â€œì…ì¥ ë‹¨ê³„ë¡œ ë³µê·€â€)
        </div>
        <div class="small" style="margin-bottom:8px;">
          âœ… ì»¨íŠ¸ë¡¤ì€ âš™ï¸ íŒì—…(ì»¨íŠ¸ë¡¤ íƒ€ì›Œ)ì—ì„œ ì¡°ì ˆë©ë‹ˆë‹¤.<br/>
          (ë¹”í”„ë¡œì í„° í’€ìŠ¤í¬ë¦° ë„ì›Œë‘ê³ , ë…¸íŠ¸ë¶ì—ì„œ íŒì—…ìœ¼ë¡œ ì»¨íŠ¸ë¡¤)
        </div>
        <div class="small">
          âœ… ì  ì†ë„ê°€ ëŠë ¤ì§€ë„ë¡ ê¸°ë³¸ê°’/ëª¨ì…˜ ìŠ¬ë¼ì´ë” ë°˜ì˜ë¨.
        </div>
      </div>
    </div>
  </div>
</div>

<canvas id="c"></canvas>

<div id="touchHUD">
  touch: <span id="hudTouch">0.000</span> | amp: <span id="hudAmp">0.000</span><br/>
  <span id="hudMidi">midi: -</span>
  <div class="bar"><i id="hudTouchBar"></i></div>
</div>

<!-- Left top quick -->
<div id="topLeft">
  <div class="iconBtn danger" id="btnReset" title="RESET (Back to Entry)">âŸ²</div>
</div>

<!-- Top right quick -->
<div id="topRight">
  <div class="iconBtn" id="btnGear" title="Control Tower (Popup)">âš™ï¸</div>
  <div class="iconBtn" id="btnMuteQuick" title="Mute">ğŸ”ˆ</div>
  <div class="iconBtn" id="btnFSQuick" title="Fullscreen">â›¶</div>
</div>

<script>
/* ==========================================================
   SETTINGS PERSISTENCE (localStorage)
========================================================== */
const STORE_KEY = "limen_workshop_settings_v4_popup";
function loadSettings(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
function saveSettings(obj){ localStorage.setItem(STORE_KEY, JSON.stringify(obj)); }
let S = loadSettings();

/* main-side helpers */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function startStatus(msg){
  const el = document.getElementById('startStatus');
  if(el) el.textContent = msg;
}
function updateLocal(k,v){ S[k]=v; saveSettings(S); }

/* ==========================================================
   CANVAS / DPR
========================================================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  W = innerWidth|0; H = innerHeight|0;
  canvas.width  = (W*DPR)|0;
  canvas.height = (H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* ==========================================================
   AUDIO CORE + ANALYSER
========================================================== */
let audioCtx;
let analyser, timeData;

let micStream = null;
let inputNode = null;

let masterGain, isMuted=false;

// EQ nodes
let eqLow, eqMid, eqHigh;

// FX nodes
let preGain, driveWS, driveGain, filter, ringOsc, ringGain, ringMult, dL, dR, merger, comp;
let splitter;

let amp=0, ampSmooth=0, ampDelta=0, prevAmp=0;

// file source
let fileAudioEl = null;
let fileNode = null;
let currentSource = S.currentSource ?? "mic"; // "mic" | "file"

function makeWaveshaper(amount=20){
  const n=2048;
  const curve=new Float32Array(n);
  const k=amount;
  for(let i=0;i<n;i++){
    const x = (i*2/n)-1;
    curve[i] = (1+k)*x/(1+k*Math.abs(x));
  }
  return curve;
}

function ensureAudio(){
  if(audioCtx) return;

  audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  timeData = new Uint8Array(analyser.fftSize);

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;

  preGain = audioCtx.createGain(); preGain.gain.value = 1.0;

  // EQ (ê³µìš©)
  eqLow = audioCtx.createBiquadFilter();
  eqLow.type = "lowshelf";
  eqLow.frequency.value = 200;
  eqLow.gain.value = 0;

  eqMid = audioCtx.createBiquadFilter();
  eqMid.type = "peaking";
  eqMid.frequency.value = 1000;
  eqMid.Q.value = 1.0;
  eqMid.gain.value = 0;

  eqHigh = audioCtx.createBiquadFilter();
  eqHigh.type = "highshelf";
  eqHigh.frequency.value = 4000;
  eqHigh.gain.value = 0;

  driveWS = audioCtx.createWaveShaper();
  driveWS.curve = makeWaveshaper(10);
  driveWS.oversample = '4x';
  driveGain = audioCtx.createGain(); driveGain.gain.value = 1.0;

  filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 900;
  filter.Q.value = 2.0;

  ringOsc = audioCtx.createOscillator();
  ringOsc.type = 'sine';
  ringOsc.frequency.value = 35;

  ringGain = audioCtx.createGain();
  ringGain.gain.value = 0.0;

  ringMult = audioCtx.createGain();
  ringMult.gain.value = 1.0;
  ringOsc.connect(ringGain);
  ringGain.connect(ringMult.gain);

  splitter = audioCtx.createChannelSplitter(2);

  dL = audioCtx.createDelay(0.05);
  dR = audioCtx.createDelay(0.05);
  dL.delayTime.value = 0.004;
  dR.delayTime.value = 0.011;

  merger = audioCtx.createChannelMerger(2);

  comp = audioCtx.createDynamicsCompressor();
  comp.threshold.value = -22;
  comp.knee.value = 28;
  comp.ratio.value = 7;
  comp.attack.value = 0.003;
  comp.release.value = 0.14;

  // chain: input â†’ preGain â†’ EQ â†’ drive â†’ filter â†’ ring â†’ widen â†’ comp â†’ analyser â†’ master
  preGain.connect(eqLow);
  eqLow.connect(eqMid);
  eqMid.connect(eqHigh);

  eqHigh.connect(driveWS);
  driveWS.connect(driveGain);
  driveGain.connect(filter);
  filter.connect(ringMult);

  ringMult.connect(splitter);
  splitter.connect(dL, 0);
  splitter.connect(dR, 1);
  dL.connect(merger, 0, 0);
  dR.connect(merger, 0, 1);

  merger.connect(comp);
  comp.connect(analyser);
  analyser.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  ringOsc.start();
}

/* ==========================================================
   PARAM GETTERS (main reads from localStorage S)
========================================================== */
function getMediaGain(){ return clamp(parseFloat(S.rngMediaGain ?? 1.00), 0.2, 3.0); }
function getSens(){ return clamp(parseFloat(S.rngSens ?? 7.0), 1, 12); }
function getGamma(){ return clamp(parseFloat(S.rngGamma ?? 0.72), 0.45, 1.20); }
function getCap(){ return clamp(parseFloat(S.rngCap ?? 0.42), 0.10, 0.70); }

function getEQLow(){ return clamp(parseFloat(S.rngEQLow ?? 0), -20, 20); }
function getEQMid(){ return clamp(parseFloat(S.rngEQMid ?? 0), -20, 20); }
function getEQHigh(){ return clamp(parseFloat(S.rngEQHigh ?? 0), -20, 20); }

function getIdleDrama(){ return clamp(parseFloat(S.rngIdleDrama ?? 0.55), 0, 1); }
function getVisSens(){ return clamp(parseFloat(S.rngVisSens ?? 1.55), 0.6, 2.6); }
function getLineMul(){ return clamp(parseFloat(S.rngLine ?? 0.75), 0.2, 1.2); }
function getPerfLim(){ return clamp(parseFloat(S.rngPerf ?? 0.72), 0.25, 1.0); }
function getFade(){ return clamp(parseFloat(S.rngFade ?? 0.03), 0.02, 0.20); }
function getPointSize(){ return clamp(parseFloat(S.rngPointSize ?? 0.60), 0.4, 1.2); }
function getGlow(){ return clamp(parseFloat(S.rngGlow ?? 0.45), 0.10, 1.0); }
function getPointColor(){
  return ((S.selPointColor ?? "red") === "red") ? "#ff3b3b" : "#ffffff";
}

/* âœ… ì†ë„ ìŠ¬ë¼ì´ë” ì¶”ê°€(ëŠë¦¬ê²Œ) */
function getMotionSpeed(){ return clamp(parseFloat(S.rngMotionSpeed ?? 0.62), 0.25, 1.2); }

/* ==========================================================
   ANALYSIS
========================================================== */
function applyEQ(){
  if(!audioCtx || !eqLow) return;
  eqLow.gain.setTargetAtTime(getEQLow(), audioCtx.currentTime, 0.02);
  eqMid.gain.setTargetAtTime(getEQMid(), audioCtx.currentTime, 0.02);
  eqHigh.gain.setTargetAtTime(getEQHigh(), audioCtx.currentTime, 0.02);
}

function updateAmp(){
  if(!analyser) return;

  analyser.getByteTimeDomainData(timeData);
  let sum=0;
  for(let i=0;i<timeData.length;i++){
    const v=(timeData[i]-128)/128;
    sum+=v*v;
  }
  const rms=Math.sqrt(sum/timeData.length);

  const rmsG = rms * getMediaGain();
  ampSmooth += (rmsG-ampSmooth)*0.12;

  const boosted = Math.pow(Math.max(0, ampSmooth * getSens()), getGamma());
  const scaled = Math.min(getCap(), boosted);

  amp = scaled;
  ampDelta = Math.abs(amp - prevAmp);
  prevAmp = amp;
}

/* ==========================================================
   OUTPUT ROUTING (optional)
========================================================== */
let currentMicDeviceId = S.currentMicDeviceId ?? "default";
let outputSupported = false;

const monitorAudio = new Audio();
monitorAudio.autoplay = true;
monitorAudio.playsInline = true;
let monitorDest = null;

function setupOutputRouting(){
  if(!audioCtx) return;
  if(monitorDest) return;
  monitorDest = audioCtx.createMediaStreamDestination();
  masterGain.connect(monitorDest);
  monitorAudio.srcObject = monitorDest.stream;
}

async function listDevices(){
  let devices = [];
  try{ devices = await navigator.mediaDevices.enumerateDevices(); }catch(e){}

  const mics = devices.filter(d=>d.kind==="audioinput");
  const entrySelMic = document.getElementById('entrySelMic');
  entrySelMic.innerHTML = "";
  if(mics.length===0){
    entrySelMic.disabled = true;
    entrySelMic.innerHTML = `<option>ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ</option>`;
  }else{
    entrySelMic.disabled = false;
    for(const d of mics){
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.textContent = d.label || `Mic (${d.deviceId.slice(0,6)}â€¦)`;
      if(d.deviceId === currentMicDeviceId) opt.selected = true;
      entrySelMic.appendChild(opt);
    }
  }

  outputSupported = typeof monitorAudio.setSinkId === "function";
}

document.getElementById('entrySelMic').addEventListener('change', async (e)=>{
  currentMicDeviceId = e.target.value;
  updateLocal("currentMicDeviceId", currentMicDeviceId);
  if(currentSource==="mic" && micStream) await startMic(currentMicDeviceId, false);
});

/* ==========================================================
   INPUT SOURCE: MIC / FILE
========================================================== */
function disconnectInputs(){
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }
}

async function startMic(deviceId="default", hideEntry=true){
  ensureAudio();
  await audioCtx.resume();
  setupOutputRouting();

  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }

  try{
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: deviceId ? { exact: deviceId } : undefined,
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false
      }
    });

    const src = audioCtx.createMediaStreamSource(micStream);
    inputNode = src;
    src.connect(preGain);

    await listDevices();
    setMicButtons(true);
    startStatus("Mic ON. (Entryì—ì„œ ë°”ë¡œ ì…ì¥ ê°€ëŠ¥)");

    if(hideEntry) hideEntryAndEnter();
  }catch(e){
    console.error(e);
    startStatus("Mic ON ì‹¤íŒ¨. ê¶Œí•œ/ì¥ì¹˜ ì„ íƒ í™•ì¸.");
    alert("ë§ˆì´í¬ ê¶Œí•œ ë˜ëŠ” ì¥ì¹˜ ì„ íƒì— ì‹¤íŒ¨í–ˆì–´ìš”. í¬ë¡¬ ê¶Œí•œ í™•ì¸!");
  }
}

function stopMic(){
  if(micStream){
    micStream.getTracks().forEach(t=>t.stop());
    micStream = null;
  }
  if(inputNode){
    try{ inputNode.disconnect(); }catch(e){}
    inputNode = null;
  }
  setMicButtons(false);
}

function ensureFileAudioEl(){
  if(fileAudioEl) return;
  fileAudioEl = new Audio();
  fileAudioEl.crossOrigin = "anonymous";
  fileAudioEl.loop = true;
  fileAudioEl.preload = "auto";
  fileAudioEl.playsInline = true;
}

function connectFileToChain(){
  ensureAudio();
  ensureFileAudioEl();
  if(!fileAudioEl.src) return;

  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }

  try{
    fileNode = audioCtx.createMediaElementSource(fileAudioEl);
    fileNode.connect(preGain);
  }catch(e){
    try{
      const oldSrc = fileAudioEl.src;
      fileAudioEl.pause();
      fileAudioEl.srcObject = null;
      fileAudioEl = null;
      ensureFileAudioEl();
      fileAudioEl.src = oldSrc;
      fileNode = audioCtx.createMediaElementSource(fileAudioEl);
      fileNode.connect(preGain);
    }catch(err){
      console.error(err);
      alert("íŒŒì¼ ì†ŒìŠ¤ë¥¼ ì˜¤ë””ì˜¤ ì²´ì¸ì— ì—°ê²°í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆì–´ìš”.");
    }
  }
  setMicButtons(false);
}

/* ENTRY <-> ë²„íŠ¼ ìƒíƒœ */
function setMicButtons(micOn){
  document.getElementById('entryMicOn').disabled  = !audioCtx || micOn || (currentSource!=="mic");
  document.getElementById('entryMicOff').disabled = !micOn;
}

/* ==========================================================
   ENTRY UI (Mic/File)
========================================================== */
const entrySelSrc = document.getElementById('entrySelSrc');
const entryMicBox = document.getElementById('entryMicBox');
const entryFileBox = document.getElementById('entryFileBox');

function applySourceUI(){
  currentSource = entrySelSrc.value;
  updateLocal("currentSource", currentSource);

  entryMicBox.style.display = (currentSource==="mic") ? "" : "none";
  entryFileBox.style.display = (currentSource==="file") ? "" : "none";

  setMicButtons(!!micStream);
}
entrySelSrc.value = currentSource;
entrySelSrc.addEventListener('change', ()=>{
  applySourceUI();
  if(currentSource==="file") stopMic();
});
applySourceUI();

/* file controls (entry) */
const entryFileAudio = document.getElementById('entryFileAudio');
const entryFilePlay = document.getElementById('entryFilePlay');
const entryFilePause = document.getElementById('entryFilePause');
const entryFileStop = document.getElementById('entryFileStop');
const entryFileTxt = document.getElementById('entryFileTxt');

function setEntryFileBtns(enabled){
  entryFilePlay.disabled = !enabled;
  entryFilePause.disabled = !enabled;
  entryFileStop.disabled = !enabled;
}
setEntryFileBtns(false);

async function loadFileFromInput(file){
  if(!file) return;

  ensureAudio();
  await audioCtx.resume();
  setupOutputRouting();
  ensureFileAudioEl();

  const url = URL.createObjectURL(file);
  try{ fileAudioEl.pause(); }catch(e){}
  fileAudioEl.src = url;
  fileAudioEl.loop = true;

  entryFileTxt.textContent = `loaded: ${file.name} (${Math.round(file.size/1024)} KB)`;

  if(currentSource!=="file"){
    entrySelSrc.value = "file";
    applySourceUI();
  }

  connectFileToChain();
  setEntryFileBtns(true);
}

entryFileAudio.addEventListener('change', async ()=>{
  const f = entryFileAudio.files && entryFileAudio.files[0];
  if(!f) return;
  await loadFileFromInput(f);
});

/* ==========================================================
   ENTRY ENTER
========================================================== */
function hideEntryAndEnter(){
  document.getElementById('hint').style.display='none';
}
function showEntry(msg=""){
  document.getElementById('hint').style.display='flex';
  if(msg) startStatus(msg);
}

entryFilePlay.addEventListener('click', async ()=>{
  if(!fileAudioEl || !fileAudioEl.src) return;
  ensureAudio(); await audioCtx.resume();
  connectFileToChain();
  try{ await fileAudioEl.play(); }catch(e){
    alert("ì¬ìƒì´ ë§‰í˜”ì–´ìš”. í™”ë©´ì„ í•œë²ˆ í„°ì¹˜/í´ë¦­í•œ ë’¤ ë‹¤ì‹œ Play ëˆŒëŸ¬ì£¼ì„¸ìš”.");
    return;
  }
  hideEntryAndEnter();
});
entryFilePause.addEventListener('click', ()=>{
  if(!fileAudioEl) return;
  try{ fileAudioEl.pause(); }catch(e){}
});
entryFileStop.addEventListener('click', ()=>{
  if(!fileAudioEl) return;
  try{ fileAudioEl.pause(); fileAudioEl.currentTime = 0; }catch(e){}
});

/* ENTRY mic buttons */
document.getElementById('entryMicOn').addEventListener('click', async ()=>{
  if(currentSource!=="mic") return;
  await startMic(currentMicDeviceId, true);
});
document.getElementById('entryMicOff').addEventListener('click', ()=> stopMic());

/* ==========================================================
   âœ… START AUDIO (ì•ˆ ëˆŒë¦¼ ëŒ€ì‘ ê°•í™”)
   - click + pointerdown + touchstart ëª¨ë‘ ì—°ê²°
========================================================== */
async function doStartAudio(){
  try{
    ensureAudio();
    await audioCtx.resume();
    await listDevices();
    startStatus("Audio unlocked. Mic/File ì„ íƒ í›„ Enterë¡œ ì…ì¥!");
    // íŒì—… ì»¨íŠ¸ë¡¤ì„ ì“°ëŠ” êµ¬ì¡°ë¼, MIDI initì€ íŒì—…ì—ì„œ ë²„íŠ¼ìœ¼ë¡œ ì‹¤í–‰
  }catch(e){
    console.error(e);
    startStatus("Audio unlock ì‹¤íŒ¨. í™”ë©´ì„ í•œë²ˆ ë” íƒ­/í´ë¦­ í›„ ì¬ì‹œë„!");
    alert("ì˜¤ë””ì˜¤ ì–¸ë½ì´ ì‹¤íŒ¨í–ˆì–´ìš”. (ë¸Œë¼ìš°ì € ì •ì±…) í™”ë©´ì„ í•œë²ˆ íƒ­/í´ë¦­ í›„ ë‹¤ì‹œ Start Audio!");
  }
}

const btnStartAudio = document.getElementById('btnStartAudio');
btnStartAudio.addEventListener('click', doStartAudio);
btnStartAudio.addEventListener('pointerdown', (e)=>{ e.preventDefault(); doStartAudio(); }, {passive:false});
btnStartAudio.addEventListener('touchstart', (e)=>{ e.preventDefault(); doStartAudio(); }, {passive:false});

/* ê·¸ë˜ë„ ë§‰í˜€ìˆëŠ” í™˜ê²½ì—ì„œ í•œë²ˆì´ë¼ë„ â€œìœ ì € ì œìŠ¤ì²˜â€ë¥¼ ì¡ê¸° */
addEventListener('pointerdown', async ()=>{
  if(audioCtx && audioCtx.state==='suspended'){
    try{ await audioCtx.resume(); }catch(e){}
  }
},{passive:true});

/* ==========================================================
   MUTE / FULLSCREEN
========================================================== */
document.getElementById('btnMuteQuick').addEventListener('click', ()=>{
  if(!audioCtx) return;
  isMuted = !isMuted;
  masterGain.gain.setTargetAtTime(isMuted?0:0.9, audioCtx.currentTime, 0.02);
  document.getElementById('btnMuteQuick').textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”ˆ';
});

function toggleFullscreen(){
  const el = document.documentElement;
  if(!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
}
document.getElementById('btnFS').addEventListener('click', toggleFullscreen);
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

/* ==========================================================
   MIDI / Touch (main receives mapped touch from popup via localStorage)
   - íŒì—…ì´ MIDI ì…ë ¥ì„ ë°›ì•„ì„œ S.touchFromMIDI (0..1) ê°’ì„ localStorageì— ê¸°ë¡
   - ë©”ì¸ì€ storage ì´ë²¤íŠ¸ë¡œ S ê°±ì‹  â†’ touchSmooth ì—…ë°ì´íŠ¸
========================================================== */
let touchRaw = 0;
let touch = 0;
let touchSmooth = 0;
let lastMidiAt = 0;

function updateTouch(){
  // popupì—ì„œ ë„˜ì–´ì˜¨ ê°’ ìš°ì„ 
  const v = clamp(parseFloat(S.touchFromMIDI ?? 0), 0, 1);
  touch = v;

  // smoothing
  const k = clamp(parseFloat(S.rngMIDISmooth ?? 0.22), 0.02, 0.50);
  touchSmooth += (touch - touchSmooth) * k;

  const now = performance.now();
  const idleMs = now - lastMidiAt;
  if(v > 0.0001) lastMidiAt = now;
  if(idleMs > 250){
    // ìì—° ê°ì‡ (íŒì—…ì—ì„œ ê°’ì´ 0ì´ ë˜ì–´ë„ ì”í–¥ì²˜ëŸ¼)
    touchSmooth *= 0.985;
  }
}

/* ==========================================================
   âœ… TOUCH FX PRESET (5ê°œ)
========================================================== */
function getFXPreset(){
  return (S.selFXPreset ?? "digital"); // digital | piano | bell | pad | pluck
}
function applyFX(){
  if(!audioCtx) return;

  const sim = clamp(parseFloat(S.rngSimTouch ?? 0), 0, 1);
  const t = Math.max(touchSmooth, sim);
  const preset = getFXPreset();

  // ê³µí†µ: ì‚´ì§ í”ë“¤ë¦¬ëŠ” ìŠ¤í…Œë ˆì˜¤
  const wob = (Math.sin(performance.now()*0.0014)*0.5+0.5);

  // presetë³„ ê¸°ë³¸ ì„±ê²©
  let driveMin=8, driveMax=105;
  let preMin=0.85, preMax=2.10;
  let dgMin=0.95, dgMax=2.05;

  let fType="bandpass";
  let fMin=160, fMax=7200, qMin=1.0, qMax=18.0;

  let ringMin=8, ringMax=360, ringDepth=0.95;

  let dlMin=0.0015, dlMax=0.014, drMin=0.0040, drMax=0.020;

  if(preset==="piano"){
    // ë”°ëœ»í•˜ê³  ëœ ìš°ìš¸: ê³¼í•œ ë§/ì™œê³¡ ì¤„ì´ê³ , ë¡œìš°íŒ¨ìŠ¤ ê¸°ë°˜ â€œí†¤â€ ëŠë‚Œ
    driveMin=6; driveMax=28;
    preMin=0.95; preMax=1.45;
    dgMin=0.85; dgMax=1.25;

    fType="lowpass";
    fMin=700; fMax=5200;
    qMin=0.55; qMax=2.2;

    ringMin=0; ringMax=90; ringDepth=0.20;

    dlMin=0.0020; dlMax=0.010;
    drMin=0.0042; drMax=0.013;
  }
  else if(preset==="bell"){
    // ë§‘ì€ ë²¨/ê¸€ë¼ì‹œ: í•˜ì´ìª½, ë§ ë” ê°•í•˜ê²Œ
    driveMin=10; driveMax=55;
    preMin=0.85; preMax=1.65;
    dgMin=1.00; dgMax=1.75;

    fType="bandpass";
    fMin=900; fMax=8600;
    qMin=2.0; qMax=22.0;

    ringMin=40; ringMax=620; ringDepth=0.85;

    dlMin=0.0010; dlMax=0.018;
    drMin=0.0035; drMax=0.026;
  }
  else if(preset==="pad"){
    // ì†Œí”„íŠ¸ íŒ¨ë“œ: ë¡œìš°íŒ¨ìŠ¤+ë„“ì€ ìŠ¤í…Œë ˆì˜¤, ë¶€ë“œëŸ¬ìš´ ì™œê³¡
    driveMin=6; driveMax=38;
    preMin=0.90; preMax=1.70;
    dgMin=0.90; dgMax=1.35;

    fType="lowpass";
    fMin=450; fMax=3600;
    qMin=0.50; qMax=1.6;

    ringMin=0; ringMax=70; ringDepth=0.14;

    dlMin=0.0040; dlMax=0.020;
    drMin=0.0065; drMax=0.030;
  }
  else if(preset==="pluck"){
    // í¼ì»¤ì‹œë¸Œ/í”ŒëŸ­: ë°´ë“œíŒ¨ìŠ¤ Q ë†’ê²Œ, í€ì¹˜/ì§§ì€ ë§
    driveMin=12; driveMax=80;
    preMin=0.80; preMax=2.15;
    dgMin=1.00; dgMax=2.10;

    fType="bandpass";
    fMin=220; fMax=5200;
    qMin=2.5; qMax=26.0;

    ringMin=8; ringMax=260; ringDepth=0.55;

    dlMin=0.0012; dlMax=0.012;
    drMin=0.0032; drMax=0.016;
  }
  // digital = ê¸°ì¡´ ëŠë‚Œ(ê°•í•¨)

  const driveAmt = driveMin + t*(driveMax-driveMin);
  driveWS.curve = makeWaveshaper(driveAmt);

  preGain.gain.setTargetAtTime(preMin + t*(preMax-preMin), audioCtx.currentTime, 0.03);
  driveGain.gain.setTargetAtTime(dgMin + t*(dgMax-dgMin), audioCtx.currentTime, 0.03);

  filter.type = fType;
  const f = fMin + Math.pow(t, 1.20) * (fMax-fMin);
  const q = qMin + t*(qMax-qMin);
  filter.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.03);
  filter.Q.setTargetAtTime(q, audioCtx.currentTime, 0.03);

  const ringHz = ringMin + t*(ringMax-ringMin);
  ringOsc.frequency.setTargetAtTime(ringHz, audioCtx.currentTime, 0.03);
  ringGain.gain.setTargetAtTime(t*ringDepth, audioCtx.currentTime, 0.03);

  const dl = dlMin + t*(dlMax-dlMin) + wob*0.0011;
  const dr = drMin + t*(drMax-drMin) + (1-wob)*0.0013;
  dL.delayTime.setTargetAtTime(dl, audioCtx.currentTime, 0.05);
  dR.delayTime.setTargetAtTime(dr, audioCtx.currentTime, 0.05);
}

/* ==========================================================
   VISUAL FIELD
========================================================== */
let N = parseInt(S.selN ?? 220, 10);
let pts = [];
let rot = 0;

const BASE_QUIET_TH = 0.0032;
const BASE_ACTIVE_TH = 0.0065;
const BASE_ONSET_TH  = 0.0060;

let energy = 0;
let burstEnergy = 0;

function initPoints(){
  pts = [];
  for(let i=0;i<N;i++){
    pts.push({
      x:(Math.random()*2-1)*(W*0.34),
      y:(Math.random()*2-1)*(H*0.34),
      z:(Math.random()*2-1)*340,
      vx:0,vy:0,vz:0
    });
  }
}
initPoints();

function project(p){
  const s=Math.sin(rot), c=Math.cos(rot);
  const x = p.x*c - p.z*s;
  const z = p.x*s + p.z*c;
  const depth = 900;
  const k = depth/(depth+z);
  return { x:x*k + W/2, y:p.y*k + H/2, k, z };
}

function applyBounds(p, mode){
  if(mode==="wrap"){
    const maxX=W*0.65, maxY=H*0.65, maxZ=560;
    if(p.x> maxX) p.x=-maxX;
    if(p.x<-maxX) p.x= maxX;
    if(p.y> maxY) p.y=-maxY;
    if(p.y<-maxY) p.y= maxY;
    if(p.z> maxZ) p.z=-maxZ;
    if(p.z<-maxZ) p.z= maxZ;
    return;
  }

  const maxX=W*0.58, maxY=H*0.58, maxZ=560;

  if(mode==="bounce"){
    if(p.x> maxX){ p.x=maxX; p.vx*=-0.7; }
    if(p.x<-maxX){ p.x=-maxX; p.vx*=-0.7; }
    if(p.y> maxY){ p.y=maxY; p.vy*=-0.7; }
    if(p.y<-maxY){ p.y=-maxY; p.vy*=-0.7; }
    if(p.z> maxZ){ p.z=maxZ; p.vz*=-0.7; }
    if(p.z<-maxZ){ p.z=-maxZ; p.vz*=-0.7; }
    return;
  }

  const pull = 0.0026;
  const edgeX = Math.max(0, Math.abs(p.x) - maxX);
  const edgeY = Math.max(0, Math.abs(p.y) - maxY);
  const edgeZ = Math.max(0, Math.abs(p.z) - maxZ);
  if(edgeX>0) p.vx += (-Math.sign(p.x)) * edgeX * pull;
  if(edgeY>0) p.vy += (-Math.sign(p.y)) * edgeY * pull;
  if(edgeZ>0) p.vz += (-Math.sign(p.z)) * edgeZ * pull;
}

/* ==========================================================
   ENTRY REBOOT (same concept)
========================================================== */
function clearRuntime(){
  amp = 0; ampSmooth = 0; ampDelta = 0; prevAmp = 0;
  touchRaw = 0; touch = 0; touchSmooth = 0; lastMidiAt = 0;
  energy = 0; burstEnergy = 0; rot = 0;
  initPoints();

  document.getElementById('hudMidi').textContent = "midi: -";
  document.getElementById('hudTouch').textContent = "0.000";
  document.getElementById('hudAmp').textContent = "0.000";
  document.getElementById('hudTouchBar').style.width = "0%";

  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,W,H);
}

async function entryReboot(reason="lag"){
  console.warn("ENTRY REBOOT:", reason);

  try{ stopMic(); }catch(e){}
  try{
    if(fileAudioEl){
      try{ fileAudioEl.pause(); }catch(e){}
    }
  }catch(e){}

  try{ disconnectInputs(); }catch(e){}
  fileNode = null;
  inputNode = null;

  try{
    if(audioCtx){
      try{ await audioCtx.close(); }catch(e){}
    }
  }catch(e){}
  audioCtx = null;
  analyser = null;
  timeData = null;
  masterGain = null;
  preGain = null;
  eqLow = eqMid = eqHigh = null;
  driveWS = driveGain = null;
  filter = null;
  ringOsc = null;
  ringGain = null;
  ringMult = null;
  splitter = null;
  dL = dR = null;
  merger = null;
  comp = null;
  monitorDest = null;

  clearRuntime();

  document.getElementById('entrySelMic').disabled = true;
  document.getElementById('entrySelMic').innerHTML = `<option>Start Audio í›„ ëª©ë¡ ë¡œë“œ</option>`;
  document.getElementById('entryMicOn').disabled = true;
  document.getElementById('entryMicOff').disabled = true;

  showEntry(`ë ‰ ê°ì§€ â†’ Entryë¡œ ë³µê·€ (reason: ${reason})`);
}

document.getElementById("btnReset").addEventListener("click", ()=> entryReboot("manual reset"));

/* ==========================================================
   AUTO REBOOT ON LAG / FREEZE
========================================================== */
function autoRebootEnabled(){ return (String(S.selAutoReboot ?? "1") === "1"); }

let lastFrameT = performance.now();
let frameMsSmooth = 16.7;
let lagTimer = 0;

let lastAnimTick = performance.now();
setInterval(()=>{
  const now = performance.now();
  if(!autoRebootEnabled()) return;
  if(now - lastAnimTick > 1600){
    entryReboot("freeze watchdog");
    lastAnimTick = now;
  }
}, 400);

function checkLag(dt){
  if(!autoRebootEnabled()) return;
  if(dt > 45){
    lagTimer += dt;
    if(lagTimer > 2200){
      entryReboot("lag reboot");
      lagTimer = 0;
    }
  }else{
    lagTimer = Math.max(0, lagTimer - 50);
  }
}

/* ==========================================================
   MAIN LOOP
========================================================== */
let lastUiT = 0;

function loop(){
  const now = performance.now();
  lastAnimTick = now;

  const dt = now - lastFrameT;
  lastFrameT = now;
  frameMsSmooth += (dt - frameMsSmooth) * 0.08;

  checkLag(dt);

  let qAuto = 1 - Math.max(0, (frameMsSmooth - 16) / 45);
  qAuto = clamp(qAuto, 0.28, 1);
  const q = Math.min(qAuto, getPerfLim());

  ctx.fillStyle = `rgba(0,0,0,${getFade().toFixed(3)})`;
  ctx.fillRect(0,0,W,H);

  if(audioCtx){
    applyEQ();
    updateAmp();
  }else{
    amp = 0; ampDelta = 0;
  }

  updateTouch();
  if(audioCtx) applyFX();

  if(now - lastUiT > 110){
    lastUiT = now;

    const tv = Math.max(touchSmooth, clamp(parseFloat(S.rngSimTouch ?? 0),0,1));
    document.getElementById('hudTouch').textContent = tv.toFixed(3);
    document.getElementById('hudAmp').textContent = amp.toFixed(3);
    document.getElementById('hudMidi').textContent = "midi: popup";
    document.getElementById('hudTouchBar').style.width = (tv*100).toFixed(1)+"%";
  }

  const visSens = getVisSens();
  const idleDrama = getIdleDrama();

  const QUIET_TH = BASE_QUIET_TH / visSens;
  const ACTIVE_TH = BASE_ACTIVE_TH / visSens;
  const ONSET_TH  = BASE_ONSET_TH / visSens;

  const targetEnergy = (amp > ACTIVE_TH) ? 1 : (amp < QUIET_TH ? 0 : energy);
  energy += (targetEnergy - energy) * 0.05;

  const energyFloor = 0.04 + idleDrama * 0.20;
  energy = Math.max(energyFloor, energy);

  const onset = Math.max(0, (ampDelta - ONSET_TH));
  burstEnergy += (onset*8.0 - burstEnergy) * 0.12;
  burstEnergy *= 0.92;
  burstEnergy = Math.min(1.5, burstEnergy);

  const mode = (S.selMode ?? "pulse");
  const boundsMode = (S.selBounds ?? "soft");
  const quietLines = parseInt(S.selQuietLines ?? "1",10);

  const t = now*0.001;
  const breathe = 0.5 + 0.5*Math.sin(t*1.2);

  const sim = clamp(parseFloat(S.rngSimTouch ?? 0),0,1);
  const touchV = Math.max(touchSmooth, sim);

  /* âœ… ì†ë„ ì „ì²´ ëŠë¦¬ê²Œ: MotionSpeed ê³± */
  const motion = getMotionSpeed();

  const baseSpeedQuiet = (0.10 + idleDrama*0.05) * motion * 0.72;
  const baseChaosQuiet = (0.55 + idleDrama*1.10) * 0.85;

  const baseSpeedActive = ((0.12 + Math.min(0.30, amp*2.6)) * visSens) * motion * 0.70;

  const baseChaosActive =
    Math.min(30,
      (ampDelta*110) +
      (touchV*120) +
      burstEnergy*55
    ) * visSens * 0.92;

  let speed = baseSpeedQuiet*(1-energy) + baseSpeedActive*energy;
  let chaos = baseChaosQuiet*(1-energy) + baseChaosActive*energy;

  if(mode==="calm"){ speed *= 0.88; chaos *= 0.75; }
  if(mode==="burst"){ speed *= 1.05; chaos *= 1.18; }

  const lineMul = getLineMul();
  const linkDistQuiet = 26 + idleDrama*10;
  const linkDistActiveRaw = (64 + amp*240 + touchV*520 + burstEnergy*110) * lineMul * visSens;
  const linkDistActive = Math.min(180, linkDistActiveRaw);
  const linkDist = linkDistQuiet*(1-energy) + linkDistActive*energy;

  const centerPull = (0.008 + touchV*0.028) * (1.0 - Math.min(1, amp*1.2)) * (0.75 + idleDrama*0.6);
  const burst = (amp*0.017 + ampDelta*0.060 + touchV*0.020 + burstEnergy*0.020) * visSens;

  const freeze = energy * Math.max(0, 1 - (ampDelta*20));
  const rotSpeedBase = (0.0012 + energy*0.010 + burstEnergy*0.008 + touchV*0.010) * (1 - 0.7*freeze);
  const rotSpeed = rotSpeedBase * (0.65 + idleDrama*0.8) * motion * 0.82;
  rot += rotSpeed;

  const scale = 1.0 + energy*(breathe-0.5)*0.25;

  for(const p of pts){
    p.vx += (Math.random()-0.5)*chaos;
    p.vy += (Math.random()-0.5)*chaos;
    p.vz += (Math.random()-0.5)*chaos*0.55;

    p.vx += (-p.x)*centerPull*(0.9 - energy*0.4);
    p.vy += (-p.y)*centerPull*(0.9 - energy*0.4);
    p.vz += (-p.z)*centerPull*(0.6 - energy*0.2);

    p.vx += (p.x)*burst*energy;
    p.vy += (p.y)*burst*energy;
    p.vz += (p.z)*burst*energy*0.6;

    p.vx *= 0.90 - energy*0.05;
    p.vy *= 0.90 - energy*0.05;
    p.vz *= 0.92 - energy*0.04;

    p.x = (p.x + p.vx*speed) * scale + (1-scale)*p.x;
    p.y = (p.y + p.vy*speed) * scale + (1-scale)*p.y;
    p.z = (p.z + p.vz*speed) * (0.92 + 0.08*scale) + (1-(0.92 + 0.08*scale))*p.z;

    applyBounds(p, boundsMode);
  }

  const pr = pts.map(project);

  if(energy > 0.05 || quietLines>0){
    const cell = Math.max(22, Math.floor(linkDist));
    const inv = 1 / cell;
    const grid = new Map();

    for(let i=0;i<N;i++){
      const a = pr[i];
      const cx = (a.x*inv)|0;
      const cy = (a.y*inv)|0;
      const key = (cx<<16) ^ (cy & 0xffff);
      let arr = grid.get(key);
      if(!arr){ arr=[]; grid.set(key, arr); }
      arr.push(i);
    }

    const baseMax = (1100 + energy*850 + burstEnergy*750 + touchV*700) * lineMul;
    const maxLines = Math.floor(baseMax * q);

    let linesDrawn = 0;
    const stride = (q < 0.45) ? 2 : 1;

    for(let i=0;i<N;i+=stride){
      if(linesDrawn >= maxLines) break;
      const a = pr[i];
      const cx = (a.x*inv)|0;
      const cy = (a.y*inv)|0;

      for(let oy=-1; oy<=1; oy++){
        for(let ox=-1; ox<=1; ox++){
          if(linesDrawn >= maxLines) break;

          const k = ((cx+ox)<<16) ^ ((cy+oy) & 0xffff);
          const bucket = grid.get(k);
          if(!bucket) continue;

          for(let bi=0; bi<bucket.length; bi++){
            const j = bucket[bi];
            if(j<=i) continue;

            const b = pr[j];
            const dx=a.x-b.x, dy=a.y-b.y;
            const d = Math.hypot(dx,dy);
            if(d<linkDist){
              const alpha = 1 - d/linkDist;

              const quietGain = (quietLines===0) ? 0 : (quietLines===1 ? 0.12 : 0.24);
              const onGain = 0.34 + amp*1.5*visSens + burstEnergy*1.6*visSens + touchV*1.4;
              const punch = Math.min(1, alpha * (quietGain*(1-energy) + onGain*energy));

              ctx.globalAlpha = punch * getGlow();
              ctx.strokeStyle = "rgba(255,255,255,0.9)";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(a.x,a.y);
              ctx.lineTo(b.x,b.y);
              ctx.stroke();

              linesDrawn++;
              if(linesDrawn >= maxLines) break;
            }
          }
        }
      }
    }
  }

  const glow = getGlow();
  const pSize = getPointSize();
  const pCol = getPointColor();

  for(let i=0;i<N;i++){
    const p = pr[i];

    const baseR = (0.6 + p.k*0.3) * pSize;
    const rQuiet = Math.max(0.9, baseR * (1.05 + idleDrama*0.15));
    const rActive = baseR * (1.15 + amp*2.2*visSens + touchV*1.6 + burstEnergy*0.9);
    const r = rQuiet*(1-energy) + rActive*energy;

    const aQuiet = 0.32 + idleDrama*0.12;
    const aActive = Math.min(1, 0.40 + amp*0.95*visSens + touchV*0.65 + burstEnergy*0.60);
    const a = aQuiet*(1-energy) + aActive*energy;

    ctx.globalAlpha = a * glow;
    ctx.fillStyle = pCol;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  requestAnimationFrame(loop);
}
loop();

/* ==========================================================
   POPUP CONTROL TOWER
   - íŒì—…ì—ì„œ localStorage(STORE_KEY) ìˆ˜ì •
   - ë©”ì¸ì€ storage ì´ë²¤íŠ¸ë¡œ ì‹¤ì‹œê°„ ë°˜ì˜
========================================================== */
function openControlTower(){
  const w = window.open("", "LIMEN_CONTROL_TOWER", "width=560,height=860,resizable=yes,scrollbars=yes");
  if(!w){
    alert("íŒì—…ì´ ì°¨ë‹¨ëì–´ìš”. ë¸Œë¼ìš°ì €ì—ì„œ íŒì—… í—ˆìš© í›„ ë‹¤ì‹œ âš™ï¸ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.");
    return;
  }
  const safeS = loadSettings();

  w.document.open();
  w.document.write(`
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>LIMEN â€“ Control Tower</title>
<style>
  body{margin:0;background:#0b0b0b;color:#ddd;font-family:system-ui,-apple-system,sans-serif;}
  header{position:sticky;top:0;background:rgba(0,0,0,.75);backdrop-filter:blur(10px);border-bottom:1px solid rgba(255,255,255,.10);padding:12px 14px;z-index:5}
  .title{font-weight:900}
  .sub{font-size:12px;color:#9aa;margin-top:4px;line-height:1.4}
  main{padding:14px}
  .card{border:1px solid rgba(255,255,255,.10);border-radius:14px;background:rgba(255,255,255,.04);padding:12px;margin:10px 0}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
  .label{width:160px;color:#aaa;font-size:12px}
  .grow{flex:1;min-width:220px}
  input[type=range],select,button{background:#111;color:#eee;border:1px solid rgba(255,255,255,.16);border-radius:10px;padding:8px 10px;font-weight:700}
  input[type=range]{padding:6px 10px;width:100%}
  button{cursor:pointer}
  button:hover,select:hover{border-color:rgba(255,255,255,.32)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:11px;color:#bbb}
  .pill{display:inline-block;padding:6px 10px;border:1px solid rgba(255,255,255,.12);border-radius:999px;background:rgba(0,0,0,.35);font-size:12px;color:#bbb}
</style>
</head>
<body>
<header>
  <div class="title">LIMEN â€“ Control Tower</div>
  <div class="sub">
    ì´ íŒì—…ì—ì„œ ì¡°ì ˆí•˜ë©´ ë©”ì¸ í™”ë©´(ë¹”í”„ë¡œì í„°)ë¡œ ì¦‰ì‹œ ë°˜ì˜ë©ë‹ˆë‹¤.<br/>
    MIDIëŠ” ì—¬ê¸°ì—ì„œ Connect/LEARN í•˜ì„¸ìš”.
  </div>
</header>

<main>
  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="pill">localStorage sync</div>
      <button id="btnResetTouch" title="touch value reset">touch reset</button>
    </div>
    <div class="mono" id="dbg"></div>
  </div>

  <div class="card">
    <div class="row"><div class="label">Touch FX Preset</div>
      <select id="selFXPreset" class="grow">
        <option value="digital">1) Digital Glitch (current vibe)</option>
        <option value="piano">2) Warm Piano-ish (ëœ ìš°ìš¸, ë”°ëœ»)</option>
        <option value="bell">3) Bright Bell / Glass</option>
        <option value="pad">4) Soft Pad / Air</option>
        <option value="pluck">5) Percussive Pluck</option>
      </select>
    </div>

    <div class="row"><div class="label">Sim Touch (test)</div>
      <div class="grow">
        <input id="rngSimTouch" type="range" min="0" max="1" step="0.001">
        <div class="mono" id="txtSimTouch"></div>
      </div>
    </div>

    <div class="row"><div class="label">MIDI Smooth</div>
      <div class="grow">
        <input id="rngMIDISmooth" type="range" min="0.02" max="0.50" step="0.01">
        <div class="mono" id="txtMIDISmooth"></div>
      </div>
    </div>

    <div class="row">
      <button id="btnMIDIInit" class="grow">Connect MIDI (WebMIDI)</button>
      <button id="btnLearn" class="grow">LEARN</button>
    </div>
    <div class="mono" id="midiStatus">midi: -</div>
    <div class="mono" id="midiLast">last: -</div>
  </div>

  <div class="card">
    <div class="row"><div class="label">Motion Speed (slower)</div>
      <div class="grow">
        <input id="rngMotionSpeed" type="range" min="0.25" max="1.2" step="0.01">
        <div class="mono" id="txtMotionSpeed"></div>
      </div>
    </div>
    <div class="row"><div class="label">Idle Drama</div>
      <div class="grow"><input id="rngIdleDrama" type="range" min="0" max="1" step="0.01"><div class="mono" id="txtIdleDrama"></div></div>
    </div>
    <div class="row"><div class="label">Visual Sens</div>
      <div class="grow"><input id="rngVisSens" type="range" min="0.6" max="2.6" step="0.01"><div class="mono" id="txtVisSens"></div></div>
    </div>
    <div class="row"><div class="label">Line density</div>
      <div class="grow"><input id="rngLine" type="range" min="0.2" max="1.2" step="0.01"><div class="mono" id="txtLine"></div></div>
    </div>
    <div class="row"><div class="label">Perf limit</div>
      <div class="grow"><input id="rngPerf" type="range" min="0.25" max="1" step="0.01"><div class="mono" id="txtPerf"></div></div>
    </div>
    <div class="row"><div class="label">BG fade</div>
      <div class="grow"><input id="rngFade" type="range" min="0.02" max="0.20" step="0.005"><div class="mono" id="txtFade"></div></div>
    </div>
    <div class="row"><div class="label">Point size</div>
      <div class="grow"><input id="rngPointSize" type="range" min="0.4" max="1.2" step="0.01"><div class="mono" id="txtPointSize"></div></div>
    </div>
    <div class="row"><div class="label">Glow</div>
      <div class="grow"><input id="rngGlow" type="range" min="0.10" max="1.0" step="0.01"><div class="mono" id="txtGlow"></div></div>
    </div>
  </div>

  <div class="card">
    <div class="row"><div class="label">Media Gain</div>
      <div class="grow"><input id="rngMediaGain" type="range" min="0.2" max="3.0" step="0.01"><div class="mono" id="txtMediaGain"></div></div>
    </div>
    <div class="row"><div class="label">Analysis Sens</div>
      <div class="grow"><input id="rngSens" type="range" min="1" max="12" step="0.1"><div class="mono" id="txtSens"></div></div>
    </div>
    <div class="row"><div class="label">Gamma</div>
      <div class="grow"><input id="rngGamma" type="range" min="0.45" max="1.20" step="0.01"><div class="mono" id="txtGamma"></div></div>
    </div>
    <div class="row"><div class="label">Amp cap</div>
      <div class="grow"><input id="rngCap" type="range" min="0.10" max="0.70" step="0.01"><div class="mono" id="txtCap"></div></div>
    </div>
    <div class="row"><div class="label">EQ Low (200Hz)</div>
      <div class="grow"><input id="rngEQLow" type="range" min="-20" max="20" step="0.5"><div class="mono" id="txtEQLow"></div></div>
    </div>
    <div class="row"><div class="label">EQ Mid (1kHz)</div>
      <div class="grow"><input id="rngEQMid" type="range" min="-20" max="20" step="0.5"><div class="mono" id="txtEQMid"></div></div>
    </div>
    <div class="row"><div class="label">EQ High (4kHz)</div>
      <div class="grow"><input id="rngEQHigh" type="range" min="-20" max="20" step="0.5"><div class="mono" id="txtEQHigh"></div></div>
    </div>
  </div>

  <div class="card">
    <div class="row"><div class="label">Auto Reboot</div>
      <select id="selAutoReboot" class="grow">
        <option value="1">ON (lag/freeze â†’ ENTRY)</option>
        <option value="0">OFF</option>
      </select>
    </div>
  </div>
</main>

<script>
const STORE_KEY = ${JSON.stringify(STORE_KEY)};
function load(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
function save(S){ localStorage.setItem(STORE_KEY, JSON.stringify(S)); }
let S = load();

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function bindRange(id, fallback, fmt){
  const el = document.getElementById(id);
  el.value = (S[id] ?? fallback);
  const txt = document.getElementById("txt"+id.slice(3));
  const update = ()=>{
    S[id] = parseFloat(el.value);
    save(S);
    if(txt) txt.textContent = fmt(S[id]);
  };
  el.addEventListener("input", update);
  update();
}
function bindSelect(id, fallback){
  const el = document.getElementById(id);
  el.value = (S[id] ?? fallback);
  const update = ()=>{
    S[id] = el.value;
    save(S);
  };
  el.addEventListener("change", update);
  update();
}
function dbg(){
  const d = document.getElementById("dbg");
  const preset = S.selFXPreset ?? "digital";
  d.textContent =
    "preset=" + preset + "\\n" +
    "touchFromMIDI=" + (S.touchFromMIDI ?? 0) + "\\n" +
    "simTouch=" + (S.rngSimTouch ?? 0) + "\\n";
}
window.addEventListener("storage", (e)=>{
  if(e.key===STORE_KEY){ S = load(); syncUI(); dbg(); }
});

bindSelect("selFXPreset","digital");
bindRange("rngSimTouch", 0, v=>"sim: "+v.toFixed(3));
bindRange("rngMIDISmooth", 0.22, v=>"smooth: "+v.toFixed(2));

bindRange("rngMotionSpeed", 0.62, v=>"motion: "+v.toFixed(2)+"Ã—");
bindRange("rngIdleDrama", 0.55, v=>"idle: "+v.toFixed(2));
bindRange("rngVisSens", 1.55, v=>"sens: "+v.toFixed(2)+"Ã—");
bindRange("rngLine", 0.75, v=>"line: "+v.toFixed(2)+"Ã—");
bindRange("rngPerf", 0.72, v=>"perf: "+v.toFixed(2));
bindRange("rngFade", 0.03, v=>"fade: "+v.toFixed(3));
bindRange("rngPointSize", 0.60, v=>"size: "+v.toFixed(2)+"Ã—");
bindRange("rngGlow", 0.45, v=>"glow: "+v.toFixed(2)+"Ã—");

bindRange("rngMediaGain", 1.00, v=>"gain: "+v.toFixed(2)+"Ã—");
bindRange("rngSens", 7.0, v=>"analysis: "+v.toFixed(1)+"Ã—");
bindRange("rngGamma", 0.72, v=>"gamma: "+v.toFixed(2));
bindRange("rngCap", 0.42, v=>"cap: "+v.toFixed(2));
bindRange("rngEQLow", 0, v=>"low: "+v.toFixed(1)+" dB");
bindRange("rngEQMid", 0, v=>"mid: "+v.toFixed(1)+" dB");
bindRange("rngEQHigh", 0, v=>"high: "+v.toFixed(1)+" dB");

bindSelect("selAutoReboot","1");

document.getElementById("btnResetTouch").addEventListener("click", ()=>{
  S.touchFromMIDI = 0;
  save(S);
  dbg();
});

/* ---------- WebMIDI ---------- */
let midiAccess=null, midiInput=null;
let learn=false;

const midiStatus = document.getElementById("midiStatus");
const midiLast = document.getElementById("midiLast");
const btnLearn = document.getElementById("btnLearn");

function setLearn(on){
  learn=on;
  btnLearn.textContent = on ? "LEARN (ON)" : "LEARN";
}

function parseRaw(data){
  const st = data[0] & 0xF0;
  const ch = data[0] & 0x0F;
  const d1 = data[1] ?? 0;
  const d2 = data[2] ?? 0;
  return {st,ch,d1,d2};
}

function attachInput(inp){
  if(midiInput) midiInput.onmidimessage=null;
  midiInput=inp;
  midiStatus.textContent = "midi: "+(inp.name||"input");
  inp.onmidimessage = (e)=>{
    const r = parseRaw(e.data);
    midiLast.textContent = "last: st=0x"+r.st.toString(16)+" ch="+(r.ch+1)+" d1="+r.d1+" d2="+r.d2;

    // learn: CCë©´ d1 ì €ì¥, NOTEë©´ note# ì €ì¥
    if(learn){
      if(r.st===0xB0){
        S.selMIDIType="cc"; S.numMIDINum=r.d1; S.selMIDICh=String(r.ch);
        save(S); setLearn(false);
      }else if(r.st===0x90 || r.st===0x80){
        S.selMIDIType="note"; S.numMIDINum=r.d1; S.selMIDICh=String(r.ch);
        save(S); setLearn(false);
      }
    }

    // mapping: stored mapping ì—†ìœ¼ë©´ ê·¸ëƒ¥ CCëŠ” raw/127, noteëŠ” vel/127
    const mode = S.selMIDIType ?? "cc";
    const num = parseInt(S.numMIDINum ?? 1,10);
    const wantCh = parseInt(S.selMIDICh ?? "-1",10);

    if(wantCh !== -1 && r.ch !== wantCh) return;

    let raw01=null;
    if(mode==="cc"){
      if(r.st!==0xB0 || r.d1!==num) return;
      raw01 = r.d2/127;
    }else{
      if((r.st!==0x90 && r.st!==0x80) || r.d1!==num) return;
      raw01 = ((r.st===0x80)?0:r.d2)/127;
    }

    // shaping: deadzone/gain/curve/invert
    let x = clamp(raw01,0,1);
    const inv = (S.selMIDIInvert ?? "0")==="1";
    if(inv) x = 1-x;

    const dead = clamp(parseFloat(S.rngMIDIDead ?? 0.02), 0, 0.25);
    if(x < dead) x = 0; else x = (x-dead)/(1-dead);

    x *= clamp(parseFloat(S.rngMIDIGain ?? 1.60), 0.3, 3.0);
    x = clamp(x,0,1);

    const curve = clamp(parseFloat(S.rngMIDICurve ?? 0.85), 0.4, 2.8);
    x = Math.pow(x, curve);
    x = clamp(x,0,1);

    S.touchFromMIDI = x;
    save(S);
    dbg();
  };
}

async function initMIDI(){
  if(!navigator.requestMIDIAccess){
    midiStatus.textContent="midi: not supported (use Sim Touch)";
    return;
  }
  try{
    midiAccess = await navigator.requestMIDIAccess({sysex:false});
    const inputs = [...midiAccess.inputs.values()];
    if(inputs.length===0){
      midiStatus.textContent="midi: no inputs";
      return;
    }
    // attach first input or saved
    const savedName = S.midiInputName ?? "";
    let pick = inputs.find(i=>i.name===savedName) || inputs[0];
    S.midiInputName = pick.name || "";
    save(S);
    attachInput(pick);
    midiStatus.textContent="midi: connected ("+(pick.name||"input")+")";
  }catch(e){
    midiStatus.textContent="midi: blocked (https/permissions)";
  }
}

document.getElementById("btnMIDIInit").addEventListener("click", initMIDI);
btnLearn.addEventListener("click", ()=> setLearn(!learn));

function syncUI(){
  // (ê°„ë‹¨: storageë¡œ ê°’ì´ ë°”ë€Œë©´ bindRangeê°€ ì´ë¯¸ ë°˜ì˜í•¨)
  const fx = document.getElementById("selFXPreset");
  fx.value = (S.selFXPreset ?? "digital");
  const ar = document.getElementById("selAutoReboot");
  ar.value = (S.selAutoReboot ?? "1");
}
dbg();
</script>
</body>
</html>
  `);
  w.document.close();
}

document.getElementById('btnGear').addEventListener('click', openControlTower);

/* ==========================================================
   STORAGE SYNC: popupì—ì„œ ê°’ ë°”ë€Œë©´ ë©”ì¸ ë°˜ì˜
========================================================== */
window.addEventListener('storage', (e)=>{
  if(e.key===STORE_KEY){
    S = loadSettings();
    // íŒŒí‹°í´ ìˆ˜ ë³€ê²½ ë°˜ì˜
    const nNew = parseInt(S.selN ?? N, 10);
    if(nNew !== N){
      N = nNew;
      initPoints();
    }
  }
});

/* ==========================================================
   STARTUP
========================================================== */
startStatus("Start Audio â†’ Mic/File ì„ íƒ â†’ Enter");
window.addEventListener('pagehide', ()=>{
  try{ stopMic(); }catch(e){}
  try{ if(fileAudioEl) fileAudioEl.pause(); }catch(e){}
});
</script>
</body>
</html>
