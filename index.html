<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport"
        content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
  <title>SLEEEEEEEP – RED RABBIT LABYRINTH</title>

  <!-- 픽셀 게임 폰트 -->
  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SLEEP">
  <meta name="theme-color" content="#000000">

  <style>
    :root{
      --appH: 100svh;
      --frame: clamp(12px, 3vmin, 24px);
      --ui-gap: 8px;

      --fs-body: clamp(10px, 1.6vmin, 14px);
      --fs-strong: clamp(11px, 1.8vmin, 16px);
      --fs-small: clamp(9px, 1.4vmin, 12px);
    }

    *{
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body{
      width: 100%;
      height: 100%;
      background: #000;
      color: #f5f5f5;
      font-family: "Press Start 2P", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      overscroll-behavior: none;
      touch-action: manipulation;
    }

    body{
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #game-root{
      position: relative;
      background: #000;
      border: 2px solid #444;
      border-radius: 8px;
      overflow: hidden;
      /* 16:9 비율, 가로모드 기준 */
      width: min(100vw, 160vh);
      aspect-ratio: 16 / 9;
    }

    #game-canvas{
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
      background: #000;
    }

    .ui-layer{
      pointer-events: none;
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: var(--frame);
    }

    #chapter-title{
      pointer-events: auto;
      align-self: flex-start;
      padding: 4px 8px;
      border: 1px solid #666;
      background: rgba(0,0,0,0.8);
      font-size: var(--fs-small);
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    #dialog-box{
      pointer-events: auto;
      margin-top: auto;
      width: 100%;
      min-height: 80px;
      max-height: 34%;
      padding: 8px;
      background: rgba(0,0,0,0.85);
      border: 2px solid #777;
      font-size: var(--fs-body);
      line-height: 1.5;
      overflow-y: auto;
      word-break: keep-all;
    }

    #dialog-box::-webkit-scrollbar{
      width: 6px;
    }
    #dialog-box::-webkit-scrollbar-thumb{
      background: #555;
    }

    #controls{
      pointer-events: auto;
      position: absolute;
      left: var(--frame);
      bottom: var(--frame);
      right: var(--frame);
      display: flex;
      flex-direction: row;
      gap: 16px;
      align-items: flex-end;
      justify-content: space-between;
    }

    /* 조이스틱 */
    #joystick{
      position: relative;
      width: 96px;
      height: 96px;
      touch-action: none;
    }

    #joystick-base{
      position: absolute;
      inset: 8px;
      border-radius: 50%;
      border: 2px solid #555;
      background: radial-gradient(circle at center, #222 0, #111 60%, #050505 100%);
      box-shadow: 0 0 6px rgba(0,0,0,0.8);
    }

    #joystick-stick{
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid #888;
      background: radial-gradient(circle at center, #f5f5f5 0, #aaaaaa 40%, #555555 100%);
      left: calc(50% - 22px);
      top: calc(50% - 22px);
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
      transition: left 0.08s ease-out, top 0.08s ease-out;
    }

    .btn-circle{
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid #777;
      background: rgba(15,15,15,0.9);
      color: #f5f5f5;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 0 1px #111;
    }

    .btn-circle:active{
      transform: translateY(1px);
      background: rgba(40,40,40,0.9);
    }

    .btn-ghost{
      background: transparent;
      border: none;
      color: #999;
      font-size: var(--fs-small);
      margin-top: 4px;
    }

    .btn-ghost:active{
      color: #fff;
    }

    #note-overlay{
      pointer-events: auto;
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.92);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--frame);
    }

    #note-overlay.hidden{
      display: none;
    }

    .note-card{
      width: min(640px, 100%);
      max-height: 100%;
      border: 2px solid #888;
      background: #050505;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .note-title{
      font-size: var(--fs-strong);
      margin-bottom: 6px;
    }

    .note-body{
      font-size: var(--fs-body);
      line-height: 1.5;
      overflow-y: auto;
      padding-right: 4px;
      word-break: keep-all;
    }

    .note-body::-webkit-scrollbar{
      width: 6px;
    }
    .note-body::-webkit-scrollbar-thumb{
      background: #555;
    }

    .note-footer{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 4px;
      font-size: var(--fs-small);
      color: #bbb;
    }

    .btn-small{
      pointer-events: auto;
      padding: 4px 10px;
      font-size: var(--fs-small);
      border-radius: 4px;
      border: 1px solid #999;
      background: #111;
      color: #f5f5f5;
    }

    .btn-small:active{
      background: #333;
    }

    #orientation-warning{
      position: fixed;
      inset: 0;
      background: #000;
      color: #f5f5f5;
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 16px;
      font-size: var(--fs-body);
    }

    #orientation-warning span{
      display: block;
      margin-top: 12px;
      font-size: var(--fs-small);
      color: #aaa;
    }

    #start-overlay{
      pointer-events: auto;
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center,#111 0,#000 60%,#000 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 18px;
    }

    #start-overlay.hidden{
      display: none;
    }

    .title-main{
      font-size: clamp(18px,3vmin,26px);
      letter-spacing: 2px;
      text-align: center;
      text-shadow: 0 0 8px rgba(255,255,255,0.6);
    }

    .title-sub{
      font-size: var(--fs-small);
      color: #ccc;
      text-align: center;
      max-width: 560px;
      line-height: 1.6;
    }

    .start-hint{
      font-size: var(--fs-small);
      color: #999;
      margin-top: 8px;
    }

    @media (max-width: 768px){
      #controls{
        transform: scale(0.9);
        transform-origin: bottom left;
      }
    }
  </style>
</head>
<body>
<div id="orientation-warning">
  가로 모드로 돌려주세요.<br/>
  <span>이 게임은 가로 화면(landscape)에서만 플레이할 수 있습니다.</span>
</div>

<div id="game-root">
  <canvas id="game-canvas" width="320" height="180"></canvas>

  <div class="ui-layer">
    <div id="chapter-title">SLEEP / HUB</div>

    <div id="start-overlay">
      <div class="title-main">RED RABBIT / FIVE ROADS</div>
      <div class="title-sub">
        붉은 토끼는 다섯 갈래의 미로를 지나<br/>
        산재·난민·표백·쓰레기산·빅이슈의 이야기를 듣습니다.<br/>
        마지막에는, 기사의 발제문이 쪽지로 남습니다.
      </div>
      <div class="start-hint">화면을 터치하거나 아무 키나 눌러 시작</div>
    </div>

    <div id="dialog-box">
      붉은 토끼는 아직 잠들지 않았습니다.<br/>
      조이스틱으로 움직이고, A 버튼으로 상호작용하세요.
    </div>

    <div id="controls">
      <div id="joystick">
        <div id="joystick-base"></div>
        <div id="joystick-stick"></div>
      </div>
      <div style="margin-left:auto;display:flex;flex-direction:column;align-items:flex-end;gap:6px;">
        <button id="btn-action" class="btn-circle">A</button>
        <button id="btn-note-list" class="btn-ghost">NOTES</button>
      </div>
    </div>
  </div>

  <!-- 쪽지/발제문 -->
  <div id="note-overlay" class="hidden">
    <div class="note-card">
      <div class="note-title" id="note-title">NOTE</div>
      <div class="note-body" id="note-body"></div>
      <div class="note-footer">
        <span id="note-status"></span>
        <button id="btn-close-note" class="btn-small">닫기</button>
      </div>
    </div>
  </div>
</div>

<script>
  // ===== ORIENTATION CHECK =====
  function checkOrientation(){
    const warn = document.getElementById('orientation-warning');
    if(window.innerWidth < window.innerHeight){
      warn.style.display = 'flex';
    }else{
      warn.style.display = 'none';
    }
  }
  window.addEventListener('resize', checkOrientation);
  checkOrientation();

  // ===== BASIC GAME CONSTANTS =====
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');

  const TILE_SIZE = 16;
  const MAP_COLS = 20; // 20 * 16 = 320
  const MAP_ROWS = 11; // 11 * 16 = 176

  const chapterTitleEl = document.getElementById('chapter-title');
  const dialogBoxEl = document.getElementById('dialog-box');
  const startOverlayEl = document.getElementById('start-overlay');
  const noteOverlayEl = document.getElementById('note-overlay');
  const noteTitleEl = document.getElementById('note-title');
  const noteBodyEl = document.getElementById('note-body');
  const noteStatusEl = document.getElementById('note-status');

  const btnAction = document.getElementById('btn-action');
  const btnNoteList = document.getElementById('btn-note-list');
  const btnCloseNote = document.getElementById('btn-close-note');

  const joystick = {
    el: document.getElementById('joystick'),
    stick: document.getElementById('joystick-stick'),
    active: false,
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0,
    dirX: 0,
    dirY: 0,
    lastMoveTime: 0,
    moveInterval: 160 // ms per tile step
  };

  let gameStarted = false;
  let currentMapId = 'hub';

  const notesState = {
    cafeteria: false,
    cameroon: false,
    bleach: false,
    trash: false,
    bigissue: false
  };

  let player = {
    x: 9,   // tile coords
    y: 9,
    px: 9 * TILE_SIZE,
    py: 9 * TILE_SIZE,
    tx: 9 * TILE_SIZE,
    ty: 9 * TILE_SIZE,
    isMoving: false
  };

  const visitedHotspots = new Set();

  // ===== AUDIO (BGM + SFX) =====
  let audioCtx = null;
  let masterGain = null;
  let bgmGain = null;
  let bgmFilter = null;
  let bgmStarted = false;

  function initAudio(){
    if(audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!AC) return;

    audioCtx = new AC();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.65;
    masterGain.connect(audioCtx.destination);

    // BGM용 버스
    bgmGain = audioCtx.createGain();
    bgmGain.gain.value = 0.3;
    bgmFilter = audioCtx.createBiquadFilter();
    bgmFilter.type = "lowpass";
    bgmFilter.frequency.value = 800;
    bgmFilter.Q.value = 0.7;
    bgmGain.connect(bgmFilter);
    bgmFilter.connect(masterGain);

    startBGM();
  }

  function startBGM(){
    if(!audioCtx || bgmStarted) return;
    bgmStarted = true;

    // 간단한 앰비언트 드론 (3개의 옥타브 다른 사인파 + 살짝의 디튠)
    const baseFreqs = [110, 220, 330];
    baseFreqs.forEach((f, i)=>{
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.value = f;
      osc.detune.value = i === 1 ? 12 : (i === 2 ? -8 : 0);

      // 아주 느린 진폭 변조
      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.type = "sine";
      lfo.frequency.value = 0.05 + 0.03*i; // 각기 다른 속도
      lfoGain.gain.value = 0.12;
      lfo.connect(lfoGain);
      lfoGain.connect(gain.gain);

      gain.gain.value = 0.18;
      osc.connect(gain);
      gain.connect(bgmGain);

      const now = audioCtx.currentTime;
      osc.start(now + i*0.3);
      lfo.start(now + i*0.3);
    });
  }

  function playStepSound(){
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(420, t);
    osc.frequency.exponentialRampToValueAtTime(220, t + 0.09);
    gain.gain.setValueAtTime(0.0, t);
    gain.gain.linearRampToValueAtTime(0.22, t + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start(t);
    osc.stop(t + 0.18);
  }

  function playTextSound(){
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "square";
    osc.frequency.setValueAtTime(880, t);
    osc.frequency.exponentialRampToValueAtTime(600, t + 0.05);
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.15, t + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start(t);
    osc.stop(t + 0.12);
  }

  function playNoteSound(){
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(660, t);
    osc.frequency.exponentialRampToValueAtTime(1320, t + 0.25);
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.25, t + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
    osc.connect(gain);
    gain.connect(masterGain);
    osc.start(t);
    osc.stop(t + 0.4);
  }

  // ===== MAPS =====
  // '#' = wall, '.' = floor, ' ' = void, '@' = hub mark,
  // '1'..'5' = chapter portals in hub
  // 'G' = goal tile in chapter map, 'H' = return to hub

  const maps = {
    hub: {
      id: 'hub',
      name: 'SLEEP / HUB',
      tiles: [
        "####################",
        "#..................#",
        "#..1.......2.......#",
        "#..................#",
        "#..3.......4.......#",
        "#..................#",
        "#........5.........#",
        "#..................#",
        "#..................#",
        "#.........@........#",
        "####################"
      ],
      start: {x: 9, y: 9},
      portals: {
        "3,2": "cafeteria",
        "11,2": "cameroon",
        "3,4": "bleach",
        "11,4": "trash",
        "9,6": "bigissue"
      },
      hotspots: [
        {
          x: 9, y: 8,
          id: "hub_intro",
          text: "다섯 갈래의 길이 앞에 놓여 있습니다.\n어느 세계의 목소리를 먼저 들으시겠습니까?"
        }
      ],
      goal: null
    },
    cafeteria: {
      id: 'cafeteria',
      name: '급식실 산재 노동자',
      tiles: [
        "####################",
        "#..G...............#",
        "#..####............#",
        "#......#...........#",
        "#......#...........#",
        "#......#.......#####",
        "#......#.......#..H#",
        "#..####.......#...#",
        "#.............#...#",
        "#.............#...#",
        "####################"
      ],
      start: {x: 2, y: 9},
      hotspots: [
        {
          x: 2, y: 1,
          id: "caf_1",
          text: "열판의 열기는 손까지 익히려 들었습니다.\n바람에 불꽃이 흐트러져서는 안 된다고 했습니다."
        },
        {
          x: 4, y: 3,
          id: "caf_2",
          text: "코끝에 머무는 식용유 냄새를 지우고 싶었습니다.\n그즈음, 그는 다시 담배를 물었습니다."
        }
      ],
      goal: {x: 3, y: 1}
    },
    cameroon: {
      id: 'cameroon',
      name: '카메룬 내전 난민',
      tiles: [
        "####################",
        "#.............#####",
        "#..######.....#..H#",
        "#..#..G.#.....#...#",
        "#..#....#.....#...#",
        "#..#....#.....#...#",
        "#..#....#######...#",
        "#..#..............#",
        "#..################",
        "#..................",
        "####################"
      ],
      start: {x: 2, y: 9},
      hotspots: [
        {
          x: 4, y: 3,
          id: "cam_1",
          text: "“이곳이 나를 원하지 않는다면 어쩔 수 없습니다.\n하지만 저는 선택지가 없습니다.”"
        },
        {
          x: 13, y: 1,
          id: "cam_2",
          text: "경계선은 눈에 보이지 않아도,\n언제나 누군가를 잘라냅니다."
        }
      ],
      goal: {x: 5, y: 3}
    },
    bleach: {
      id: 'bleach',
      name: '인도 표백 노동자',
      tiles: [
        "####################",
        "#..G.........######",
        "#..#####.....#...H#",
        "#......#.....#....#",
        "#......#.....#....#",
        "#......#.....#....#",
        "#..######....#....#",
        "#.............#...#",
        "#.............#...#",
        "#.............#...#",
        "####################"
      ],
      start: {x: 2, y: 9},
      hotspots: [
        {
          x: 4, y: 1,
          id: "ble_1",
          text: "심라구지란 상류에 트럭이 섰습니다.\n잿빛 오염수가 흰 거품과 뒤섞여 떨어집니다."
        },
        {
          x: 8, y: 7,
          id: "ble_2",
          text: "여력이 없는 사람들은 버틸 뿐이라고 말했습니다.\n떠나지 않은 사람들도 곧 아플 것이라고 했습니다."
        }
      ],
      goal: {x: 3, y: 1}
    },
    trash: {
      id: 'trash',
      name: '태국 쓰레기산',
      tiles: [
        "####################",
        "#..#######.....#..H#",
        "#..#.....#.....#...#",
        "#..#.G...#.....#...#",
        "#..#.....#####.#...#",
        "#..#.........#.#...#",
        "#..#######...#.#...#",
        "#..........###.#...#",
        "#..............#...#",
        "#..............#...#",
        "####################"
      ],
      start: {x: 2, y: 9},
      hotspots: [
        {
          x: 4, y: 3,
          id: "tr_1",
          text: "멀리서 보았을 때 쓰레기산은 언덕 같았습니다.\n가까이 다가갈수록 냄새와 소리가 쌓여갑니다."
        },
        {
          x: 12, y: 8,
          id: "tr_2",
          text: "GPS를 넣은 신발은 도시를 떠나,\n바다를 건너, 3500km 떨어진 시장에서 다시 신호를 보냈습니다."
        }
      ],
      goal: {x: 4, y: 3}
    },
    bigissue: {
      id: 'bigissue',
      name: '빅이슈 / 거리의 집',
      tiles: [
        "####################",
        "#..................#",
        "#..######......####",
        "#..#....#......#..H",
        "#..#.G..#......#..#",
        "#..#....#......#..#",
        "#..######......#..#",
        "#..............#..#",
        "#..............#..#",
        "#..............#..#",
        "####################"
      ],
      start: {x: 2, y: 9},
      hotspots: [
        {
          x: 4, y: 4,
          id: "bi_1",
          text: "매일 아침 왼발 앞쪽에 붕대를 감습니다.\n붕대는 발가락 대신 몸의 균형을 잡아줍니다."
        },
        {
          x: 15, y: 3,
          id: "bi_2",
          text: "홈리스는 거리 노숙인만이 아닙니다.\n불안정한 집, 기준에 미치지 못하는 방도 포함됩니다."
        }
      ],
      goal: {x: 4, y: 4}
    }
  };

  // ===== TEXT HELPERS =====
  function setDialog(text){
    dialogBoxEl.textContent = '';
    const lines = text.split('\n');
    lines.forEach((line, idx) => {
      dialogBoxEl.appendChild(document.createTextNode(line));
      if(idx < lines.length - 1){
        dialogBoxEl.appendChild(document.createElement('br'));
      }
    });
    playTextSound();
  }

  function showNoteForMap(mapId){
    let title = "";
    let body = "";
    let key = null;

    if(mapId === 'cafeteria'){
      title = "NOTE 1 / 급식실 산재 노동자";
      body =
        "열판의 열기는 손까지 익히려 들었습니다.\n" +
        "창문을 열면, 바람에 불꽃이 흐트러져서는 안 된다고 했습니다.\n\n" +
        "코끝에 머무는 식용유 냄새를 지우고 싶었습니다.\n" +
        "그즈음 그는 다시 담배를 물었고,\n" +
        "몇 년 후 조리실을 떠났습니다.\n\n" +
        "폐암 4기 진단. 그리고, 지난해 7월의 부고.\n" +
        "일터의 열기는 몸에 먼저 스며들었습니다.";
      key = 'cafeteria';
    }else if(mapId === 'cameroon'){
      title = "NOTE 2 / 카메룬 내전 난민";
      body =
        "“이곳이 나를 원하지 않는다면 어쩔 수 없어요.\n" +
        "하지만 저는 선택지가 없습니다.\n" +
        "이곳에 머무는 것밖에.”\n\n" +
        "국경과 난민 캠프, 서류와 바코드,\n" +
        "눈에 보이지 않는 선들이 사람을 잘라냅니다.\n\n" +
        "당신과 나를 구분짓는 경계,\n" +
        "‘너’가 ‘그것’이 되는 순간은 어디에서 시작될까요?";
      key = 'cameroon';
    }else if(mapId === 'bleach'){
      title = "NOTE 3 / 인도 표백 노동자";
      body =
        "심라구지란 상류에 선 트럭에서,\n" +
        "잿빛 오염수가 흰 거품과 뒤섞여 쏟아졌습니다.\n" +
        "30분 뒤, 똑같은 장면이 반복되었습니다.\n\n" +
        "표백 공장의 더러운 물은 방류되어\n" +
        "마을과 강으로 흘러들어갑니다.\n\n" +
        "떠날 여력이 없는 사람들은 버틸 뿐이라고 말합니다.\n" +
        "여기 머무는 이들 역시 곧 아플 것이라고 말합니다.";
      key = 'bleach';
    }else if(mapId === 'trash'){
      title = "NOTE 4 / 태국 쓰레기산";
      body =
        "멀리서 보았을 때, 쓰레기산은 작은 언덕 같았습니다.\n" +
        "가까이 다가갈수록, 냄새와 소리가 겹겹이 쌓였습니다.\n\n" +
        "GPS를 넣은 신발은 도시 외곽으로 나갔다가,\n" +
        "양주, 인천 항구를 지나,\n" +
        "4주 뒤, 태국 롱끌르아 시장에서 다시 신호를 보냈습니다.\n\n" +
        "한 사람의 발자국은,\n" +
        "거대한 쓰레기의 역사 속 한 좌표가 되었습니다.";
      key = 'trash';
    }else if(mapId === 'bigissue'){
      title = "NOTE 5 / 빅이슈 / 거리의 집";
      body =
        "매일 아침, 왼발 앞쪽에 붕대를 감습니다.\n" +
        "2011년 산재 사고로 왼쪽 발가락 다섯 개를 잃었습니다.\n" +
        "붕대는 발가락 대신 몸의 균형을 잡아주지만,\n" +
        "얼마 못 가 모양이 흐트러집니다.\n\n" +
        "홈리스는 거리 노숙인만을 뜻하지 않습니다.\n" +
        "불안정한 주거, 기준에 미치지 못하는 집,\n" +
        "치료시설과 임시 쉼터의 침대들까지 포함됩니다.\n\n" +
        "우리는 서로에게 기대어 서 있습니다.\n" +
        "누군가의 붕대 위에서 간신히 버티는 균형처럼.";
      key = 'bigissue';
    }else if(mapId === 'all'){
      title = "FINAL NOTE / 다섯 갈래의 잠";
      body =
        "붉은 토끼는 다섯 갈래의 미로를 모두 지나왔습니다.\n\n" +
        "급식실의 열기, 국경의 경계,\n" +
        "표백 공장의 물, 쓰레기산 위의 GPS,\n" +
        "거리의 집과 붕대.\n\n" +
        "이 이야기들은 서로 다른 곳에서 시작되었지만,\n" +
        "하나의 세계 안에서 동시에 잠들어 있습니다.\n\n" +
        "당신은 이제, 기사의 발제문을 들었고,\n" +
        "누군가의 세계가 ‘그것’이 되기 전의 순간을\n" +
        "조금 더 오래 바라보게 되었습니다.";
      key = null;
    }

    noteTitleEl.textContent = title;
    noteBodyEl.textContent = '';
    body.split('\n').forEach((line, idx) => {
      noteBodyEl.appendChild(document.createTextNode(line));
      if(idx < body.split('\n').length - 1){
        noteBodyEl.appendChild(document.createElement('br'));
      }
    });

    if(key){
      notesState[key] = true;
    }

    const collectedCount = Object.values(notesState).filter(Boolean).length;
    const total = Object.keys(notesState).length;
    noteStatusEl.textContent = `수집된 쪽지: ${collectedCount} / ${total}`;

    noteOverlayEl.classList.remove('hidden');
    playNoteSound();
  }

  function showNoteList(){
    let body = "";
    body += notesState.cafeteria ? "■ NOTE 1 / 급식실 산재 노동자 (획득)\n" : "□ NOTE 1 / 급식실 산재 노동자\n";
    body += notesState.cameroon ? "■ NOTE 2 / 카메룬 내전 난민 (획득)\n" : "□ NOTE 2 / 카메룬 내전 난민\n";
    body += notesState.bleach ? "■ NOTE 3 / 인도 표백 노동자 (획득)\n" : "□ NOTE 3 / 인도 표백 노동자\n";
    body += notesState.trash ? "■ NOTE 4 / 태국 쓰레기산 (획득)\n" : "□ NOTE 4 / 태국 쓰레기산\n";
    body += notesState.bigissue ? "■ NOTE 5 / 빅이슈 / 거리의 집 (획득)\n" : "□ NOTE 5 / 빅이슈 / 거리의 집\n";

    noteTitleEl.textContent = "NOTES / 쪽지 목록";
    noteBodyEl.textContent = '';
    body.split('\n').forEach((line, idx) => {
      noteBodyEl.appendChild(document.createTextNode(line));
      if(idx < body.split('\n').length - 1){
        noteBodyEl.appendChild(document.createElement('br'));
      }
    });
    const collectedCount = Object.values(notesState).filter(Boolean).length;
    const total = Object.keys(notesState).length;
    noteStatusEl.textContent = `수집된 쪽지: ${collectedCount} / ${total}`;
    noteOverlayEl.classList.remove('hidden');
    playNoteSound();
  }

  // ===== MAP HELPERS =====
  function getMap(){
    return maps[currentMapId];
  }

  function isWall(x, y){
    const map = getMap();
    if(x < 0 || x >= MAP_COLS || y < 0 || y >= MAP_ROWS) return true;
    const ch = map.tiles[y].charAt(x);
    if(ch === '#') return true;
    return false;
  }

  function getTileChar(x, y){
    const map = getMap();
    if(x < 0 || x >= MAP_COLS || y < 0 || y >= MAP_ROWS) return ' ';
    return map.tiles[y].charAt(x);
  }

  function warpToMap(mapId, startPos){
    currentMapId = mapId;
    chapterTitleEl.textContent = maps[mapId].name;
    const map = maps[mapId];
    const sp = startPos || map.start;
    player.x = sp.x;
    player.y = sp.y;
    player.px = player.x * TILE_SIZE;
    player.py = player.y * TILE_SIZE;
    player.tx = player.px;
    player.ty = player.py;
    player.isMoving = false;

    if(mapId === 'hub'){
      setDialog("다섯 갈래의 길.\n토끼는 어느 세계부터 들어가 볼까요?");
    }else{
      if(mapId === 'cafeteria'){
        setDialog("열판의 열기와 식용유 냄새가 남은 조리실.\n지워진 자리를 따라가 봅니다.");
      }else if(mapId === 'cameroon'){
        setDialog("보이지 않는 선들이 겹쳐진 국경.\n열려 있으면서 닫힌 문들을 지나갑니다.");
      }else if(mapId === 'bleach'){
        setDialog("표백 공장의 물이 흐르는 마을.\n흰색이 아니라, 지워짐으로 물든 세계.");
      }else if(mapId === 'trash'){
        setDialog("겹겹이 쌓인 쓰레기산.\n누군가의 발자국이 어디로 옮겨졌는지 따라가 봅니다.");
      }else if(mapId === 'bigissue'){
        setDialog("거리의 집, 흔들리는 균형.\n누군가의 붕대 위에서 버티는 밤.");
      }
    }
  }

  // ===== PLAYER MOVEMENT (부드러운 보간) =====
  function tryMove(dx, dy){
    if(!gameStarted) return;
    if(player.isMoving) return;
    if(dx === 0 && dy === 0) return;

    const nx = player.x + dx;
    const ny = player.y + dy;
    if(isWall(nx, ny)) return;

    player.x = nx;
    player.y = ny;
    player.tx = player.x * TILE_SIZE;
    player.ty = player.y * TILE_SIZE;
    player.isMoving = true;

    handleTileStepPending = true; // 이동 완료 후 처리
    playStepSound();
  }

  let handleTileStepPending = false;

  function handleTileStep(){
    const map = getMap();
    const key = player.x + "," + player.y;

    if(map.id === 'hub'){
      const portal = map.portals[key];
      if(portal){
        warpToMap(portal);
        return;
      }

      const collectedAll = Object.values(notesState).every(Boolean);
      if(collectedAll && player.x === 9 && player.y === 9){
        showNoteForMap('all');
      }

      map.hotspots.forEach(hs => {
        if(hs.x === player.x && hs.y === player.y){
          if(!visitedHotspots.has(hs.id)){
            visitedHotspots.add(hs.id);
          }
          setDialog(hs.text);
        }
      });

    }else{
      if(map.hotspots){
        map.hotspots.forEach(hs => {
          if(hs.x === player.x && hs.y === player.y){
            if(!visitedHotspots.has(hs.id)){
              visitedHotspots.add(hs.id);
            }
            setDialog(hs.text);
          }
        });
      }

      if(map.goal && map.goal.x === player.x && map.goal.y === player.y){
        showNoteForMap(map.id);
      }

      const ch = getTileChar(player.x, player.y);
      if(ch === 'H'){
        warpToMap('hub');
      }
    }
  }

  // ===== RENDERING =====
  function draw(){
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const map = getMap();

    // 맵별 팔레트
    let floor = "#111111";
    let floorDetail = "#151515";
    let wallDark = "#444444";
    let wallLight = "#666666";
    let accentGoal = "#ff4444";
    let accentGoalDark = "#550000";
    let accentHub = "#55ffff";
    let accentHubDark = "#002222";

    if(map.id === 'cafeteria'){
      floor = "#121010";
      floorDetail = "#2a1b1b";
      wallDark = "#4b3333";
      wallLight = "#8c5b46";
    }else if(map.id === 'cameroon'){
      floor = "#111119";
      floorDetail = "#202033";
      wallDark = "#373a4b";
      wallLight = "#7a7f99";
    }else if(map.id === 'bleach'){
      floor = "#161616";
      floorDetail = "#2a2a2a";
      wallDark = "#555555";
      wallLight = "#9f9f9f";
    }else if(map.id === 'trash'){
      floor = "#10130e";
      floorDetail = "#272f1a";
      wallDark = "#3e4a32";
      wallLight = "#7f8d5a";
    }else if(map.id === 'bigissue'){
      floor = "#101015";
      floorDetail = "#1f1f2b";
      wallDark = "#34344a";
      wallLight = "#777799";
    }

    // 타일 그리기
    for(let y=0; y<MAP_ROWS; y++){
      const row = map.tiles[y];
      for(let x=0; x<MAP_COLS; x++){
        const ch = row.charAt(x);
        const sx = x * TILE_SIZE;
        const sy = y * TILE_SIZE;

        // 바닥
        ctx.fillStyle = floor;
        ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);

        if(ch === '#'){
          // 벽
          ctx.fillStyle = wallDark;
          ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = wallLight;
          ctx.fillRect(sx+2, sy+2, TILE_SIZE-4, TILE_SIZE-6);
        }else{
          // 바닥 텍스처
          ctx.fillStyle = floorDetail;
          ctx.fillRect(sx + (x%2===0?4:9), sy + (y%2===0?4:9), 1, 1);
        }

        if(map.id === 'hub'){
          if(ch === '1' || ch === '2' || ch === '3' || ch === '4' || ch === '5'){
            ctx.fillStyle = "#202020";
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = "#bbbbbb";
            ctx.fillRect(sx+3, sy+3, TILE_SIZE-6, TILE_SIZE-6);
            ctx.fillStyle = "#000000";
            ctx.font = "10px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(ch, sx + TILE_SIZE/2, sy + TILE_SIZE/2 + 1);
          }
          if(ch === '@'){
            ctx.fillStyle = "#333333";
            ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(sx+3, sy+3, TILE_SIZE-6, TILE_SIZE-6);
          }
        }

        if(ch === 'G'){
          ctx.fillStyle = accentGoalDark;
          ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = accentGoal;
          ctx.fillRect(sx+3, sy+3, TILE_SIZE-6, TILE_SIZE-6);
        }
        if(ch === 'H'){
          ctx.fillStyle = accentHubDark;
          ctx.fillRect(sx, sy, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = accentHub;
          ctx.fillRect(sx+3, sy+3, TILE_SIZE-6, TILE_SIZE-6);
        }
      }
    }

    // 플레이어 위치 보간
    if(player.isMoving){
      const speed = 0.28; // 0~1 사이 (1이면 순간이동)
      const dx = player.tx - player.px;
      const dy = player.ty - player.py;
      player.px += dx * speed;
      player.py += dy * speed;

      if(Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5){
        player.px = player.tx;
        player.py = player.ty;
        player.isMoving = false;
        if(handleTileStepPending){
          handleTileStepPending = false;
          handleTileStep();
        }
      }
    }

    // 붉은 토끼
    const px = player.px;
    const py = player.py;
    ctx.fillStyle = "#990000";
    ctx.fillRect(px+3, py+3, TILE_SIZE-6, TILE_SIZE-5); // 몸통

    // 귀
    ctx.fillRect(px+4, py-2, 3, 6);
    ctx.fillRect(px+TILE_SIZE-7, py-2, 3, 6);

    // 눈
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(px+5, py+5, 2, 2);

    // 그림자
    ctx.fillStyle = "rgba(0,0,0,0.4)";
    ctx.fillRect(px+2, py+TILE_SIZE-4, TILE_SIZE-4, 2);

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);

  // ===== INPUT HANDLERS =====

  function startGameIfNeeded(){
    if(!gameStarted){
      gameStarted = true;
      startOverlayEl.classList.add('hidden');
      setDialog("붉은 토끼가 눈을 떴습니다.\n다섯 갈래의 길 중 하나를 선택해 보세요.");
    }
    initAudio();
  }

  // 키보드
  window.addEventListener('keydown', (e)=>{
    startGameIfNeeded();
    if(noteOverlayEl && !noteOverlayEl.classList.contains('hidden')){
      if(e.key === 'Escape' || e.key === 'Enter' || e.key === ' '){
        noteOverlayEl.classList.add('hidden');
      }
      return;
    }
    if(e.key === 'ArrowUp' || e.key === 'w'){
      tryMove(0,-1);
    }else if(e.key === 'ArrowDown' || e.key === 's'){
      tryMove(0,1);
    }else if(e.key === 'ArrowLeft' || e.key === 'a'){
      tryMove(-1,0);
    }else if(e.key === 'ArrowRight' || e.key === 'd'){
      tryMove(1,0);
    }else if(e.key === ' ' || e.key === 'Enter' || e.key === 'z' || e.key === 'x'){
      handleAction();
    }
  });

  // 액션 버튼
  btnAction.addEventListener('click', ()=>{
    startGameIfNeeded();
    handleAction();
  });

  function handleAction(){
    const map = getMap();

    if(map.id === 'hub'){
      const all = Object.values(notesState).every(Boolean);
      if(player.x === 9 && player.y === 9){
        if(all){
          showNoteForMap('all');
        }else{
          setDialog("아직 잠들지 않은 이야기가 있습니다.\n다른 길들을 더 걸어가 보세요.");
        }
      }else{
        setDialog("조이스틱으로 움직이고 A 버튼으로 상호작용합니다.\n포털 위에 서면 다른 세계로 이동합니다.");
      }
    }else{
      if(map.id === 'cafeteria'){
        setDialog("당신이 걸어가는 길 위에도,\n보이지 않는 열과 기름이 남아 있을지 모릅니다.");
      }else if(map.id === 'cameroon'){
        setDialog("발밑의 픽셀들도 보이지 않는 선으로 나뉩니다.\n당신은 어느 쪽에 서 있습니까?");
      }else if(map.id === 'bleach'){
        setDialog("흰색은 항상 깨끗함을 의미하지 않습니다.\n무언가가 지워진 자리일 수도 있습니다.");
      }else if(map.id === 'trash'){
        setDialog("겹겹이 쌓인 픽셀 더미 속에서,\n당신은 어떤 하나의 점에 시선이 멈추나요?");
      }else if(map.id === 'bigissue'){
        setDialog("우리는 서로에게 약간씩 기대며 버팁니다.\n균형을 잃지 않기 위해.");
      }
    }
  }

  // NOTE 창 닫기
  btnCloseNote.addEventListener('click', ()=>{
    noteOverlayEl.classList.add('hidden');
    if(currentMapId !== 'hub' && currentMapId !== 'all'){
      warpToMap('hub');
    }
  });

  btnNoteList.addEventListener('click', ()=>{
    if(!gameStarted) return;
    showNoteList();
  });

  startOverlayEl.addEventListener('click', ()=>{
    startGameIfNeeded();
  });

  // ===== JOYSTICK HANDLING =====
  const joystickRect = ()=> joystick.el.getBoundingClientRect();

  function joystickSetStick(dx, dy){
    const maxR = 32;
    const len = Math.sqrt(dx*dx + dy*dy);
    const r = Math.min(len, maxR);
    const nx = len ? dx / len : 0;
    const ny = len ? dy / len : 0;
    const cx = 48; // center (96/2)
    const cy = 48;
    joystick.stick.style.left = (cx + nx * r - 22) + "px";
    joystick.stick.style.top = (cy + ny * r - 22) + "px";
  }

  function joystickReset(){
    joystick.active = false;
    joystick.dirX = 0;
    joystick.dirY = 0;
    joystickSetStick(0,0);
  }

  function joystickPointerDown(e){
    startGameIfNeeded();
    e.preventDefault();
    const rect = joystickRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    joystick.active = true;
    joystick.startX = x;
    joystick.startY = y;
    joystick.curX = x;
    joystick.curY = y;
    joystick.lastMoveTime = performance.now();
    joystickSetStick(0,0);
  }

  function joystickPointerMove(e){
    if(!joystick.active) return;
    e.preventDefault();
    const rect = joystickRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    joystick.curX = x;
    joystick.curY = y;

    const dx = x - joystick.startX;
    const dy = y - joystick.startY;

    joystickSetStick(dx, dy);

    const dist = Math.sqrt(dx*dx + dy*dy);
    const threshold = 12;
    if(dist < threshold){
      joystick.dirX = 0;
      joystick.dirY = 0;
      return;
    }

    // 어느 축으로 움직일지 결정
    if(Math.abs(dx) > Math.abs(dy)){
      joystick.dirX = dx > 0 ? 1 : -1;
      joystick.dirY = 0;
    }else{
      joystick.dirX = 0;
      joystick.dirY = dy > 0 ? 1 : -1;
    }

    const now = performance.now();
    if(now - joystick.lastMoveTime > joystick.moveInterval){
      joystick.lastMoveTime = now;
      tryMove(joystick.dirX, joystick.dirY);
    }
  }

  function joystickPointerUp(e){
    e.preventDefault();
    joystickReset();
  }

  joystick.el.addEventListener('mousedown', joystickPointerDown);
  joystick.el.addEventListener('mousemove', joystickPointerMove);
  window.addEventListener('mouseup', joystickPointerUp);

  joystick.el.addEventListener('touchstart', joystickPointerDown, {passive:false});
  joystick.el.addEventListener('touchmove', joystickPointerMove, {passive:false});
  window.addEventListener('touchend', joystickPointerUp, {passive:false});
  window.addEventListener('touchcancel', joystickPointerUp, {passive:false});

  // 초기 허브 설정
  warpToMap('hub');
</script>
</body>
</html>
