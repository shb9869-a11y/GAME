<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Grave Run — Spirit & Opportunity (Large · Fixed)</title>
<meta name="theme-color" content="#000000">
<style>
  :root{
    --bg:#0a0812; --fg:#eae6ff;
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bot: env(safe-area-inset-bottom, 0px);
    --safe-left: env(safe-area-inset-left, 0px);
    --safe-right: env(safe-area-inset-right, 0px);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font-family:ui-monospace,"SF Mono",Menlo,Consolas,monospace;}
  #stage{
    position:relative;width:100vw;height:100svh;
    padding:var(--safe-top) var(--safe-right) var(--safe-bot) var(--safe-left);
    overflow:hidden;
  }
  canvas{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    image-rendering:pixelated;image-rendering:crisp-edges;touch-action:none;
    min-width:1px;min-height:1px;z-index:0;
  }
  .hud{
    position:absolute;left:calc(14px + var(--safe-left));top:calc(10px + var(--safe-top));
    font-size:13px;opacity:.9;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.15);
    padding:8px 10px;border-radius:12px;z-index:2;
  }
  .dpad{
    position:absolute;left:calc(18px + var(--safe-left));bottom:calc(18px + var(--safe-bot));
    width:220px;height:220px;display:none;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);
    gap:12px;opacity:.96;filter:drop-shadow(0 2px 8px rgba(0,0,0,.6));z-index:2;
  }
  .dpad .cell{display:grid;place-items:center;}
  .dpad button{
    width:100%;height:100%;border-radius:16px;border:1px solid rgba(255,255,255,.25);
    background:rgba(255,255,255,.08);color:#fff;font:700 15px ui-monospace,monospace;
    user-select:none;-webkit-user-select:none;
  }
  .dpad button:active{background:rgba(255,255,255,.2);}
  @media (pointer:coarse){ .dpad{display:grid;} }
  .btnE{
    position:absolute;right:calc(18px + var(--safe-right));bottom:calc(18px + var(--safe-bot));
    width:220px;height:64px;display:none;place-items:center;
    border-radius:14px;border:1px solid rgba(255,255,255,.22);
    background:rgba(255,255,255,.08);color:#fff;font:800 14px ui-monospace,monospace;z-index:2;
  }
  .dialog{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:3;}
  .dialog .box{
    min-width:340px;max-width:86vw;background:#171422;color:#eee;
    border:1px solid rgba(255,255,255,.2);border-radius:12px;padding:16px 16px 14px;
    box-shadow:0 10px 24px rgba(0,0,0,.6);font:13px/1.7 ui-monospace,monospace;
  }
  .dialog .box h3{margin:0 0 10px;font:700 13px ui-monospace,monospace;color:#ffd4a6;}
  .choices{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px;}
  .choices button{padding:9px 12px;border-radius:9px;border:1px solid rgba(255,255,255,.25);
    background:#2c2546;color:#fff;font:700 12px ui-monospace,monospace;}
</style>
</head>
<body>
<div id="stage" aria-live="polite">
  <div class="hud" id="hud">초기화 중…</div>
  <canvas id="view" aria-label="게임 화면"></canvas>

  <div class="dpad" id="dpad" aria-hidden="false">
    <div class="cell"></div><div class="cell"><button data-dir="up">▲</button></div><div class="cell"></div>
    <div class="cell"><button data-dir="left">◀</button></div><div class="cell"></div><div class="cell"><button data-dir="right">▶</button></div>
    <div class="cell"></div><div class="cell"><button data-dir="down">▼</button></div><div class="cell"></div>
  </div>

  <button id="btnE" class="btnE">E</button>

  <div id="dialog" class="dialog" role="dialog" aria-modal="true">
    <div class="box">
      <h3 id="dgTitle">기록</h3>
      <div id="dgBody">...</div>
      <div id="dgChoices" class="choices"></div>
    </div>
  </div>
</div>

<script>
/* ===== Query ===== */
const Q=new URLSearchParams(location.search);
const ROOM=Q.get('room')||'room-a';
const NAME=(Q.get('name')||'guest').slice(0,16);
const SERVER=Q.get('server')||'ws://localhost:3000';
const SFX_ON=(Q.get('sfx')||'1')==='1';

/* ===== DOM refs (!!! btnE를 먼저 잡는다) ===== */
const stage=document.getElementById('stage');
const cv=document.getElementById('view');
const hud=document.getElementById('hud');
const dpad=document.getElementById('dpad');
const btnE=document.getElementById('btnE');
const dlg=document.getElementById('dialog');
const dgTitle=document.getElementById('dgTitle');
const dgBody=document.getElementById('dgBody');
const dgChoices=document.getElementById('dgChoices');

/* ===== Audio ===== */
let AC, G, ready=false;
function initAudio(){ if(ready||!SFX_ON) return; AC=new (window.AudioContext||window.webkitAudioContext)(); G=AC.createGain(); G.gain.value=0.22; G.connect(AC.destination); ready=true; }
async function unlockAudio(){ try{ initAudio(); if(AC && AC.state==='suspended') await AC.resume(); }catch(e){} }
['pointerdown','touchstart','keydown'].forEach(ev=>addEventListener(ev,unlockAudio,{passive:true}));
function blip(f=660,d=0.08,v=0.25){ if(!ready||!SFX_ON) return; const t=AC.currentTime,o=AC.createOscillator(),g=AC.createGain(); o.type='square'; o.frequency.setValueAtTime(f,t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(v,t+0.01); g.gain.linearRampToValueAtTime(0.0001,t+d+0.06); o.connect(g); g.connect(G); o.start(t); o.stop(t+d+0.06); }

/* ===== Canvas ===== */
const g=cv.getContext('2d',{alpha:false}); g.imageSmoothingEnabled=false;
const TILE=24, W=20, H=20;
cv.width=W*TILE; cv.height=H*TILE;

/* iOS 안전한 fit: visualViewport 사용 + 최소 1배 */
function fit(){
  const vw = window.visualViewport ? window.visualViewport.width  : stage.clientWidth;
  const vh = window.visualViewport ? window.visualViewport.height : stage.clientHeight;
  const s = Math.max(1, Math.floor(Math.min(vw/cv.width, vh/cv.height)));
  cv.style.width=(cv.width*s)+'px';
  cv.style.height=(cv.height*s)+'px';
}
new ResizeObserver(fit).observe(stage); fit(); requestAnimationFrame(fit);

/* ===== 맵 ===== */
const LEVEL0 = Array.from({length:H},()=>Array(W).fill(0));
const LEVEL1 = Array.from({length:H},()=>Array(W).fill(0));
for(let x=0;x<W;x++){ LEVEL0[0][x]=1; LEVEL0[H-1][x]=1; LEVEL1[0][x]=1; LEVEL1[H-1][x]=1; }
for(let y=0;y<H;y++){ LEVEL0[y][0]=1; LEVEL0[y][W-1]=1; LEVEL1[y][0]=1; LEVEL1[y][W-1]=1; }
for(let x=6;x<=13;x++){ LEVEL0[H-1][x]=0; LEVEL1[H-1][x]=0; }
for(let y=3;y<17;y+=3){ LEVEL0[y][5]=1; LEVEL0[y][10]=1; LEVEL0[y][15]=1; }
const PHONES=[[2,4],[2,8],[2,12],[5,16],[8,4],[8,8],[8,12],[12,6],[12,10],[16,14]];
PHONES.forEach(([x,y])=>{ LEVEL1[y][x]=1; });

let room=0;
function solidAt(r,tx,ty){ if(tx<0||ty<0||tx>=W||ty>=H) return true; const L=r===0?LEVEL0:LEVEL1; return L[ty][tx]===1; }

/* ===== 도우미 ===== */
function nearestGrave(px,py){ let best=null,bd=1e9; for(let y=0;y<H;y++) for(let x=0;x<W;x++){ if(LEVEL0[y][x]===1){ const cx=x+0.5,cy=y+0.5,d=Math.hypot(px-cx,py-cy); if(d<bd){bd=d;best={x,y,cx,cy};}}} return {grave:best,dist:bd}; }
function nearestPhone(px,py){ let best=null,bd=1e9; for(const [x,y] of PHONES){ const cx=x+0.5,cy=y+0.5,d=Math.hypot(px-cx,py-cy); if(d<bd){bd=d;best={x,y,cx,cy};}} return {phone:best,dist:bd}; }
function graveText(x,y){ const lines=["나는 얼굴을 잃고, 귀로만 걷는다.","빛이 고요를 문질러 소리가 났다.","오차가 감정이고, 잔향이 초상이다.","돌은 서 있고, 이야기는 흘러간다.","너와 나 사이, 빈칸이 숨을 쉰다.","시간의 모서리에 귀를 댔다.","여기 눕힌 건 말들이다.","망각의 틈에서 작은 불이 켜진다."]; const idx=(x*31+y*17)%lines.length; return lines[idx]; }

/* ===== 플레이어/타인 ===== */
function randTint(){ const hues=[18,30,200,140,280]; const h=hues[(Math.random()*hues.length)|0]; return `hsl(${h} 80% 60%)`; }
const me={id:null,name:NAME,x:10.5,y:4.5,spd:0.09,tint:randTint(),anim:0};
const others=new Map();

/* ===== NPC Opportunity ===== */
const opp={x:8.5,y:8.5,spd:0.065,path:[],target:null,repathAt:0};
function randomWalkableTile0(){ let tx,ty; do{ tx=(Math.random()*W)|0; ty=(Math.random()*H)|0; }while(LEVEL0[ty]?.[tx]!==0); return {tx,ty}; }
function bfsPath(level, sx,sy,tx,ty){
  const Q=[[sx,sy]],V=new Set([sx+','+sy]),P={},dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  const solid=(x,y)=>{ if(x<0||y<0||x>=W||y>=H) return true; return level===0?(LEVEL0[y][x]===1):(LEVEL1[y][x]===1); };
  while(Q.length){ const [x,y]=Q.shift(); if(x===tx&&y===ty) break;
    for(const [dx,dy] of dirs){ const nx=x+dx,ny=y+dy; if(solid(nx,ny)) continue; const k=nx+','+ny; if(V.has(k)) continue; V.add(k); P[k]=[x,y]; Q.push([nx,ny]); } }
  const key=tx+','+ty; if(!(key in P) && !(sx===tx && sy===ty)) return [];
  let path=[[tx,ty]],cx=tx,cy=ty; while(!(cx===sx&&cy===sy)){ const prev=P[cx+','+cy]; if(!prev) break; path.push(prev); cx=prev[0]; cy=prev[1]; } path.reverse(); return path;
}
const Opportunity={
  ensureTarget(force=false){
    if(room!==0||inConvo) return;
    const now=performance.now();
    if(force || !opp.target || now>opp.repathAt || opp.path.length===0){
      let t=randomWalkableTile0(), tries=0;
      while(Math.hypot((t.tx+0.5)-me.x,(t.ty+0.5)-me.y)<3 && tries++<10) t=randomWalkableTile0();
      opp.target=t; const sx=opp.x|0, sy=opp.y|0;
      opp.path=bfsPath(0,sx,sy,t.tx,t.ty); opp.repathAt=now+5000+Math.random()*5000;
    }
  },
  step(){
    if(room!==0||inConvo) return;
    this.ensureTarget();
    if(opp.path.length>0){
      const [nx,ny]=opp.path[0], tx=nx+0.5, ty=ny+0.5; const dx=tx-opp.x, dy=ty-opp.y, m=Math.hypot(dx,dy);
      if(m<0.05){ opp.x=tx; opp.y=ty; opp.path.shift(); } else { const ax=dx/m, ay=dy/m; moveEntity(opp,ax,ay); }
    } else this.ensureTarget(true);
  }
};

/* ===== 입력 ===== */
const keys=new Set();
addEventListener('keydown',e=>{ const k=e.key.toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','e'].includes(k)) e.preventDefault(); keys.add(k);});
addEventListener('keyup',e=> keys.delete(e.key.toLowerCase()));
const held=new Set(); const dstate={ax:0,ay:0};
function updHeld(){ let ax=0,ay=0; if(held.has('left')) ax-=1; if(held.has('right')) ax+=1; if(held.has('up')) ay-=1; if(held.has('down')) ay+=1; dstate.ax=ax; dstate.ay=ay; }
dpad.querySelectorAll('button[data-dir]').forEach(btn=>{
  const dir=btn.dataset.dir;
  const down=e=>{e.preventDefault();held.add(dir);updHeld();};
  const up=e=>{e.preventDefault();held.delete(dir);updHeld();};
  btn.addEventListener('pointerdown',down); btn.addEventListener('pointerup',up);
  btn.addEventListener('pointercancel',up); btn.addEventListener('pointerleave',up);
  btn.addEventListener('touchstart',down,{passive:false}); btn.addEventListener('touchend',up,{passive:false}); btn.addEventListener('touchcancel',up,{passive:false});
});

/* ===== 네트워크 ===== */
let ws, wsOpen=false, myId=null;
function connect(){
  try{
    ws=new WebSocket(SERVER);
    ws.addEventListener('open', ()=>{ wsOpen=true; hud.textContent=`연결됨 · ROOM=${ROOM}`; ws.send(JSON.stringify({t:'join',room:ROOM,name:NAME})); });
    ws.addEventListener('message', onMsg);
    ws.addEventListener('close', ()=>{ wsOpen=false; hud.textContent='연결 끊김. 3초 후 재시도…'; setTimeout(connect,3000); });
    ws.addEventListener('error', ()=>{ hud.textContent='서버 오류. 3초 후 재시도…'; try{ws.close();}catch(e){} });
  }catch{ hud.textContent='오프라인 모드(서버 미연결)'; }
}
connect();
function onMsg(ev){
  const msg=JSON.parse(ev.data||'{}');
  if(msg.t==='welcome'){ myId=msg.id; me.id=myId; }
  else if(msg.t==='state' && msg.id!==myId){
    let o=others.get(msg.id);
    if(!o){ o={id:msg.id,name:msg.name||'guest',x:msg.x,y:msg.y,tint:msg.tint||randTint(),ts:performance.now()}; others.set(msg.id,o); blip(520,0.05,0.18); }
    else{ o.name=msg.name||o.name; o.x=msg.x; o.y=msg.y; o.tint=msg.tint||o.tint; o.ts=performance.now(); }
  }else if(msg.t==='leave'){ others.delete(msg.id); }
}

/* ===== 브로드캐스트 ===== */
let lastSend=0;
function sendState(now){
  if(!wsOpen||!myId) return;
  if(now-lastSend<66) return;
  lastSend=now;
  ws.send(JSON.stringify({t:'state',room:ROOM,id:myId,name:NAME,x:+me.x.toFixed(3),y:+me.y.toFixed(3),tint:me.tint}));
}

/* ===== 상호작용 ===== */
let inConvo=false;
function closeDialog(){ dlg.style.display='none'; dgChoices.innerHTML=''; inConvo=false; }
dlg.addEventListener('click',(e)=>{ if(e.target===dlg) closeDialog(); });

function openGraveDialog(gr){
  blip(920,0.07,0.26);
  dgTitle.textContent='비석의 기록';
  dgBody.textContent=graveText(gr.x,gr.y);
  dgChoices.innerHTML='';
  dlg.style.display='flex';
}
const convo=[
  {npc:"Opportunity: …신호 포착. 너는 소리를 어떻게 듣지?",
   choices:["몸으로 먼저 듣는다.","기억으로 해석한다."],
   replies:["좋아. 몸은 진실을 숨기지 않지.","그래, 기억은 언제나 편집본이야."]},
  {npc:"여기 비석들은 잊힌 말들의 좌표야.",
   choices:["좌표를 따라가면 어디에 닿을까?","말이 사라지면 무엇이 남지?"],
   replies:["아마 네가 모르는 너에게.","침묵. 그리고 방향."]},
  {npc:"마지막 질문. 너는 왜 계속 걷고 있어?",
   choices:["누군가의 잔향을 찾고 있어.","멈추면, 들리지 않을까 봐."],
   replies:["그 잔향이 네 지도를 바꿀 거야.","걷는 침묵은 언제나 열려 있지."]},
];
let stepIdx=0;
function openOppConvo(){
  inConvo=true; stepIdx=0; renderConvoStep();
  dlg.style.display='flex'; blip(700,0.07,0.23);
}
function renderConvoStep(){
  const s=convo[stepIdx];
  dgTitle.textContent='대화 — Spirit × Opportunity';
  dgBody.innerHTML=`<div style="white-space:pre-wrap">${s.npc}</div>`;
  dgChoices.innerHTML='';
  s.choices.forEach((text,i)=>{
    const b=document.createElement('button'); b.textContent=text;
    b.onclick=()=>{
      blip(660,0.06,0.22);
      const reply=s.replies[i];
      dgBody.innerHTML+=`\n\n> Spirit: ${text}\nOpportunity: ${reply}`;
      stepIdx++;
      if(stepIdx<convo.length){ setTimeout(()=>renderConvoStep(),420); }
      else{ dgChoices.innerHTML=''; const done=document.createElement('button'); done.textContent='끝내기'; done.onclick=()=> closeDialog(); dgChoices.appendChild(done); }
    };
    dgChoices.appendChild(b);
  });
}

/* ===== 이동/그리기 ===== */
function moveEntity(e,ax,ay){
  const sp=e.spd||0.08; let nx=e.x+ax*sp, ny=e.y+ay*sp;
  if(!solidAt(room, nx|0, e.y|0)) e.x=nx;
  if(!solidAt(room, e.x|0, ny|0)) e.y=ny;
}
function drawMap(){
  g.fillStyle = room===0 ? '#1b142a' : '#131c2a'; g.fillRect(0,0,cv.width,cv.height);
  const L=room===0?LEVEL0:LEVEL1;
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    if(L[y][x]===1){
      g.fillStyle=room===0 ? '#6d58a5' : '#35506d'; g.fillRect(x*TILE,y*TILE,TILE,TILE);
      g.fillStyle='rgba(0,0,0,.35)'; g.fillRect(x*TILE,y*TILE+TILE-4,TILE,4);
    }
  }
  g.fillStyle=room===0?'#584787':'#2c4058'; g.fillRect(6*TILE,(H-1)*TILE,8*TILE,TILE);
  if(room===1){
    PHONES.forEach(([x,y])=>{
      const px=x*TILE, py=y*TILE;
      g.fillStyle='#d63c2f'; g.fillRect(px+4,py+8,16,10);
      g.fillStyle='#e9c8a8'; g.fillRect(px+8,py+10,8,5);
      g.fillStyle='rgba(0,0,0,.3)'; g.fillRect(px+4,py+TILE-3,16,3);
    });
  }
}
function drawSpirit(p){
  const px=Math.round(p.x*TILE - TILE/2), py=Math.round(p.y*TILE - TILE/2);
  g.fillStyle='rgba(0,0,0,.5)'; g.fillRect(px+3,py+TILE-3,TILE-6,3);
  g.fillStyle=p.tint; g.fillRect(px+5,py+10,14,7);
  g.fillStyle='#ffffff'; g.fillRect(px+7,py+6,10,3);
  g.fillStyle='#222'; g.fillRect(px+5,py+17,14,2);
  g.fillStyle='rgba(0,0,0,.55)'; const labelW=Math.max(40, p.name.length*6);
  g.fillRect(px+8 - labelW/2, py-12, labelW, 12);
  g.fillStyle='#fff'; g.font='9px ui-monospace'; g.fillText(p.name, px+10 - labelW/2, py-3);
}
function drawOpportunity(){
  if(room!==0) return;
  const px=Math.round(opp.x*TILE - TILE/2), py=Math.round(opp.y*TILE - TILE/2);
  g.fillStyle='rgba(0,0,0,.5)'; g.fillRect(px+3,py+TILE-3,TILE-6,3);
  g.fillStyle='#b6c3cf'; g.fillRect(px+5,py+10,14,7);
  g.fillStyle='#e7f3ff'; g.fillRect(px+6,py+7,12,3);
  g.fillStyle='#8bb7ff'; g.fillRect(px+11,py+8,3,2);
  g.fillStyle='rgba(0,0,0,.55)'; g.fillRect(px-12, py-12, 80, 12);
  g.fillStyle='#fff'; g.font='9px ui-monospace'; g.fillText('Opportunity', px-10, py-3);
}

/* ===== 루프 ===== */
let last=0; hud.textContent='오프라인 모드(서버 미연결)'; // 최소 표시
function update(dt){
  let ax=0,ay=0;
  if(keys.has('a')||keys.has('arrowleft')) ax-=1; if(keys.has('d')||keys.has('arrowright')) ax+=1;
  if(keys.has('w')||keys.has('arrowup')) ay-=1; if(keys.has('s')||keys.has('arrowdown')) ay+=1;
  ax+=dstate.ax; ay+=dstate.ay; const m=Math.hypot(ax,ay)||1; ax/=m; ay/=m;
  if(!inConvo) moveEntity(me,ax,ay);
  if(!inConvo && (me.y|0)===H-1 && (me.x|0)>=6 && (me.x|0)<=13){ room=room===0?1:0; blip(820,0.06,0.26); me.y=H-2.2; }
  Opportunity.step();

  // 상호작용
  let label="", action=null;
  if(room===0){
    if(!inConvo && Math.hypot(me.x-opp.x,me.y-opp.y)<0.95){ label='E: Opportunity와 대화'; action=()=> openOppConvo(); }
    else{ const ng=nearestGrave(me.x,me.y); if(ng.grave && ng.dist<1.1){ label='E: 비석에 귀 기울이기'; action=()=> openGraveDialog(ng.grave); } }
  }else{
    const np=nearestPhone(me.x,me.y); if(np.phone && np.dist<1.1){ label='E: 수화기 들기'; action=()=>{ blip(660,0.12,0.28); dgTitle.textContent='전화기의 방'; dgBody.textContent='...여보세요? (침묵 속의 목소리가 미세하게 울린다)'; dgChoices.innerHTML=''; dlg.style.display='flex'; }; }
  }
  if(action){ btnE.style.display='grid'; btnE.textContent=label; btnE.onclick=action; } else { btnE.style.display='none'; btnE.onclick=null; }
}
function render(){
  drawMap(); drawOpportunity(); others.forEach(o=>drawSpirit(o)); drawSpirit(me);
}
function loop(t){
  requestAnimationFrame(loop);
  const dt=Math.min(32,(t-last)||16); last=t;
  update(dt/16); render(); sendState(t);
}
requestAnimationFrame(loop);

/* ===== 키보드 E ===== */
addEventListener('keydown', e=>{ if(e.key==='e'||e.key==='E'){ if(getComputedStyle(btnE).display!=='none'){ e.preventDefault(); btnE.click(); } }});
</script>
</body>
</html>