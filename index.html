<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>LIMEN WORKSHOP â€“ Monitorable Sound/Touch Reactive Field</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;}

  /* ENTRY (ë ‰ ì‹œ ì—¬ê¸°ë¡œ ë˜ëŒì•„ì˜´) */
  #hint{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.72);
    color:#ddd; font-family:system-ui, -apple-system, sans-serif;
    text-align:center; padding:20px;
    z-index:50;
  }
  #hint .box{
    width:min(720px, 94vw);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:18px 16px;
    background:rgba(0,0,0,.55);
    text-align:left;
  }

  /* Top-left / Top-right buttons */
  #topLeft{
    position:fixed; left:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  #topRight{
    position:fixed; right:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  .iconBtn{
    width:42px; height:42px;
    display:grid; place-items:center;
    background:rgba(0,0,0,.38);
    color:#eee;
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px;
    backdrop-filter: blur(10px);
    cursor:pointer;
    user-select:none;
    font-size:18px;
  }
  .iconBtn:hover{border-color:rgba(255,255,255,.30)}
  .iconBtn:active{transform:translateY(1px)}
  .iconBtn.danger{
    border-color:rgba(255,80,80,.55);
    color:#ffb9b9;
  }
  .iconBtn.danger:hover{border-color:rgba(255,120,120,.75)}

  /* tiny HUD for touch */
  #touchHUD{
    position:fixed; left:12px; bottom:12px;
    z-index:39;
    color:#ddd;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:8px 10px;
    backdrop-filter: blur(10px);
    pointer-events:none;
  }
  #touchHUD .bar{height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;border:1px solid rgba(255,255,255,.10);margin-top:6px;}
  #touchHUD .bar i{display:block;height:100%;width:0%;background:rgba(255,80,80,.90);}

  /* Entry header */
  .entryTitle{font-weight:900; font-size:16px; margin-bottom:10px;}
  .entryGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  @media (min-width:720px){
    .entryGrid{grid-template-columns: 1fr 1fr;}
  }
  .entryCard{
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px;
    background:rgba(0,0,0,.20);
  }
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0;}
  .label{font-size:12px; color:#aaa; width:132px;}
  .grow{flex:1; min-width:200px;}
  button, select, input[type="range"], input[type="number"]{
    background:#0f0f0f; color:#eee;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:8px 10px;
    font-weight:650;
    outline:none;
  }
  input[type="range"]{padding:6px 10px;}
  button:hover, select:hover{border-color:rgba(255,255,255,.32)}
  button:disabled, select:disabled{opacity:.5; cursor:not-allowed}
  .small{font-size:11px; color:#9aa; line-height:1.45;}
  .fileLine{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .fileLine input[type="file"]{
    padding:6px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.22);
    color:#ddd;
  }

  /* tiny status pill */
  #pillMini{
    position:fixed; left:12px; top:62px;
    z-index:39;
    color:#bbb;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    padding:7px 9px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.28);
    backdrop-filter: blur(10px);
    user-select:none;
  }
</style>
</head>
<body>

<!-- ENTRY (ë ‰ ì‹œ ì—¬ê¸°ë¡œ ë˜ëŒì•„ì˜´) -->
<div id="hint">
  <div class="box">
    <div class="entryTitle">LIMEN WORKSHOP â€“ Entry</div>
    <div class="small" style="margin-bottom:12px;">
      1) <b>Start Audio</b>ë¡œ ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œ<br/>
      2) ì—¬ê¸°ì„œ <b>Mic / File</b> ì„ íƒ í›„ <b>Mic ON</b> ë˜ëŠ” <b>File Play</b>ë¡œ ì…ì¥<br/>
      3) TouchMeëŠ” ì…ì¥ í›„(ë˜ëŠ” ì§€ê¸ˆë„) âš™ï¸ì—ì„œ <b>MIDI â†’ LEARN</b>
    </div>

    <div class="row" style="justify-content:space-between;">
      <div class="row" style="margin:0;">
        <button id="btnStartAudio">Start Audio</button>
        <button id="btnFS">Fullscreen</button>
      </div>
      <div class="small" id="startStatus" style="opacity:.9; margin-left:10px;"></div>
    </div>

    <div class="entryGrid">
      <!-- MIC/FILE ENTRY -->
      <div class="entryCard">
        <div class="row" style="margin-top:0;">
          <div class="label">Input</div>
          <select id="entrySelSrc" class="grow">
            <option value="mic" selected>Mic (Live input)</option>
            <option value="file">File (MP3/WAV)</option>
          </select>
        </div>

        <div id="entryMicBox">
          <div class="row">
            <div class="label">Mic device</div>
            <select id="entrySelMic" class="grow" disabled>
              <option>Start Audio í›„ ëª©ë¡ ë¡œë“œ</option>
            </select>
          </div>
          <div class="row">
            <button id="entryMicOn" class="grow" disabled>Mic ON (Enter)</button>
            <button id="entryMicOff" class="grow" disabled>Mic OFF</button>
          </div>
          <div class="small">Mic ONì„ ëˆ„ë¥´ë©´ Entry í™”ë©´ì´ ë‹«íˆê³ (ì…ì¥) ë¹„ì£¼ì–¼ì´ ì‹œì‘ë©ë‹ˆë‹¤.</div>
        </div>

        <div id="entryFileBox" style="display:none;">
          <div class="row">
            <div class="label">Audio file</div>
            <div class="grow">
              <div class="fileLine">
                <input id="entryFileAudio" type="file" accept="audio/*">
              </div>
              <div class="small" id="entryFileTxt">íŒŒì¼ ì„ íƒ í›„ Playë¡œ ì…ì¥</div>
            </div>
          </div>
          <div class="row">
            <button id="entryFilePlay" class="grow" disabled>Play (Enter)</button>
            <button id="entryFilePause" class="grow" disabled>Pause</button>
            <button id="entryFileStop" class="grow" disabled>Stop</button>
          </div>
        </div>
      </div>

      <!-- QUICK INFO -->
      <div class="entryCard">
        <div class="small" style="margin-bottom:8px;">
          âœ… ë ‰(í”„ë¦¬ì¦ˆ/ê³¼ë¶€í•˜) ê°ì§€ ì‹œ <b>ìë™ìœ¼ë¡œ ì´ Entry í™”ë©´ìœ¼ë¡œ ë˜ëŒì•„ì˜µë‹ˆë‹¤</b>.<br/>
          (í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ì´ ì•„ë‹ˆë¼ â€œì…ì¥ ë‹¨ê³„ë¡œ ë³µê·€â€)
        </div>
        <div class="small" style="margin-bottom:8px;">
          âœ… ì»¨íŠ¸ë¡¤ì€ ìš°ì¸¡ ìƒë‹¨ âš™ï¸ â†’ <b>Control Tower(íŒì—…)</b>ë¡œ ì—´ë¦½ë‹ˆë‹¤.<br/>
          (ë¹”í”„ë¡œì í„°ëŠ” í’€ìŠ¤í¬ë¦° ìœ ì§€ + ë…¸íŠ¸ë¶ì—ì„œ íŒì—…ìœ¼ë¡œ ì»¨íŠ¸ë¡¤)
        </div>
        <div class="small">
          âœ… â€œFX Preset(5ê°œ)â€ë¥¼ ì¶”ê°€í–ˆì–´ìš”. TouchMe ì‚¬ìš´ë“œë¥¼ ë°ì€ í†¤(í”¼ì•„ë…¸/ë§ˆë¦¼ë°”/íŒ¨ë“œ ë“±)ìœ¼ë¡œ ë°”ê¿”ê°€ë©° ì„ íƒ ê°€ëŠ¥.
        </div>
      </div>
    </div>
  </div>
</div>

<canvas id="c"></canvas>

<div id="pillMini">audio:off | src:off | q:1.00</div>

<div id="touchHUD">
  touch: <span id="hudTouch">0.000</span> | amp: <span id="hudAmp">0.000</span><br/>
  <span id="hudMidi">midi: -</span>
  <div class="bar"><i id="hudTouchBar"></i></div>
</div>

<!-- Left top quick -->
<div id="topLeft">
  <div class="iconBtn danger" id="btnReset" title="RESET (Back to Entry)">âŸ²</div>
</div>

<!-- Top right quick -->
<div id="topRight">
  <div class="iconBtn" id="btnGear" title="Control Tower (Popup)">âš™ï¸</div>
  <div class="iconBtn" id="btnMuteQuick" title="Mute">ğŸ”ˆ</div>
  <div class="iconBtn" id="btnFSQuick" title="Fullscreen">â›¶</div>
</div>

<script>
/* ==========================================================
   SETTINGS PERSISTENCE (localStorage)
========================================================== */
const STORE_KEY = "limen_workshop_settings_v4_popup";
function loadSettings(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
function saveSettings(obj){ localStorage.setItem(STORE_KEY, JSON.stringify(obj)); }
const S = loadSettings();

function sget(id, fallback){ return (S[id] ?? fallback); }
function sset(id, val){ S[id]=val; saveSettings(S); }

/* ==========================================================
   CANVAS / DPR
========================================================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  W = innerWidth|0; H = innerHeight|0;
  canvas.width  = (W*DPR)|0;
  canvas.height = (H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

/* ==========================================================
   AUDIO CORE + ANALYSER
========================================================== */
let audioCtx;
let analyser, timeData;

let micStream = null;
let inputNode = null;

let masterGain, isMuted=false;

// EQ nodes
let eqLow, eqMid, eqHigh;

// FX nodes
let preGain, driveWS, driveGain, filter, ringOsc, ringGain, ringMult, dL, dR, merger, comp;
let splitter;

// extra â€œtoneâ€ helpers (preset-dependent)
let postLP, postHP;

let amp=0, ampSmooth=0, ampDelta=0, prevAmp=0;

// file source
let fileAudioEl = null;
let fileNode = null;
let currentSource = S.currentSource ?? "mic"; // "mic" | "file"

function makeWaveshaper(amount=20){
  const n=2048;
  const curve=new Float32Array(n);
  const k=amount;
  for(let i=0;i<n;i++){
    const x = (i*2/n)-1;
    curve[i] = (1+k)*x/(1+k*Math.abs(x));
  }
  return curve;
}

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  timeData = new Uint8Array(analyser.fftSize);

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;

  preGain = audioCtx.createGain(); preGain.gain.value = 1.0;

  // EQ (ê³µìš©)
  eqLow = audioCtx.createBiquadFilter();
  eqLow.type = "lowshelf";
  eqLow.frequency.value = 200;
  eqLow.gain.value = 0;

  eqMid = audioCtx.createBiquadFilter();
  eqMid.type = "peaking";
  eqMid.frequency.value = 1000;
  eqMid.Q.value = 1.0;
  eqMid.gain.value = 0;

  eqHigh = audioCtx.createBiquadFilter();
  eqHigh.type = "highshelf";
  eqHigh.frequency.value = 4000;
  eqHigh.gain.value = 0;

  // drive
  driveWS = audioCtx.createWaveShaper();
  driveWS.curve = makeWaveshaper(10);
  driveWS.oversample = '4x';
  driveGain = audioCtx.createGain(); driveGain.gain.value = 1.0;

  // main tone filter (bandpass default; presets can change params)
  filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 900;
  filter.Q.value = 2.0;

  // ring / AM
  ringOsc = audioCtx.createOscillator();
  ringOsc.type = 'sine';
  ringOsc.frequency.value = 35;

  ringGain = audioCtx.createGain();
  ringGain.gain.value = 0.0;

  ringMult = audioCtx.createGain();
  ringMult.gain.value = 1.0;
  ringOsc.connect(ringGain);
  ringGain.connect(ringMult.gain);

  // widen (dual short delays)
  splitter = audioCtx.createChannelSplitter(2);
  dL = audioCtx.createDelay(0.05);
  dR = audioCtx.createDelay(0.05);
  dL.delayTime.value = 0.004;
  dR.delayTime.value = 0.011;
  merger = audioCtx.createChannelMerger(2);

  // post tone polish
  postHP = audioCtx.createBiquadFilter();
  postHP.type = "highpass";
  postHP.frequency.value = 28;

  postLP = audioCtx.createBiquadFilter();
  postLP.type = "lowpass";
  postLP.frequency.value = 16000;
  postLP.Q.value = 0.7;

  comp = audioCtx.createDynamicsCompressor();
  comp.threshold.value = -22;
  comp.knee.value = 28;
  comp.ratio.value = 7;
  comp.attack.value = 0.003;
  comp.release.value = 0.14;

  // chain: input â†’ preGain â†’ EQ â†’ drive â†’ filter â†’ ring â†’ widen â†’ postHP/LP â†’ comp â†’ analyser â†’ master
  preGain.connect(eqLow);
  eqLow.connect(eqMid);
  eqMid.connect(eqHigh);

  eqHigh.connect(driveWS);
  driveWS.connect(driveGain);
  driveGain.connect(filter);
  filter.connect(ringMult);

  ringMult.connect(splitter);
  splitter.connect(dL, 0);
  splitter.connect(dR, 1);
  dL.connect(merger, 0, 0);
  dR.connect(merger, 0, 1);

  merger.connect(postHP);
  postHP.connect(postLP);
  postLP.connect(comp);

  comp.connect(analyser);
  analyser.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  ringOsc.start();

  updateMiniPill(1);
}

/* ==========================================================
   AUDIO PARAMS (no in-page UI: controlled by popup)
========================================================== */
function getMediaGain(){ return clamp(parseFloat(sget('rngMediaGain', 1.00)), 0.2, 3.0); }
function getSens(){ return clamp(parseFloat(sget('rngSens', 7.0)), 1, 12); }
function getGamma(){ return clamp(parseFloat(sget('rngGamma', 0.72)), 0.45, 1.20); }
function getCap(){ return clamp(parseFloat(sget('rngCap', 0.42)), 0.10, 0.70); }

function getEQLow(){ return clamp(parseFloat(sget('rngEQLow', 0)), -20, 20); }
function getEQMid(){ return clamp(parseFloat(sget('rngEQMid', 0)), -20, 20); }
function getEQHigh(){ return clamp(parseFloat(sget('rngEQHigh', 0)), -20, 20); }

function applyEQ(){
  if(!audioCtx || !eqLow) return;
  eqLow.gain.setTargetAtTime(getEQLow(), audioCtx.currentTime, 0.02);
  eqMid.gain.setTargetAtTime(getEQMid(), audioCtx.currentTime, 0.02);
  eqHigh.gain.setTargetAtTime(getEQHigh(), audioCtx.currentTime, 0.02);
}

function updateAmp(){
  if(!analyser) return;

  analyser.getByteTimeDomainData(timeData);
  let sum=0;
  for(let i=0;i<timeData.length;i++){
    const v=(timeData[i]-128)/128;
    sum+=v*v;
  }
  const rms=Math.sqrt(sum/timeData.length);

  const rmsG = rms * getMediaGain();
  ampSmooth += (rmsG-ampSmooth)*0.12;

  const boosted = Math.pow(Math.max(0, ampSmooth * getSens()), getGamma());
  const scaled = Math.min(getCap(), boosted);

  amp = scaled;
  ampDelta = Math.abs(amp - prevAmp);
  prevAmp = amp;
}

/* ==========================================================
   OUTPUT ROUTING (optional)
========================================================== */
const txtSupport = { value:"" };

let currentMicDeviceId = S.currentMicDeviceId ?? "default";
let outputSupported = false;

const monitorAudio = new Audio();
monitorAudio.autoplay = true;
monitorAudio.playsInline = true;
let monitorDest = null;

function setupOutputRouting(){
  if(!audioCtx) return;
  if(monitorDest) return;
  monitorDest = audioCtx.createMediaStreamDestination();
  masterGain.connect(monitorDest);
  monitorAudio.srcObject = monitorDest.stream;
}

async function listDevices(){
  let devices = [];
  try{ devices = await navigator.mediaDevices.enumerateDevices(); }catch(e){}
  const mics = devices.filter(d=>d.kind==="audioinput");
  const spks = devices.filter(d=>d.kind==="audiooutput");
  outputSupported = typeof monitorAudio.setSinkId === "function";

  // for popup UI
  publishToPopup({ type:"DEVICES", mics, spks, outputSupported, currentMicDeviceId, currentSpkDeviceId: S.currentSpkDeviceId ?? "" });

  if(outputSupported && S.currentSpkDeviceId){
    try{
      setupOutputRouting();
      await monitorAudio.setSinkId(S.currentSpkDeviceId);
    }catch(e){}
  }

  txtSupport.value =
    `ì§€ì› ìƒíƒœ: mic=${mics.length} | spk=${spks.length} | outputSelect=${outputSupported ? 'YES' : 'NO'}\n`+
    `ë ‰/í”„ë¦¬ì¦ˆ ê°ì§€ ì‹œ ìë™ìœ¼ë¡œ Entryë¡œ ë³µê·€ (SYSTEM > Auto Reboot)`;
}

/* ==========================================================
   INPUT SOURCE: MIC / FILE
========================================================== */
function disconnectInputs(){
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }
}

async function startMic(deviceId="default", hideEntry=true){
  ensureAudio();
  await audioCtx.resume();
  setupOutputRouting();

  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }

  try{
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: deviceId ? { exact: deviceId } : undefined,
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false
      }
    });

    const src = audioCtx.createMediaStreamSource(micStream);
    inputNode = src;
    src.connect(preGain);

    await listDevices();
    updateMiniPill(1);
    startStatus("Mic ON. (Entryì—ì„œ ë°”ë¡œ ì…ì¥ ê°€ëŠ¥)");
    publishToPopup({ type:"STATE", state: snapshotState() });

    if(hideEntry) hideEntryAndEnter();
  }catch(e){
    console.error(e);
    startStatus("Mic ON ì‹¤íŒ¨. ê¶Œí•œ/ì¥ì¹˜ ì„ íƒ í™•ì¸.");
    alert("ë§ˆì´í¬ ê¶Œí•œ ë˜ëŠ” ì¥ì¹˜ ì„ íƒì— ì‹¤íŒ¨í–ˆì–´ìš”. í¬ë¡¬ ê¶Œí•œ í™•ì¸!");
  }
}

function stopMic(){
  if(micStream){
    micStream.getTracks().forEach(t=>t.stop());
    micStream = null;
  }
  if(inputNode){
    try{ inputNode.disconnect(); }catch(e){}
    inputNode = null;
  }
  updateMiniPill(1);
  publishToPopup({ type:"STATE", state: snapshotState() });
}

function ensureFileAudioEl(){
  if(fileAudioEl) return;
  fileAudioEl = new Audio();
  fileAudioEl.crossOrigin = "anonymous";
  fileAudioEl.loop = true;
  fileAudioEl.preload = "auto";
  fileAudioEl.playsInline = true;
}

function connectFileToChain(){
  ensureAudio();
  ensureFileAudioEl();
  if(!fileAudioEl.src) return;

  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }

  try{
    fileNode = audioCtx.createMediaElementSource(fileAudioEl);
    fileNode.connect(preGain);
  }catch(e){
    // MediaElementSourceëŠ” ì—˜ë¦¬ë¨¼íŠ¸ë‹¹ 1íšŒ ì œí•œì´ë¼ ì¬ìƒì„± ë£¨íŠ¸
    try{
      const oldSrc = fileAudioEl.src;
      fileAudioEl.pause();
      fileAudioEl.srcObject = null;
      fileAudioEl = null;
      ensureFileAudioEl();
      fileAudioEl.src = oldSrc;
      fileNode = audioCtx.createMediaElementSource(fileAudioEl);
      fileNode.connect(preGain);
    }catch(err){
      console.error(err);
      alert("íŒŒì¼ ì†ŒìŠ¤ë¥¼ ì˜¤ë””ì˜¤ ì²´ì¸ì— ì—°ê²°í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆì–´ìš”.");
    }
  }
  updateMiniPill(1);
  publishToPopup({ type:"STATE", state: snapshotState() });
}

function startStatus(msg){
  const el = document.getElementById('startStatus');
  if(el) el.textContent = msg;
}

/* ==========================================================
   ENTRY UI (mic/file ì„ íƒ) - ë©”ì¸ í˜ì´ì§€ëŠ” Entryë§Œ ìœ ì§€
========================================================== */
const entrySelSrc = document.getElementById('entrySelSrc');
const entryMicBox = document.getElementById('entryMicBox');
const entryFileBox = document.getElementById('entryFileBox');

function applySourceUI(){
  currentSource = (S.currentSource ?? currentSource);
  entrySelSrc.value = currentSource;
  entryMicBox.style.display  = (currentSource==="mic")  ? "" : "none";
  entryFileBox.style.display = (currentSource==="file") ? "" : "none";
  updateMiniPill(1);
  publishToPopup({ type:"STATE", state: snapshotState() });
}

entrySelSrc.addEventListener('change', ()=>{
  currentSource = entrySelSrc.value;
  sset('currentSource', currentSource);
  applySourceUI();

  if(currentSource==="mic"){
    // file â†’ mic ì „í™˜
    if(fileAudioEl){ try{ fileAudioEl.pause(); }catch(e){} }
    if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode=null; }
    ampSmooth=amp=ampDelta=prevAmp=0;
  }else{
    // mic â†’ file ì „í™˜
    stopMic();
    if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode=null; }
    ampSmooth=amp=ampDelta=prevAmp=0;
    if(fileAudioEl && fileAudioEl.src){
      ensureAudio(); audioCtx.resume?.();
      connectFileToChain();
    }
  }
});

/* ==========================================================
   FILE CONTROLS (ENTRY)
========================================================== */
const entryFileAudio = document.getElementById('entryFileAudio');
const entryFilePlay  = document.getElementById('entryFilePlay');
const entryFilePause = document.getElementById('entryFilePause');
const entryFileStop  = document.getElementById('entryFileStop');
const entryFileTxt   = document.getElementById('entryFileTxt');

function setEntryFileBtns(enabled){
  entryFilePlay.disabled  = !enabled;
  entryFilePause.disabled = !enabled;
  entryFileStop.disabled  = !enabled;
}
setEntryFileBtns(false);

async function loadFileFromInput(file){
  if(!file) return;

  ensureAudio();
  await audioCtx.resume();
  setupOutputRouting();
  ensureFileAudioEl();

  const url = URL.createObjectURL(file);
  try{ fileAudioEl.pause(); }catch(e){}
  fileAudioEl.src = url;
  fileAudioEl.loop = true;

  entryFileTxt.textContent = `loaded: ${file.name} (${Math.round(file.size/1024)} KB)`;

  if(currentSource!=="file"){
    currentSource = "file";
    sset('currentSource', "file");
    applySourceUI();
  }

  connectFileToChain();
  setEntryFileBtns(true);
  updateMiniPill(1);
  publishToPopup({ type:"STATE", state: snapshotState() });
}

entryFileAudio.addEventListener('change', async ()=>{
  const f = entryFileAudio.files && entryFileAudio.files[0];
  if(!f) return;
  await loadFileFromInput(f);
});

/* ==========================================================
   ENTRY ENTER: Mic ON / File Play -> hide entry
========================================================== */
function hideEntryAndEnter(){
  document.getElementById('hint').style.display='none';
}
function showEntry(msg=""){
  document.getElementById('hint').style.display='flex';
  if(msg) startStatus(msg);
}

document.getElementById('entryMicOn').addEventListener('click', async ()=>{
  if(currentSource!=="mic") return;
  await startMic(currentMicDeviceId, true);
});
document.getElementById('entryMicOff').addEventListener('click', ()=> stopMic());

entryFilePlay.addEventListener('click', async ()=>{
  if(!fileAudioEl || !fileAudioEl.src) return;
  ensureAudio(); await audioCtx.resume();
  connectFileToChain();
  try{ await fileAudioEl.play(); }catch(e){
    alert("ì¬ìƒì´ ë§‰í˜”ì–´ìš”. í™”ë©´ì„ í•œë²ˆ í„°ì¹˜/í´ë¦­í•œ ë’¤ ë‹¤ì‹œ Play ëˆŒëŸ¬ì£¼ì„¸ìš”.");
    return;
  }
  updateMiniPill(1);
  publishToPopup({ type:"STATE", state: snapshotState() });
  hideEntryAndEnter();
});
entryFilePause.addEventListener('click', ()=>{
  if(!fileAudioEl) return;
  try{ fileAudioEl.pause(); }catch(e){}
  updateMiniPill(1);
  publishToPopup({ type:"STATE", state: snapshotState() });
});
entryFileStop.addEventListener('click', ()=>{
  if(!fileAudioEl) return;
  try{ fileAudioEl.pause(); fileAudioEl.currentTime = 0; }catch(e){}
  updateMiniPill(1);
  publishToPopup({ type:"STATE", state: snapshotState() });
});

/* ==========================================================
   ENTRY: Start Audio (unlock) + device list + MIDI init
========================================================== */
document.getElementById('btnStartAudio').addEventListener('click', async ()=>{
  ensureAudio();
  await audioCtx.resume();
  await listDevices();
  await initMIDI();
  // Entryì—ì„œ mic ì„ íƒ enable
  const entrySelMic = document.getElementById('entrySelMic');
  entrySelMic.disabled = false;
  startStatus("Audio unlocked. ì´ì œ Mic/File ì„ íƒ í›„ Enter ë²„íŠ¼ìœ¼ë¡œ ì…ì¥!");
  publishToPopup({ type:"STATE", state: snapshotState() });
});

addEventListener('pointerdown', async ()=>{
  if(audioCtx && audioCtx.state==='suspended'){
    await audioCtx.resume();
  }
},{passive:true});

/* ==========================================================
   TOP BUTTONS
========================================================== */
function toggleFullscreen(){
  const el = document.documentElement;
  if(!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
}
document.getElementById('btnFS').addEventListener('click', toggleFullscreen);
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

document.getElementById('btnMuteQuick').addEventListener('click', ()=>{
  if(!audioCtx) return;
  isMuted = !isMuted;
  masterGain.gain.setTargetAtTime(isMuted?0:0.9, audioCtx.currentTime, 0.02);
  document.getElementById('btnMuteQuick').textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”ˆ';
  publishToPopup({ type:"STATE", state: snapshotState() });
});

/* ==========================================================
   MIDI (TouchMe) : (ê¸°ì¡´ êµ¬ì¡° ìœ ì§€ + popupì—ì„œ ì œì–´)
========================================================== */
let midiAccess = null;
let midiInput = null;

let touchRaw = 0;
let touch = 0;
let touchSmooth = 0;
let lastMidiAt = 0;

let midiName="MIDI: ?";
let midiLog = [];
let midiLearn = false;

function pushMidiLog(line){
  midiLog.push(line);
  if(midiLog.length>18) midiLog.shift();
  publishToPopup({ type:"MIDI_LOG", midiName, lines: midiLog.slice() });
}

function getMIDIDead(){ return clamp(parseFloat(sget('rngMIDIDead', 0.02)), 0, 0.25); }
function getMIDIGain(){ return clamp(parseFloat(sget('rngMIDIGain', 1.60)), 0.3, 3.0); }
function getMIDICurve(){ return clamp(parseFloat(sget('rngMIDICurve', 0.85)), 0.4, 2.8); }
function getMIDISmooth(){ return clamp(parseFloat(sget('rngMIDISmooth', 0.22)), 0.02, 0.50); }

function shapeMIDI(x){
  const inv = (String(sget('selMIDIInvert', "0")) === "1");
  if(inv) x = 1-x;

  const dead = getMIDIDead();
  if(x < dead) x = 0;
  else x = (x-dead) / (1-dead);

  x *= getMIDIGain();
  x = clamp(x, 0, 1);

  const curve = getMIDICurve();
  x = Math.pow(x, curve);
  return clamp(x, 0, 1);
}

function updateTouch(){
  const k = getMIDISmooth();
  touchSmooth += (touch - touchSmooth) * k;

  const now = performance.now();
  const idleMs = now - lastMidiAt;
  if(idleMs > 250 && !midiLearn){
    touch *= 0.985;
  }
}

function midiParseRaw(data){
  const st = data[0] & 0xF0;
  const ch = data[0] & 0x0F;
  const d1 = data[1] ?? 0;
  const d2 = data[2] ?? 0;

  let type = "other";
  if(st===0xB0) type="cc";
  else if(st===0x90) type="noteon";
  else if(st===0x80) type="noteoff";
  return {st, ch, d1, d2, type};
}

function midiMsgToValue(data){
  const st = data[0] & 0xF0;
  const ch = data[0] & 0x0F;
  const d1 = data[1] ?? 0;
  const d2 = data[2] ?? 0;

  const wantCh = parseInt(sget('selMIDICh', "-1"),10);
  if(wantCh !== -1 && ch !== wantCh) return null;

  const mode = String(sget('selMIDIType', "cc"));
  const num = clampInt(parseInt(sget('numMIDINum', 1),10), 0, 127);

  if(mode==="cc"){
    if(st !== 0xB0) return null;
    if(d1 !== num) return null;
    return { raw01: d2/127, ch, type:"cc", num:d1, val:d2 };
  }else{
    if(st !== 0x90 && st !== 0x80) return null;
    if(d1 !== num) return null;
    const vel = (st===0x80) ? 0 : d2;
    return { raw01: vel/127, ch, type:"note", num:d1, val:vel };
  }
}

async function initMIDI(){
  if(!navigator.requestMIDIAccess){
    midiName="MIDI: not supported";
    pushMidiLog("requestMIDIAccess ì—†ìŒ");
    publishToPopup({ type:"MIDI_SUPPORT", ok:false, msg:"âš ï¸ ì´ ë¸Œë¼ìš°ì €ëŠ” WebMIDIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. â†’ Sim Touchë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥" });
    return;
  }
  try{
    midiAccess = await navigator.requestMIDIAccess({sysex:false});
    midiAccess.onstatechange = ()=> rebuildMIDIInputs();
    rebuildMIDIInputs(true);
    publishToPopup({ type:"MIDI_SUPPORT", ok:true, msg:"âœ… WebMIDI OK. TouchMe ì—°ê²° í›„ LEARN ëˆ„ë¥´ê³  í•œ ë²ˆ í„°ì¹˜í•˜ì„¸ìš”." });
    pushMidiLog("MIDI ready.");
  }catch(e){
    console.error(e);
    midiName="MIDI: blocked";
    publishToPopup({ type:"MIDI_SUPPORT", ok:false, msg:"âš ï¸ MIDI ì ‘ê·¼ì´ ì°¨ë‹¨ë¨. Chrome ê¶Œí•œ/ë³´ì•ˆ(https) í™•ì¸." });
    pushMidiLog("MIDI access failed");
  }
}

function rebuildMIDIInputs(autoselect=false){
  if(!midiAccess){
    publishToPopup({ type:"MIDI_INPUTS", inputs:[], selected:"" });
    return;
  }
  const inputs = [...midiAccess.inputs.values()].map(i=>({id:i.id, name:i.name||("MIDI "+i.id.slice(0,6)+"â€¦")}));
  if(inputs.length===0){
    midiName="MIDI: no inputs";
    publishToPopup({ type:"MIDI_INPUTS", inputs:[], selected:"" });
    pushMidiLog("No MIDI devices. TouchMe USB/BT í™•ì¸.");
    return;
  }

  const savedId = S.midiInputId ?? "";
  const hasSaved = inputs.some(i=>i.id===savedId);

  let sel = "";
  if(hasSaved) sel = savedId;
  else if(autoselect) sel = inputs[0].id;

  publishToPopup({ type:"MIDI_INPUTS", inputs, selected: sel });
  if(sel) attachMIDIInput(sel);
}

function setLearn(on){
  midiLearn = !!on;
  publishToPopup({ type:"MIDI_LEARN", on:midiLearn });
  if(midiLearn) pushMidiLog("LEARN: TouchMeë¥¼ í•œ ë²ˆ í„°ì¹˜í•˜ì„¸ìš” (CC/NOTE ìë™ ë§¤í•‘).");
}

function attachMIDIInput(id){
  if(!midiAccess) return;
  const inp = [...midiAccess.inputs.values()].find(i=>i.id===id);
  if(!inp) return;

  if(midiInput) midiInput.onmidimessage = null;
  midiInput = inp;
  S.midiInputId = id;
  saveSettings(S);

  midiName = "MIDI: " + (midiInput.name || "input");
  pushMidiLog("Connected: " + midiName);

  midiInput.onmidimessage = (e)=>{
    const data = e.data;
    const r = midiParseRaw(data);
    lastMidiAt = performance.now();

    if(midiLearn){
      if(r.st===0xB0){
        sset('selMIDIType', "cc");
        sset('numMIDINum', r.d1);
        sset('selMIDICh', String(r.ch));
        pushMidiLog(`LEARN OK: CC #${r.d1} ch:${r.ch+1}`);
        setLearn(false);
        publishToPopup({ type:"STATE", state: snapshotState() });
      }else if(r.st===0x90 || r.st===0x80){
        sset('selMIDIType', "note");
        sset('numMIDINum', r.d1);
        sset('selMIDICh', String(r.ch));
        pushMidiLog(`LEARN OK: NOTE #${r.d1} ch:${r.ch+1}`);
        setLearn(false);
        publishToPopup({ type:"STATE", state: snapshotState() });
      }
    }

    const parsed = midiMsgToValue(data);
    if(!parsed){
      if(Math.random() < 0.18) pushMidiLog(`raw=[${[...data].join(',')}] (not mapped)`);
      return;
    }

    touchRaw = parsed.raw01;
    touch = shapeMIDI(touchRaw);

    if(Math.random() < 0.22){
      pushMidiLog(`mapped ${parsed.type} #${parsed.num} ch:${parsed.ch+1} -> touch=${touch.toFixed(3)}`);
    }
  };
}

/* ==========================================================
   FX PRESETS (5ê°œ) + Touch mapping
   - "ìš¸ì í•˜ì§€ ì•Šê²Œ": ring(AM) ê¹Šì´/í•„í„°/Që¥¼ í”„ë¦¬ì…‹ìœ¼ë¡œ ë°ê²Œ ì¡°ì •
========================================================== */
function getSimTouch(){ return clamp(parseFloat(sget('rngSimTouch', 0)), 0, 1); }
function getPreset(){ return String(sget('selPreset', "touch_glitch")); } // 5 presets
function presetLabel(k){
  const map = {
    touch_glitch: "Touch Glitch (original)",
    piano_room: "Piano Room (bright)",
    marimba_pop: "Marimba Pop (crispy)",
    warm_pad: "Warm Pad (soft)",
    clean_pulse: "Clean Pulse (minimal)"
  };
  return map[k] || k;
}

function applyPresetBase(){
  if(!audioCtx || !filter || !postLP || !postHP) return;
  const p = getPreset();

  // ê³µí†µ ì•ˆì „ ë² ì´ìŠ¤ (ë„ˆë¬´ íƒí•´ì§€ì§€ ì•Šê²Œ)
  postHP.frequency.setTargetAtTime(28, audioCtx.currentTime, 0.03);

  if(p==="touch_glitch"){
    filter.type = "bandpass";
    postLP.frequency.setTargetAtTime(16000, audioCtx.currentTime, 0.03);
  }else if(p==="piano_room"){
    filter.type = "peaking";
    filter.frequency.setTargetAtTime(1800, audioCtx.currentTime, 0.03);
    filter.Q.setTargetAtTime(0.9, audioCtx.currentTime, 0.03);
    postLP.frequency.setTargetAtTime(14000, audioCtx.currentTime, 0.03);
    postHP.frequency.setTargetAtTime(45, audioCtx.currentTime, 0.03);
  }else if(p==="marimba_pop"){
    filter.type = "bandpass";
    filter.frequency.setTargetAtTime(2400, audioCtx.currentTime, 0.03);
    filter.Q.setTargetAtTime(1.6, audioCtx.currentTime, 0.03);
    postLP.frequency.setTargetAtTime(15500, audioCtx.currentTime, 0.03);
    postHP.frequency.setTargetAtTime(55, audioCtx.currentTime, 0.03);
  }else if(p==="warm_pad"){
    filter.type = "lowpass";
    filter.frequency.setTargetAtTime(5200, audioCtx.currentTime, 0.03);
    filter.Q.setTargetAtTime(0.7, audioCtx.currentTime, 0.03);
    postLP.frequency.setTargetAtTime(12000, audioCtx.currentTime, 0.03);
    postHP.frequency.setTargetAtTime(35, audioCtx.currentTime, 0.03);
  }else if(p==="clean_pulse"){
    filter.type = "highpass";
    filter.frequency.setTargetAtTime(160, audioCtx.currentTime, 0.03);
    filter.Q.setTargetAtTime(0.8, audioCtx.currentTime, 0.03);
    postLP.frequency.setTargetAtTime(17000, audioCtx.currentTime, 0.03);
    postHP.frequency.setTargetAtTime(60, audioCtx.currentTime, 0.03);
  }
}

function applyFX(){
  if(!audioCtx) return;

  const sim = getSimTouch();
  const t = Math.max(touchSmooth, sim);

  // í”„ë¦¬ì…‹ ë² ì´ìŠ¤ ë¨¼ì €
  applyPresetBase();

  const p = getPreset();

  // í”„ë¦¬ì…‹ë³„ "ë°ê¸°/í”¼ì•„ë…¸ ëŠë‚Œ"ì„ ìœ„í•œ ë§¤í•‘
  // (drive ê³¼í•˜ë©´ ìš°ìš¸/ê±°ì¹ ì–´ì ¸ì„œ, piano ê³„ì—´ì€ driveë¥¼ ì–•ê²Œ)
  let driveAmt, preG, driveG, fHz, q, ringHz, ringDepth, widen;

  if(p==="touch_glitch"){
    driveAmt = 10 + t*95;
    preG = 0.85 + t*1.25;
    driveG = 0.95 + t*1.10;
    fHz = 180 + Math.pow(t, 1.35) * 7200;
    q = 1.0 + t*18.0;
    ringHz = 10 + t*360;
    ringDepth = t*0.95;
    widen = t;
  }else if(p==="piano_room"){
    // í”¼ì•„ë…¸/ë£¸: ë“œë¼ì´ë¸Œ ì•½, Q ë‚®ê²Œ, ringì€ ì–•ê³  ë°ì€ tremolo ëŠë‚Œ
    driveAmt = 4 + t*18;
    preG = 0.95 + t*0.55;
    driveG = 1.00 + t*0.35;
    fHz = 900 + Math.pow(t, 1.2) * 3600;
    q = 0.8 + t*2.2;
    ringHz = 3 + t*14;
    ringDepth = t*0.25;        // ê³¼í•œ AM ê¸ˆì§€
    widen = 0.35 + t*0.55;
  }else if(p==="marimba_pop"){
    // ë§ˆë¦¼ë°”: bandpassë¡œ ë°˜ì§, ringì€ ì•„ì£¼ ì–•ê²Œ + ë¹ ë¥¸ ìºë¦­í„°
    driveAmt = 6 + t*28;
    preG = 0.92 + t*0.75;
    driveG = 1.00 + t*0.55;
    fHz = 1200 + Math.pow(t, 1.25) * 5200;
    q = 1.2 + t*4.2;
    ringHz = 8 + t*55;
    ringDepth = t*0.18;
    widen = 0.25 + t*0.75;
  }else if(p==="warm_pad"){
    // íŒ¨ë“œ: ì €ì—­/ì¤‘ì—­ ë¶€ë“œëŸ½ê²Œ, ring ê±°ì˜ ì—†ê³  widenìœ¼ë¡œ ê³µê°„ê°
    driveAmt = 3 + t*10;
    preG = 0.92 + t*0.55;
    driveG = 0.98 + t*0.35;
    fHz = 800 + Math.pow(t, 1.1) * 2600;
    q = 0.7 + t*1.6;
    ringHz = 1.5 + t*6;
    ringDepth = t*0.10;
    widen = 0.45 + t*0.50;
  }else{ // clean_pulse
    // í´ë¦°: ë“œë¼ì´ë¸Œ ê±°ì˜ ì—†ìŒ, ring off ê°€ê¹Œì´, ëŒ€ì‹  í•„í„° ì»·ì˜¤í”„ë¡œ ë°˜ì‘
    driveAmt = 2 + t*6;
    preG = 0.95 + t*0.35;
    driveG = 1.00 + t*0.20;
    fHz = 400 + Math.pow(t, 1.3) * 8200;
    q = 0.75 + t*1.25;
    ringHz = 0.5 + t*3;
    ringDepth = t*0.06;
    widen = 0.15 + t*0.45;
  }

  driveWS.curve = makeWaveshaper(driveAmt);
  preGain.gain.setTargetAtTime(preG, audioCtx.currentTime, 0.03);
  driveGain.gain.setTargetAtTime(driveG, audioCtx.currentTime, 0.03);

  // filter params (preset baseì—ì„œ typeì€ ì´ë¯¸ ë°”ë€œ. ì—¬ê¸°ì„œëŠ” ì›€ì§ì„ë§Œ)
  filter.frequency.setTargetAtTime(fHz, audioCtx.currentTime, 0.03);
  filter.Q.setTargetAtTime(q, audioCtx.currentTime, 0.03);

  // ring / tremolo depth
  ringOsc.frequency.setTargetAtTime(ringHz, audioCtx.currentTime, 0.03);
  ringGain.gain.setTargetAtTime(ringDepth, audioCtx.currentTime, 0.03);

  // stereo widen (delay)
  const wob = (Math.sin(performance.now()*0.0017)*0.5+0.5);
  dL.delayTime.setTargetAtTime(0.0015 + widen*0.014 + wob*0.0012, audioCtx.currentTime, 0.05);
  dR.delayTime.setTargetAtTime(0.0040 + widen*0.020 + (1-wob)*0.0014, audioCtx.currentTime, 0.05);

  // popup í…”ë ˆë©”íŠ¸ë¦¬ìš©
  fxText = `preset:${presetLabel(p)} | drive:${driveAmt.toFixed(1)} | f:${fHz.toFixed(0)}Hz Q:${q.toFixed(2)} | ring:${ringHz.toFixed(1)}Hz depth:${ringDepth.toFixed(2)} | widen:${widen.toFixed(2)}`;
}

/* ==========================================================
   VISUAL PARAMS (ì†ë„ â€œì²œì²œíˆâ€ ë°˜ì˜: Speed slider ì¶”ê°€ + ê¸°ë³¸ ê°’ ë‚®ì¶¤)
========================================================== */
function getIdleDrama(){ return clamp(parseFloat(sget('rngIdleDrama', 0.55)), 0, 1); }
function getVisSens(){ return clamp(parseFloat(sget('rngVisSens', 1.55)), 0.6, 2.6); }
function getLineMul(){ return clamp(parseFloat(sget('rngLine', 0.75)), 0.2, 1.2); }
function getPerfLim(){ return clamp(parseFloat(sget('rngPerf', 0.72)), 0.25, 1.0); }
function getFade(){ return clamp(parseFloat(sget('rngFade', 0.03)), 0.02, 0.20); }
function getPointSize(){ return clamp(parseFloat(sget('rngPointSize', 0.60)), 0.4, 1.2); }
function getGlow(){ return clamp(parseFloat(sget('rngGlow', 0.45)), 0.10, 1.0); }
function getSpeedMul(){ return clamp(parseFloat(sget('rngSpeed', 0.62)), 0.35, 1.15); } // âœ… ê¸°ë³¸ â€œëŠë¦¬ê²Œâ€
function getPointColor(){
  return (String(sget('selPointColor', 'red')) === "red") ? "#ff3b3b" : "#ffffff";
}

let N = parseInt(sget('selN', 220),10) || 220;
let pts = [];
let rot = 0;

const BASE_QUIET_TH = 0.0032;
const BASE_ACTIVE_TH = 0.0065;
const BASE_ONSET_TH  = 0.0060;

let energy = 0;
let burstEnergy = 0;

function initPoints(){
  pts = [];
  for(let i=0;i<N;i++){
    pts.push({
      x:(Math.random()*2-1)*(W*0.34),
      y:(Math.random()*2-1)*(H*0.34),
      z:(Math.random()*2-1)*340,
      vx:0,vy:0,vz:0
    });
  }
}
initPoints();

function project(p){
  const s=Math.sin(rot), c=Math.cos(rot);
  const x = p.x*c - p.z*s;
  const z = p.x*s + p.z*c;
  const depth = 900;
  const k = depth/(depth+z);
  return { x:x*k + W/2, y:p.y*k + H/2, k, z };
}

function applyBounds(p, mode){
  if(mode==="wrap"){
    const maxX=W*0.65, maxY=H*0.65, maxZ=560;
    if(p.x> maxX) p.x=-maxX;
    if(p.x<-maxX) p.x= maxX;
    if(p.y> maxY) p.y=-maxY;
    if(p.y<-maxY) p.y= maxY;
    if(p.z> maxZ) p.z=-maxZ;
    if(p.z<-maxZ) p.z= maxZ;
    return;
  }

  const maxX=W*0.58, maxY=H*0.58, maxZ=560;

  if(mode==="bounce"){
    if(p.x> maxX){ p.x=maxX; p.vx*=-0.7; }
    if(p.x<-maxX){ p.x=-maxX; p.vx*=-0.7; }
    if(p.y> maxY){ p.y=maxY; p.vy*=-0.7; }
    if(p.y<-maxY){ p.y=-maxY; p.vy*=-0.7; }
    if(p.z> maxZ){ p.z=maxZ; p.vz*=-0.7; }
    if(p.z<-maxZ){ p.z=-maxZ; p.vz*=-0.7; }
    return;
  }

  const pull = 0.0026;
  const edgeX = Math.max(0, Math.abs(p.x) - maxX);
  const edgeY = Math.max(0, Math.abs(p.y) - maxY);
  const edgeZ = Math.max(0, Math.abs(p.z) - maxZ);
  if(edgeX>0) p.vx += (-Math.sign(p.x)) * edgeX * pull;
  if(edgeY>0) p.vy += (-Math.sign(p.y)) * edgeY * pull;
  if(edgeZ>0) p.vz += (-Math.sign(p.z)) * edgeZ * pull;
}

/* ==========================================================
   ENTRY REBOOT (í•µì‹¬)
========================================================== */
function clearRuntime(){
  amp = 0; ampSmooth = 0; ampDelta = 0; prevAmp = 0;
  touchRaw = 0; touch = 0; touchSmooth = 0; lastMidiAt = 0;
  energy = 0; burstEnergy = 0; rot = 0;
  initPoints();

  document.getElementById('hudMidi').textContent = "midi: -";
  document.getElementById('hudTouch').textContent = "0.000";
  document.getElementById('hudAmp').textContent = "0.000";
  document.getElementById('hudTouchBar').style.width = "0%";

  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,W,H);
}

async function entryReboot(reason="lag"){
  console.warn("ENTRY REBOOT:", reason);

  try{ stopMic(); }catch(e){}
  try{
    if(fileAudioEl){
      try{ fileAudioEl.pause(); }catch(e){}
      // íŒŒì¼ ì„ íƒì€ ìœ ì§€(Entryì—ì„œ Play ê°€ëŠ¥)
    }
  }catch(e){}

  try{ disconnectInputs(); }catch(e){}
  fileNode = null;
  inputNode = null;

  // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë‹«ì•„ â€œStart Audioâ€ ë‹¨ê³„ë¡œ ë˜ëŒë¦¼
  try{
    if(audioCtx){
      try{ await audioCtx.close(); }catch(e){}
    }
  }catch(e){}

  audioCtx = null;
  analyser = null;
  timeData = null;
  masterGain = null;
  preGain = null;
  eqLow = eqMid = eqHigh = null;
  driveWS = driveGain = null;
  filter = null;
  ringOsc = null;
  ringGain = null;
  ringMult = null;
  splitter = null;
  dL = dR = null;
  merger = null;
  postHP = postLP = null;
  comp = null;
  monitorDest = null;

  clearRuntime();
  updateMiniPill(1);

  // Entry UI reset
  document.getElementById('entrySelMic').disabled = true;
  document.getElementById('entrySelMic').innerHTML = `<option>Start Audio í›„ ëª©ë¡ ë¡œë“œ</option>`;
  document.getElementById('entryMicOn').disabled = true;
  document.getElementById('entryMicOff').disabled = true;

  showEntry(`ë ‰ ê°ì§€ â†’ Entryë¡œ ë³µê·€ (reason: ${reason})`);
  publishToPopup({ type:"STATE", state: snapshotState() });
}

document.getElementById("btnReset").addEventListener("click", ()=> entryReboot("manual reset"));

/* ==========================================================
   AUTO REBOOT ON LAG / FREEZE
========================================================== */
function autoRebootEnabled(){ return (String(sget('selAutoReboot', "1")) === "1"); }

let lastFrameT = performance.now();
let frameMsSmooth = 16.7;
let lagTimer = 0;

let lastAnimTick = performance.now();
setInterval(()=>{
  const now = performance.now();
  if(!autoRebootEnabled()) return;
  if(now - lastAnimTick > 1600){
    entryReboot("freeze watchdog");
    lastAnimTick = now;
  }
}, 400);

function checkLag(dt){
  if(!autoRebootEnabled()) return;
  if(dt > 45){
    lagTimer += dt;
    if(lagTimer > 2200){
      entryReboot("lag reboot");
      lagTimer = 0;
    }
  }else{
    lagTimer = Math.max(0, lagTimer - 50);
  }
}

/* ==========================================================
   MAIN LOOP
========================================================== */
let lastUiT = 0;
let fxText = "preset:-";
function loop(){
  const now = performance.now();
  lastAnimTick = now;

  const dt = now - lastFrameT;
  lastFrameT = now;
  frameMsSmooth += (dt - frameMsSmooth) * 0.08;

  checkLag(dt);

  let qAuto = 1 - Math.max(0, (frameMsSmooth - 16) / 45);
  qAuto = clamp(qAuto, 0.28, 1);
  const q = Math.min(qAuto, getPerfLim());

  ctx.fillStyle = `rgba(0,0,0,${getFade().toFixed(3)})`;
  ctx.fillRect(0,0,W,H);

  if(audioCtx){
    applyEQ();
    updateAmp();
  }else{
    amp = 0; ampDelta = 0;
  }

  updateTouch();
  if(audioCtx) applyFX();

  // HUD + popup telemetry
  if(now - lastUiT > 110){
    lastUiT = now;
    const sim = getSimTouch();
    const tv = Math.max(touchSmooth, sim);

    document.getElementById('hudTouch').textContent = tv.toFixed(3);
    document.getElementById('hudAmp').textContent = amp.toFixed(3);
    document.getElementById('hudMidi').textContent = midiName;
    document.getElementById('hudTouchBar').style.width = (tv*100).toFixed(1)+"%";

    updateMiniPill(q);

    publishToPopup({
      type:"TELEM",
      amp, ampDelta, touch:tv,
      frameMs: frameMsSmooth,
      q,
      fxText,
      src: currentSource,
      audioState: audioCtx ? audioCtx.state : "off"
    });
  }

  const visSens = getVisSens();
  const idleDrama = getIdleDrama();

  const QUIET_TH = BASE_QUIET_TH / visSens;
  const ACTIVE_TH = BASE_ACTIVE_TH / visSens;
  const ONSET_TH  = BASE_ONSET_TH / visSens;

  const targetEnergy = (amp > ACTIVE_TH) ? 1 : (amp < QUIET_TH ? 0 : energy);
  energy += (targetEnergy - energy) * 0.05;

  const energyFloor = 0.04 + idleDrama * 0.20;
  energy = Math.max(energyFloor, energy);

  const onset = Math.max(0, (ampDelta - ONSET_TH));
  burstEnergy += (onset*8.0 - burstEnergy) * 0.12;
  burstEnergy *= 0.92;
  burstEnergy = Math.min(1.5, burstEnergy);

  const mode = String(sget('selMode', 'pulse'));
  const boundsMode = String(sget('selBounds', 'soft'));
  const quietLines = parseInt(sget('selQuietLines', 1),10);

  const t = now*0.001;
  const breathe = 0.5 + 0.5*Math.sin(t*1.2);

  const sim = getSimTouch();
  const touchV = Math.max(touchSmooth, sim);

  // âœ… ëŠë¦¬ê²Œ: baseSpeedë¥¼ ë‚®ì¶”ê³ , speedMul ìŠ¬ë¼ì´ë”ë¡œ ìµœì¢… ìŠ¤ì¼€ì¼
  const speedMul = getSpeedMul();
  const baseSpeedQuiet = (0.06 + idleDrama*0.03) * speedMul;
  const baseChaosQuiet = 0.48 + idleDrama*0.95;

  const baseSpeedActive = (0.08 + Math.min(0.18, amp*1.8)) * visSens * speedMul;

  const baseChaosActive =
    Math.min(28,
      (ampDelta*95) +
      (touchV*110) +
      burstEnergy*50
    ) * visSens;

  let speed = baseSpeedQuiet*(1-energy) + baseSpeedActive*energy;
  let chaos = baseChaosQuiet*(1-energy) + baseChaosActive*energy;

  if(mode==="calm"){ speed *= 0.90; chaos *= 0.72; }
  if(mode==="burst"){ speed *= 1.02; chaos *= 1.12; }

  const lineMul = getLineMul();
  const linkDistQuiet = 26 + idleDrama*10;
  const linkDistActiveRaw = (64 + amp*240 + touchV*520 + burstEnergy*110) * lineMul * visSens;
  const linkDistActive = Math.min(180, linkDistActiveRaw);
  const linkDist = linkDistQuiet*(1-energy) + linkDistActive*energy;

  const centerPull = (0.008 + touchV*0.028) * (1.0 - Math.min(1, amp*1.2)) * (0.75 + idleDrama*0.6);
  const burst = (amp*0.017 + ampDelta*0.060 + touchV*0.020 + burstEnergy*0.020) * visSens;

  const freeze = energy * Math.max(0, 1 - (ampDelta*20));
  const rotSpeedBase = (0.0010 + energy*0.008 + burstEnergy*0.007 + touchV*0.008) * (1 - 0.7*freeze);
  const rotSpeed = rotSpeedBase * (0.65 + idleDrama*0.8) * speedMul; // âœ… íšŒì „ë„ ëŠë¦¬ê²Œ
  rot += rotSpeed;

  const scale = 1.0 + energy*(breathe-0.5)*0.25;

  for(const p of pts){
    p.vx += (Math.random()-0.5)*chaos;
    p.vy += (Math.random()-0.5)*chaos;
    p.vz += (Math.random()-0.5)*chaos*0.55;

    p.vx += (-p.x)*centerPull*(0.9 - energy*0.4);
    p.vy += (-p.y)*centerPull*(0.9 - energy*0.4);
    p.vz += (-p.z)*centerPull*(0.6 - energy*0.2);

    p.vx += (p.x)*burst*energy;
    p.vy += (p.y)*burst*energy;
    p.vz += (p.z)*burst*energy*0.6;

    p.vx *= 0.90 - energy*0.05;
    p.vy *= 0.90 - energy*0.05;
    p.vz *= 0.92 - energy*0.04;

    // âœ… speedMulê°€ ì´ë¯¸ ë°˜ì˜ëœ speedë¥¼ ê³±í•´ ìµœì¢… ì´ë™ì´ ë” ì²œì²œíˆ
    p.x = (p.x + p.vx*speed) * scale + (1-scale)*p.x;
    p.y = (p.y + p.vy*speed) * scale + (1-scale)*p.y;
    p.z = (p.z + p.vz*speed) * (0.92 + 0.08*scale) + (1-(0.92 + 0.08*scale))*p.z;

    applyBounds(p, boundsMode);
  }

  const pr = pts.map(project);

  // lines
  if(energy > 0.05 || quietLines>0){
    const cell = Math.max(22, Math.floor(linkDist));
    const inv = 1 / cell;
    const grid = new Map();

    for(let i=0;i<N;i++){
      const a = pr[i];
      const cx = (a.x*inv)|0;
      const cy = (a.y*inv)|0;
      const key = (cx<<16) ^ (cy & 0xffff);
      let arr = grid.get(key);
      if(!arr){ arr=[]; grid.set(key, arr); }
      arr.push(i);
    }

    const baseMax = (1100 + energy*850 + burstEnergy*750 + touchV*700) * lineMul;
    const maxLines = Math.floor(baseMax * q);

    let linesDrawn = 0;
    const stride = (q < 0.45) ? 2 : 1;

    for(let i=0;i<N;i+=stride){
      if(linesDrawn >= maxLines) break;
      const a = pr[i];
      const cx = (a.x*inv)|0;
      const cy = (a.y*inv)|0;

      for(let oy=-1; oy<=1; oy++){
        for(let ox=-1; ox<=1; ox++){
          if(linesDrawn >= maxLines) break;

          const k = ((cx+ox)<<16) ^ ((cy+oy) & 0xffff);
          const bucket = grid.get(k);
          if(!bucket) continue;

          for(let bi=0; bi<bucket.length; bi++){
            const j = bucket[bi];
            if(j<=i) continue;

            const b = pr[j];
            const dx=a.x-b.x, dy=a.y-b.y;
            const d = Math.hypot(dx,dy);
            if(d<linkDist){
              const alpha = 1 - d/linkDist;

              const quietGain = (quietLines===0) ? 0 : (quietLines===1 ? 0.12 : 0.24);
              const onGain = 0.34 + amp*1.5*visSens + burstEnergy*1.6*visSens + touchV*1.4;
              const punch = Math.min(1, alpha * (quietGain*(1-energy) + onGain*energy));

              ctx.globalAlpha = punch * getGlow();
              ctx.strokeStyle = "rgba(255,255,255,0.9)";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(a.x,a.y);
              ctx.lineTo(b.x,b.y);
              ctx.stroke();

              linesDrawn++;
              if(linesDrawn >= maxLines) break;
            }
          }
        }
      }
    }
  }

  // points
  const glow = getGlow();
  const pSize = getPointSize();
  const pCol = getPointColor();

  for(let i=0;i<N;i++){
    const p = pr[i];

    const baseR = (0.6 + p.k*0.3) * pSize;
    const rQuiet = Math.max(0.9, baseR * (1.05 + idleDrama*0.15));
    const rActive = baseR * (1.15 + amp*2.2*visSens + touchV*1.6 + burstEnergy*0.9);
    const r = rQuiet*(1-energy) + rActive*energy;

    const aQuiet = 0.32 + idleDrama*0.12;
    const aActive = Math.min(1, 0.40 + amp*0.95*visSens + touchV*0.65 + burstEnergy*0.60);
    const a = aQuiet*(1-energy) + aActive*energy;

    ctx.globalAlpha = a * glow;
    ctx.fillStyle = pCol;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  requestAnimationFrame(loop);
}
loop();

/* ==========================================================
   CONTROL TOWER POPUP (âš™ï¸)
   - ë©”ì¸ í™”ë©´ ìœ„ì— UIë¥¼ ë„ìš°ì§€ ì•Šê³ , íŒì—…ì°½(ì»¨íŠ¸ë¡¤ íƒ€ì›Œ)ì—ì„œ ì¡°ì‘
========================================================== */
let ctrlWin = null;

function publishToPopup(payload){
  try{
    if(ctrlWin && !ctrlWin.closed){
      ctrlWin.postMessage(payload, "*");
    }
  }catch(e){}
}

function snapshotState(){
  return {
    settings: JSON.parse(JSON.stringify(S)),
    currentSource,
    audioState: audioCtx ? audioCtx.state : "off",
    muted: isMuted ? 1 : 0,
    micOn: micStream ? 1 : 0,
    fileLoaded: (fileAudioEl && fileAudioEl.src) ? 1 : 0,
    filePlaying: (fileAudioEl && fileAudioEl.src && !fileAudioEl.paused) ? 1 : 0,
    currentMicDeviceId,
    currentSpkDeviceId: S.currentSpkDeviceId ?? "",
    midiName,
    supportText: txtSupport.value
  };
}

function openControlTower(){
  // ì´ë¯¸ ì—´ë ¤ìˆìœ¼ë©´ í¬ì»¤ìŠ¤
  if(ctrlWin && !ctrlWin.closed){
    ctrlWin.focus();
    publishToPopup({ type:"STATE", state: snapshotState() });
    listDevices();
    return;
  }

  ctrlWin = window.open("", "LIMEN_CONTROL_TOWER",
    "width=580,height=820,menubar=no,toolbar=no,location=no,status=no,resizable=yes,scrollbars=yes");
  if(!ctrlWin){
    alert("íŒì—…ì´ ì°¨ë‹¨ëì–´ìš”. ë¸Œë¼ìš°ì €ì—ì„œ ì´ ì‚¬ì´íŠ¸ì˜ íŒì—… í—ˆìš©í•´ì¤˜ì•¼ â€˜Control Towerâ€™ê°€ ëœ¹ë‹ˆë‹¤!");
    return;
  }

  const popupHTML = buildControlTowerHTML();
  ctrlWin.document.open();
  ctrlWin.document.write(popupHTML);
  ctrlWin.document.close();

  // ìµœì´ˆ ìƒíƒœ/ë””ë°”ì´ìŠ¤ ë³´ë‚´ê¸°
  setTimeout(async ()=>{
    publishToPopup({ type:"STATE", state: snapshotState() });
    await listDevices();
    rebuildMIDIInputs(true);
  }, 80);
}

document.getElementById('btnGear').addEventListener('click', openControlTower);

window.addEventListener("message", async (ev)=>{
  const msg = ev.data || {};
  if(!msg || typeof msg !== "object") return;

  if(msg.type === "REQUEST_STATE"){
    publishToPopup({ type:"STATE", state: snapshotState() });
    await listDevices();
    rebuildMIDIInputs(true);
    return;
  }

  if(msg.type === "SET"){
    const { id, value } = msg;
    if(typeof id !== "string") return;

    // settings write
    sset(id, value);

    // immediate reactions
    if(id === "selN"){
      N = parseInt(value,10) || 220;
      initPoints();
    }
    if(id === "selPointColor"){
      // nothing else
    }
    if(id === "selAutoReboot"){
      // nothing else
    }

    publishToPopup({ type:"STATE", state: snapshotState() });
    return;
  }

  if(msg.type === "CMD"){
    const a = msg.action;
    if(a==="FULLSCREEN") toggleFullscreen();
    if(a==="MUTE"){
      if(!audioCtx) return;
      isMuted = !isMuted;
      masterGain.gain.setTargetAtTime(isMuted?0:0.9, audioCtx.currentTime, 0.02);
      document.getElementById('btnMuteQuick').textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”ˆ';
      publishToPopup({ type:"STATE", state: snapshotState() });
    }
    if(a==="RESET") entryReboot("manual reset (popup)");
    if(a==="AUDIO_UNLOCK"){
      ensureAudio();
      await audioCtx.resume();
      await listDevices();
      await initMIDI();
      // Entryì—ì„œ mic ì„ íƒ enable
      const entrySelMic = document.getElementById('entrySelMic');
      entrySelMic.disabled = false;
      startStatus("Audio unlocked. (from Control Tower)");
      publishToPopup({ type:"STATE", state: snapshotState() });
    }
    if(a==="SET_SOURCE"){
      const v = msg.value === "file" ? "file" : "mic";
      currentSource = v;
      sset('currentSource', v);
      applySourceUI();
    }
    if(a==="MIC_ON"){
      if(currentSource!=="mic") return;
      const dev = msg.deviceId || currentMicDeviceId;
      currentMicDeviceId = dev;
      sset('currentMicDeviceId', dev);
      await startMic(currentMicDeviceId, (msg.enter===1));
    }
    if(a==="MIC_OFF") stopMic();

    if(a==="SET_MIC_DEVICE"){
      currentMicDeviceId = msg.deviceId || "default";
      sset('currentMicDeviceId', currentMicDeviceId);
      // mic ì´ë¯¸ ì¼œì ¸ìˆìœ¼ë©´ ì¬ì‹œì‘
      if(currentSource==="mic" && micStream) await startMic(currentMicDeviceId, false);
      await listDevices();
      publishToPopup({ type:"STATE", state: snapshotState() });
    }

    if(a==="SET_SPK_DEVICE"){
      if(!outputSupported) return;
      sset('currentSpkDeviceId', msg.deviceId || "");
      try{
        ensureAudio();
        setupOutputRouting();
        await monitorAudio.setSinkId(msg.deviceId || "default");
      }catch(e){}
      await listDevices();
      publishToPopup({ type:"STATE", state: snapshotState() });
    }

    if(a==="FILE_LOAD_REQUEST"){
      // popupì—ì„œëŠ” íŒŒì¼ ì§ì ‘ ì„ íƒ ëª»í•˜ë‹ˆê¹Œ, Entryì—ì„œ ì„ íƒ ì•ˆë‚´ë§Œ
      showEntry("íŒŒì¼ì€ Entry í™”ë©´ì—ì„œ ì„ íƒí•´ì¤˜! (ë³´ì•ˆìƒ íŒì—…ì´ íŒŒì¼ ì„ íƒì„ ê°•ì œë¡œ ëª» ì—½ë‹ˆë‹¤)");
    }
    if(a==="FILE_PLAY"){
      if(!fileAudioEl || !fileAudioEl.src) return;
      ensureAudio(); await audioCtx.resume();
      connectFileToChain();
      try{ await fileAudioEl.play(); }catch(e){}
      if(msg.enter===1) hideEntryAndEnter();
      publishToPopup({ type:"STATE", state: snapshotState() });
    }
    if(a==="FILE_PAUSE"){
      if(!fileAudioEl) return;
      try{ fileAudioEl.pause(); }catch(e){}
      publishToPopup({ type:"STATE", state: snapshotState() });
    }
    if(a==="FILE_STOP"){
      if(!fileAudioEl) return;
      try{ fileAudioEl.pause(); fileAudioEl.currentTime = 0; }catch(e){}
      publishToPopup({ type:"STATE", state: snapshotState() });
    }

    if(a==="MIDI_INIT") await initMIDI();
    if(a==="MIDI_LEARN") setLearn(!midiLearn);
    if(a==="MIDI_ATTACH") attachMIDIInput(msg.id);

    return;
  }
});

/* popup HTML builder */
function buildControlTowerHTML(){
  // NOTE: popup ë‚´ë¶€ì—ì„œ UIë¥¼ ë§Œë“¤ê³ , postMessageë¡œ ë©”ì¸ì— SET/CMDë¥¼ ë³´ëƒ„
  const esc = (s)=> String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
  const initial = snapshotState();
  const initS = initial.settings || {};

  return `<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LIMEN â€“ Control Tower</title>
<style>
  html,body{margin:0;height:100%;background:#0a0a0a;color:#ddd;font-family:system-ui,-apple-system,sans-serif;}
  .wrap{padding:12px;}
  .top{
    display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    position:sticky; top:0; background:rgba(10,10,10,.92); backdrop-filter: blur(10px);
    padding:10px; border-bottom:1px solid rgba(255,255,255,.08); z-index:5;
  }
  .pill{
    margin-left:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px; color:#bbb;
    padding:6px 8px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:999px;
    background:rgba(0,0,0,.25);
    white-space:nowrap;
  }
  button, select, input[type="range"], input[type="number"]{
    background:#111; color:#eee;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:8px 10px;
    font-weight:650;
    outline:none;
  }
  input[type="range"]{padding:6px 10px;}
  button:hover, select:hover{border-color:rgba(255,255,255,.32)}
  .tabs{display:flex; gap:6px; padding:10px 0; flex-wrap:wrap;}
  .tab{
    padding:8px 10px; font-size:12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.04);
    cursor:pointer;
    user-select:none;
  }
  .tab.active{border-color:rgba(255,255,255,.34);background:rgba(255,255,255,.08);}
  .panel{display:none; padding:10px 0;}
  .panel.active{display:block;}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0;}
  .label{font-size:12px; color:#aaa; width:140px;}
  .grow{flex:1; min-width:220px;}
  .small{font-size:11px; color:#9aa; line-height:1.45;}
  .mono{
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px; color:#bbb;
    white-space:pre-wrap; word-break:break-word;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:10px;
    padding:8px;
    max-height:190px; overflow:auto;
  }
  .meter{height:10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);overflow:hidden;}
  .meter i{display:block;height:100%;width:0%;background:rgba(255,255,255,.85);}
  .two{display:flex; gap:10px; flex-wrap:wrap;}
  .box{
    flex:1; min-width:260px;
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px;
    background:rgba(0,0,0,.20);
  }
  .pillBtn{border-radius:999px;padding:6px 10px;font-size:12px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);cursor:pointer;}
  .pillBtn.on{border-color:rgba(255,255,255,.34);background:rgba(255,255,255,.10);}
</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <button id="cmdAudio">Start Audio</button>
      <button id="cmdFS">Fullscreen</button>
      <button id="cmdMute">Mute</button>
      <button id="cmdReset" style="border-color:rgba(255,80,80,.55);color:#ffb9b9;">RESET</button>
      <div class="pill" id="pillTop">loadingâ€¦</div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="visual">VISUAL</div>
      <div class="tab" data-tab="audio">AUDIO</div>
      <div class="tab" data-tab="midi">MIDI</div>
      <div class="tab" data-tab="system">SYSTEM</div>
    </div>

    <div id="pan-visual" class="panel active">
      <div class="row">
        <div class="label">Mode</div>
        <select id="selMode" class="grow">
          <option value="calm">Calm (quiet 3D dots)</option>
          <option value="pulse">Pulse (amp-driven)</option>
          <option value="burst">Burst (delta-driven)</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Particles</div>
        <select id="selN" class="grow">
          <option value="160">160</option>
          <option value="220">220</option>
          <option value="320">320</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Keep in screen</div>
        <select id="selBounds" class="grow">
          <option value="soft">Soft boundary</option>
          <option value="bounce">Bounce</option>
          <option value="wrap">Wrap</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Quiet lines</div>
        <select id="selQuietLines" class="grow">
          <option value="0">Off</option>
          <option value="1">Very subtle</option>
          <option value="2">On</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Point color</div>
        <select id="selPointColor" class="grow">
          <option value="red">Red</option>
          <option value="white">White</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Speed (slow)</div>
        <div class="grow">
          <input id="rngSpeed" type="range" min="0.35" max="1.15" step="0.01" value="0.62" style="width:100%;">
          <div class="small" id="txtSpeed">speed: 0.62Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Idle Drama</div>
        <div class="grow">
          <input id="rngIdleDrama" type="range" min="0" max="1" step="0.01" value="0.55" style="width:100%;">
          <div class="small" id="txtIdleDrama">idle drama: 0.55</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Visual Sens</div>
        <div class="grow">
          <input id="rngVisSens" type="range" min="0.6" max="2.6" step="0.01" value="1.55" style="width:100%;">
          <div class="small" id="txtVisSens">visual sens: 1.55Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Line density</div>
        <div class="grow">
          <input id="rngLine" type="range" min="0.2" max="1.2" step="0.01" value="0.75" style="width:100%;">
          <div class="small" id="txtLine">line density: 0.75Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Perf limit</div>
        <div class="grow">
          <input id="rngPerf" type="range" min="0.25" max="1" step="0.01" value="0.72" style="width:100%;">
          <div class="small" id="txtPerf">perf limit: 0.72</div>
        </div>
      </div>

      <div class="row">
        <div class="label">BG fade</div>
        <div class="grow">
          <input id="rngFade" type="range" min="0.02" max="0.20" step="0.005" value="0.03" style="width:100%;">
          <div class="small" id="txtFade">fade: 0.030</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Point size</div>
        <div class="grow">
          <input id="rngPointSize" type="range" min="0.4" max="1.2" step="0.01" value="0.60" style="width:100%;">
          <div class="small" id="txtPointSize">point size: 0.60Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Glow</div>
        <div class="grow">
          <input id="rngGlow" type="range" min="0.10" max="1.0" step="0.01" value="0.45" style="width:100%;">
          <div class="small" id="txtGlow">glow: 0.45Ã—</div>
        </div>
      </div>

      <div class="small">
        âœ… ì ë“¤ì´ ë„ˆë¬´ ë¹ ë¥´ë©´ <b>Speedâ†“</b> + <b>Perf limitâ†“</b> + <b>Line densityâ†“</b><br/>
        âœ… ì‹¬í•˜ê²Œ ë©ˆì¶”ë©´ ë©”ì¸ì´ <b>ìë™ìœ¼ë¡œ Entry</b>ë¡œ ë³µê·€í•©ë‹ˆë‹¤.
      </div>
    </div>

    <div id="pan-audio" class="panel">
      <div class="row">
        <div class="label">FX Preset</div>
        <select id="selPreset" class="grow">
          <option value="touch_glitch">Touch Glitch (original)</option>
          <option value="piano_room">Piano Room (bright)</option>
          <option value="marimba_pop">Marimba Pop (crispy)</option>
          <option value="warm_pad">Warm Pad (soft)</option>
          <option value="clean_pulse">Clean Pulse (minimal)</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Input level</div>
        <div class="grow"><div class="meter"><i id="meterIn"></i></div></div>
      </div>

      <div class="row">
        <div class="label">Media Gain</div>
        <div class="grow">
          <input id="rngMediaGain" type="range" min="0.2" max="3.0" step="0.01" value="1.00" style="width:100%;">
          <div class="small" id="txtMediaGain">media gain: 1.00Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Analysis Sens</div>
        <div class="grow">
          <input id="rngSens" type="range" min="1" max="12" step="0.1" value="7.0" style="width:100%;">
          <div class="small" id="txtSens">analysis sens: 7.0Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Gamma boost</div>
        <div class="grow">
          <input id="rngGamma" type="range" min="0.45" max="1.20" step="0.01" value="0.72" style="width:100%;">
          <div class="small" id="txtGamma">gamma: 0.72</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Amp cap</div>
        <div class="grow">
          <input id="rngCap" type="range" min="0.10" max="0.70" step="0.01" value="0.42" style="width:100%;">
          <div class="small" id="txtCap">amp cap: 0.42</div>
        </div>
      </div>

      <div class="row">
        <div class="label">EQ Low</div>
        <div class="grow">
          <input id="rngEQLow" type="range" min="-20" max="20" step="0.5" value="0" style="width:100%;">
          <div class="small" id="txtEQLow">low: 0 dB (200Hz)</div>
        </div>
      </div>
      <div class="row">
        <div class="label">EQ Mid</div>
        <div class="grow">
          <input id="rngEQMid" type="range" min="-20" max="20" step="0.5" value="0" style="width:100%;">
          <div class="small" id="txtEQMid">mid: 0 dB (1kHz)</div>
        </div>
      </div>
      <div class="row">
        <div class="label">EQ High</div>
        <div class="grow">
          <input id="rngEQHigh" type="range" min="-20" max="20" step="0.5" value="0" style="width:100%;">
          <div class="small" id="txtEQHigh">high: 0 dB (4kHz)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Amp / Î”</div>
        <div class="mono grow" id="txtAmp">amp: -</div>
      </div>
      <div class="row">
        <div class="label">FX (Touch)</div>
        <div class="mono grow" id="txtFx">preset:-</div>
      </div>

      <div class="small">
        âœ… í”„ë¦¬ì…‹ì„ ë°”ê¾¸ë©´ TouchMeê°€ ê°™ì€ ê°’ì´ë¼ë„ â€œë°ê¸°/ì§ˆê°â€ì´ ë‹¬ë¼ì ¸ìš”.<br/>
        âœ… ë„ˆë¬´ ê±°ì¹ ë©´ <b>Media Gainâ†“</b> ë˜ëŠ” <b>EQ Highâ†“</b>ë¡œ ì •ë¦¬.
      </div>
    </div>

    <div id="pan-midi" class="panel">
      <div class="row" style="justify-content:space-between;">
        <div class="small" id="txtMIDISupport" style="opacity:.95"></div>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button id="btnMIDIInit" class="pillBtn">Connect MIDI</button>
          <button id="btnMIDILearn" class="pillBtn">LEARN</button>
        </div>
      </div>

      <div class="two">
        <div class="box">
          <div class="row">
            <div class="label">MIDI Input</div>
            <select id="selMIDIIn" class="grow">
              <option value="">Loadingâ€¦</option>
            </select>
          </div>

          <div class="row">
            <div class="label">Map Source</div>
            <select id="selMIDIType" class="grow">
              <option value="cc">Control Change (CC)</option>
              <option value="note">Note Velocity</option>
            </select>
          </div>

          <div class="row">
            <div class="label">CC / Note#</div>
            <input id="numMIDINum" class="grow" type="number" min="0" max="127" step="1" value="1" />
          </div>

          <div class="row">
            <div class="label">Channel</div>
            <select id="selMIDICh" class="grow">
              <option value="-1">Any</option>
              ${Array.from({length:16}).map((_,i)=>`<option value="${i}">${i+1}</option>`).join('')}
            </select>
          </div>

          <div class="row">
            <div class="label">Invert</div>
            <select id="selMIDIInvert" class="grow">
              <option value="0">Normal</option>
              <option value="1">Invert (1-x)</option>
            </select>
          </div>

          <div class="row">
            <div class="label">Deadzone</div>
            <div class="grow">
              <input id="rngMIDIDead" type="range" min="0" max="0.25" step="0.005" value="0.02" style="width:100%;">
              <div class="small" id="txtMIDIDead">deadzone: 0.020</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Gain</div>
            <div class="grow">
              <input id="rngMIDIGain" type="range" min="0.3" max="3.0" step="0.01" value="1.60" style="width:100%;">
              <div class="small" id="txtMIDIGain">gain: 1.60Ã—</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Curve</div>
            <div class="grow">
              <input id="rngMIDICurve" type="range" min="0.4" max="2.8" step="0.01" value="0.85" style="width:100%;">
              <div class="small" id="txtMIDICurve">curve: 0.85 ( <1 = ë” ì˜ˆë¯¼ )</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Smoothing</div>
            <div class="grow">
              <input id="rngMIDISmooth" type="range" min="0.02" max="0.50" step="0.01" value="0.22" style="width:100%;">
              <div class="small" id="txtMIDISmooth">smooth: 0.22</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Sim Touch</div>
            <div class="grow">
              <input id="rngSimTouch" type="range" min="0" max="1" step="0.001" value="0" style="width:100%;">
              <div class="small">ë¯¸ë””ê°€ ë§‰íŒ í™˜ê²½ì—ì„œ ì´ ìŠ¬ë¼ì´ë”ë¡œ FX/ë¹„ì£¼ì–¼ í…ŒìŠ¤íŠ¸</div>
            </div>
          </div>
        </div>

        <div class="box">
          <div class="row">
            <div class="label">Touch value</div>
            <div class="grow"><div class="meter"><i id="meterTouch"></i></div></div>
          </div>

          <div class="row">
            <div class="label">Mapped</div>
            <div class="mono grow" id="txtMIDIRaw">raw: -</div>
          </div>

          <div class="row">
            <div class="label">Last MIDI(raw)</div>
            <div class="mono grow" id="txtMIDILast">Waitingâ€¦</div>
          </div>

          <div class="row">
            <div class="label">MIDI log</div>
            <div class="mono grow" id="txtMIDI">Waitingâ€¦</div>
          </div>

          <div class="small">
            âœ… <b>LEARN</b> ëˆ„ë¥´ê³  TouchMe í•œë²ˆ í„°ì¹˜ â†’ ìë™ ë§¤í•‘<br/>
            âœ… logê°€ ê°±ì‹ ë˜ë©´ <b>ë¯¸ë””ëŠ” ë“¤ì–´ì˜¤ê³  ìˆìŒ</b>
          </div>
        </div>
      </div>
    </div>

    <div id="pan-system" class="panel">
      <div class="row">
        <div class="label">Input source</div>
        <select id="selSrc" class="grow">
          <option value="mic">Mic</option>
          <option value="file">File</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Mic device</div>
        <select id="selMic" class="grow">
          <option value="default">Loadingâ€¦</option>
        </select>
      </div>

      <div class="row">
        <button id="btnMicOn" class="grow">Mic ON</button>
        <button id="btnMicOff" class="grow">Mic OFF</button>
      </div>

      <div class="row">
        <div class="label">Audio file</div>
        <button id="btnFileHelp" class="grow">íŒŒì¼ ì„ íƒì€ Entryì—ì„œ</button>
      </div>

      <div class="row">
        <button id="btnFilePlay" class="grow">File Play</button>
        <button id="btnFilePause" class="grow">Pause</button>
        <button id="btnFileStop" class="grow">Stop</button>
      </div>

      <div class="row">
        <div class="label">Speaker output</div>
        <select id="selSpk" class="grow">
          <option value="">Loadingâ€¦</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Auto Reboot</div>
        <select id="selAutoReboot" class="grow">
          <option value="1">ON (lag/freeze â†’ ENTRY)</option>
          <option value="0">OFF</option>
        </select>
      </div>

      <div class="small" id="txtSupport"></div>
      <div class="small">â€» íŒì—… ì»¨íŠ¸ë¡¤ì€ ë©”ì¸ í™”ë©´ì„ ê°€ë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤(ë¹”í”„ë¡œì í„° í’€ìŠ¤í¬ë¦° ìœ ì§€).</div>
    </div>
  </div>

<script>
  const send = (obj)=> opener && opener.postMessage(obj, "*");
  const $ = (id)=> document.getElementById(id);
  const pillTop = $("pillTop");

  // tabs
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
      document.querySelectorAll(".panel").forEach(x=>x.classList.remove("active"));
      t.classList.add("active");
      $("pan-"+t.dataset.tab).classList.add("active");
    });
  });

  // top commands
  $("cmdAudio").addEventListener("click", ()=> send({type:"CMD", action:"AUDIO_UNLOCK"}));
  $("cmdFS").addEventListener("click", ()=> send({type:"CMD", action:"FULLSCREEN"}));
  $("cmdMute").addEventListener("click", ()=> send({type:"CMD", action:"MUTE"}));
  $("cmdReset").addEventListener("click", ()=> send({type:"CMD", action:"RESET"}));

  // helper: bind SET
  function bindSelect(id){
    const el = $(id);
    el.addEventListener("change", ()=> send({type:"SET", id, value: el.value}));
  }
  function bindRange(id, labelId, fmt){
    const el = $(id);
    const lb = $(labelId);
    const update = ()=>{
      const v = parseFloat(el.value);
      if(lb) lb.textContent = fmt(v);
      send({type:"SET", id, value: v});
    };
    el.addEventListener("input", update);
    el.addEventListener("change", update);
  }
  function bindNumber(id){
    const el = $(id);
    el.addEventListener("input", ()=> send({type:"SET", id, value: parseInt(el.value,10)}));
  }

  // VISUAL binds
  ["selMode","selN","selBounds","selQuietLines","selPointColor","selAutoReboot","selPreset"].forEach(bindSelect);

  bindRange("rngSpeed","txtSpeed",(v)=>`speed: ${v.toFixed(2)}Ã—`);
  bindRange("rngIdleDrama","txtIdleDrama",(v)=>`idle drama: ${v.toFixed(2)}`);
  bindRange("rngVisSens","txtVisSens",(v)=>`visual sens: ${v.toFixed(2)}Ã—`);
  bindRange("rngLine","txtLine",(v)=>`line density: ${v.toFixed(2)}Ã—`);
  bindRange("rngPerf","txtPerf",(v)=>`perf limit: ${v.toFixed(2)}`);
  bindRange("rngFade","txtFade",(v)=>`fade: ${v.toFixed(3)}`);
  bindRange("rngPointSize","txtPointSize",(v)=>`point size: ${v.toFixed(2)}Ã—`);
  bindRange("rngGlow","txtGlow",(v)=>`glow: ${v.toFixed(2)}Ã—`);

  // AUDIO binds
  bindRange("rngMediaGain","txtMediaGain",(v)=>`media gain: ${v.toFixed(2)}Ã—`);
  bindRange("rngSens","txtSens",(v)=>`analysis sens: ${v.toFixed(1)}Ã—`);
  bindRange("rngGamma","txtGamma",(v)=>`gamma: ${v.toFixed(2)}`);
  bindRange("rngCap","txtCap",(v)=>`amp cap: ${v.toFixed(2)}`);
  bindRange("rngEQLow","txtEQLow",(v)=>`low: ${v.toFixed(1)} dB (200Hz)`);
  bindRange("rngEQMid","txtEQMid",(v)=>`mid: ${v.toFixed(1)} dB (1kHz)`);
  bindRange("rngEQHigh","txtEQHigh",(v)=>`high: ${v.toFixed(1)} dB (4kHz)`);

  // MIDI binds
  $("btnMIDIInit").addEventListener("click", ()=> send({type:"CMD", action:"MIDI_INIT"}));
  $("btnMIDILearn").addEventListener("click", ()=> send({type:"CMD", action:"MIDI_LEARN"}));
  $("selMIDIIn").addEventListener("change", ()=> send({type:"CMD", action:"MIDI_ATTACH", id: $("selMIDIIn").value}));

  bindSelect("selMIDIType");
  bindNumber("numMIDINum");
  bindSelect("selMIDICh");
  bindSelect("selMIDIInvert");

  bindRange("rngMIDIDead","txtMIDIDead",(v)=>`deadzone: ${v.toFixed(3)}`);
  bindRange("rngMIDIGain","txtMIDIGain",(v)=>`gain: ${v.toFixed(2)}Ã—`);
  bindRange("rngMIDICurve","txtMIDICurve",(v)=>`curve: ${v.toFixed(2)} ( <1 = ë” ì˜ˆë¯¼ )`);
  bindRange("rngMIDISmooth","txtMIDISmooth",(v)=>`smooth: ${v.toFixed(2)}`);
  bindRange("rngSimTouch","rngSimTouchHelp",(v)=>""); // label ì—†ìŒ

  // SYSTEM
  $("selSrc").addEventListener("change", ()=> send({type:"CMD", action:"SET_SOURCE", value:$("selSrc").value}));
  $("selMic").addEventListener("change", ()=> send({type:"CMD", action:"SET_MIC_DEVICE", deviceId:$("selMic").value}));
  $("selSpk").addEventListener("change", ()=> send({type:"CMD", action:"SET_SPK_DEVICE", deviceId:$("selSpk").value}));
  $("btnMicOn").addEventListener("click", ()=> send({type:"CMD", action:"MIC_ON", deviceId:$("selMic").value, enter:0}));
  $("btnMicOff").addEventListener("click", ()=> send({type:"CMD", action:"MIC_OFF"}));
  $("btnFileHelp").addEventListener("click", ()=> send({type:"CMD", action:"FILE_LOAD_REQUEST"}));
  $("btnFilePlay").addEventListener("click", ()=> send({type:"CMD", action:"FILE_PLAY", enter:0}));
  $("btnFilePause").addEventListener("click", ()=> send({type:"CMD", action:"FILE_PAUSE"}));
  $("btnFileStop").addEventListener("click", ()=> send({type:"CMD", action:"FILE_STOP"}));

  // meters
  const meterIn = $("meterIn");
  const meterTouch = $("meterTouch");

  // receive from main
  window.addEventListener("message", (ev)=>{
    const m = ev.data || {};
    if(!m || typeof m !== "object") return;

    if(m.type==="STATE"){
      const st = m.state || {};
      const s = st.settings || {};
      // set control values (only if element exists)
      const setV = (id, v)=> { const el=$(id); if(el && v!==undefined && v!==null) el.value = String(v); };
      const setR = (id, v)=> { const el=$(id); if(el && v!==undefined && v!==null) el.value = String(v); };

      // visual
      setV("selMode", s.selMode ?? "pulse");
      setV("selN", s.selN ?? "220");
      setV("selBounds", s.selBounds ?? "soft");
      setV("selQuietLines", s.selQuietLines ?? "1");
      setV("selPointColor", s.selPointColor ?? "red");
      setR("rngSpeed", s.rngSpeed ?? 0.62);
      setR("rngIdleDrama", s.rngIdleDrama ?? 0.55);
      setR("rngVisSens", s.rngVisSens ?? 1.55);
      setR("rngLine", s.rngLine ?? 0.75);
      setR("rngPerf", s.rngPerf ?? 0.72);
      setR("rngFade", s.rngFade ?? 0.03);
      setR("rngPointSize", s.rngPointSize ?? 0.60);
      setR("rngGlow", s.rngGlow ?? 0.45);

      // audio
      setV("selPreset", s.selPreset ?? "touch_glitch");
      setR("rngMediaGain", s.rngMediaGain ?? 1.00);
      setR("rngSens", s.rngSens ?? 7.0);
      setR("rngGamma", s.rngGamma ?? 0.72);
      setR("rngCap", s.rngCap ?? 0.42);
      setR("rngEQLow", s.rngEQLow ?? 0);
      setR("rngEQMid", s.rngEQMid ?? 0);
      setR("rngEQHigh", s.rngEQHigh ?? 0);

      // midi
      setV("selMIDIType", s.selMIDIType ?? "cc");
      setV("selMIDICh", s.selMIDICh ?? "-1");
      setV("selMIDIInvert", s.selMIDIInvert ?? "0");
      setV("numMIDINum", s.numMIDINum ?? 1);
      setR("rngMIDIDead", s.rngMIDIDead ?? 0.02);
      setR("rngMIDIGain", s.rngMIDIGain ?? 1.60);
      setR("rngMIDICurve", s.rngMIDICurve ?? 0.85);
      setR("rngMIDISmooth", s.rngMIDISmooth ?? 0.22);
      setR("rngSimTouch", s.rngSimTouch ?? 0);

      // system
      setV("selSrc", st.currentSource ?? "mic");
      setV("selAutoReboot", s.selAutoReboot ?? "1");
      $("txtSupport").textContent = st.supportText || "";

      // refresh labels
      $("txtSpeed").textContent = "speed: " + parseFloat($("rngSpeed").value).toFixed(2) + "Ã—";
      $("txtIdleDrama").textContent = "idle drama: " + parseFloat($("rngIdleDrama").value).toFixed(2);
      $("txtVisSens").textContent = "visual sens: " + parseFloat($("rngVisSens").value).toFixed(2) + "Ã—";
      $("txtLine").textContent = "line density: " + parseFloat($("rngLine").value).toFixed(2) + "Ã—";
      $("txtPerf").textContent = "perf limit: " + parseFloat($("rngPerf").value).toFixed(2);
      $("txtFade").textContent = "fade: " + parseFloat($("rngFade").value).toFixed(3);
      $("txtPointSize").textContent = "point size: " + parseFloat($("rngPointSize").value).toFixed(2) + "Ã—";
      $("txtGlow").textContent = "glow: " + parseFloat($("rngGlow").value).toFixed(2) + "Ã—";
      $("txtMediaGain").textContent = "media gain: " + parseFloat($("rngMediaGain").value).toFixed(2) + "Ã—";
      $("txtSens").textContent = "analysis sens: " + parseFloat($("rngSens").value).toFixed(1) + "Ã—";
      $("txtGamma").textContent = "gamma: " + parseFloat($("rngGamma").value).toFixed(2);
      $("txtCap").textContent = "amp cap: " + parseFloat($("rngCap").value).toFixed(2);
      $("txtEQLow").textContent = "low: " + parseFloat($("rngEQLow").value).toFixed(1) + " dB (200Hz)";
      $("txtEQMid").textContent = "mid: " + parseFloat($("rngEQMid").value).toFixed(1) + " dB (1kHz)";
      $("txtEQHigh").textContent = "high: " + parseFloat($("rngEQHigh").value).toFixed(1) + " dB (4kHz)";
      $("txtMIDIDead").textContent = "deadzone: " + parseFloat($("rngMIDIDead").value).toFixed(3);
      $("txtMIDIGain").textContent = "gain: " + parseFloat($("rngMIDIGain").value).toFixed(2) + "Ã—";
      $("txtMIDICurve").textContent = "curve: " + parseFloat($("rngMIDICurve").value).toFixed(2) + " ( <1 = ë” ì˜ˆë¯¼ )";
      $("txtMIDISmooth").textContent = "smooth: " + parseFloat($("rngMIDISmooth").value).toFixed(2);

      pillTop.textContent = "audio:" + (st.audioState||"off") + " | src:" + (st.currentSource||"-");
    }

    if(m.type==="DEVICES"){
      // mic list
      const mics = m.mics || [];
      const selMic = $("selMic");
      selMic.innerHTML = "";
      if(mics.length===0){
        selMic.innerHTML = "<option value='default'>No mic</option>";
      }else{
        for(const d of mics){
          const opt = document.createElement("option");
          opt.value = d.deviceId;
          opt.textContent = d.label || ("Mic " + (d.deviceId||"").slice(0,6) + "â€¦");
          if(d.deviceId===m.currentMicDeviceId) opt.selected = true;
          selMic.appendChild(opt);
        }
      }

      // spk list
      const selSpk = $("selSpk");
      selSpk.innerHTML = "";
      if(!m.outputSupported){
        selSpk.innerHTML = "<option value=''>outputSelect=NO</option>";
        selSpk.disabled = true;
      }else{
        selSpk.disabled = false;
        const spks = m.spks || [];
        if(spks.length===0){
          selSpk.innerHTML = "<option value='default'>default</option>";
        }else{
          for(const d of spks){
            const opt = document.createElement("option");
            opt.value = d.deviceId;
            opt.textContent = d.label || ("Spk " + (d.deviceId||"").slice(0,6) + "â€¦");
            if(m.currentSpkDeviceId && d.deviceId===m.currentSpkDeviceId) opt.selected = true;
            selSpk.appendChild(opt);
          }
        }
      }
    }

    if(m.type==="TELEM"){
      const inPct = Math.max(0, Math.min(1, (m.amp||0)*6.0));
      $("meterIn").style.width = (inPct*100).toFixed(1)+"%";

      const tv = Math.max(0, Math.min(1, m.touch||0));
      $("meterTouch").style.width = (tv*100).toFixed(1)+"%";

      $("txtAmp").textContent = "amp: " + (m.amp||0).toFixed(4) + " | dAmp: " + (m.ampDelta||0).toFixed(4) +
        " | frame:" + (m.frameMs||0).toFixed(1) + "ms | q:" + (m.q||1).toFixed(2);

      $("txtFx").textContent = m.fxText || "preset:-";

      pillTop.textContent = "audio:" + (m.audioState||"off") + " | src:" + (m.src||"-") + " | q:" + (m.q||1).toFixed(2);
    }

    if(m.type==="MIDI_SUPPORT"){
      $("txtMIDISupport").textContent = m.msg || "";
    }
    if(m.type==="MIDI_INPUTS"){
      const sel = $("selMIDIIn");
      sel.innerHTML = "";
      const inputs = m.inputs || [];
      if(inputs.length===0){
        sel.innerHTML = "<option value=''>No MIDI inputs</option>";
      }else{
        for(const it of inputs){
          const opt = document.createElement("option");
          opt.value = it.id;
          opt.textContent = it.name;
          if(m.selected && it.id===m.selected) opt.selected = true;
          sel.appendChild(opt);
        }
      }
    }
    if(m.type==="MIDI_LEARN"){
      const b = $("btnMIDILearn");
      b.classList.toggle("on", !!m.on);
      b.textContent = m.on ? "LEARN (ON)" : "LEARN";
    }
    if(m.type==="MIDI_LOG"){
      $("txtMIDI").textContent = (m.midiName||"MIDI") + "\\n" + (m.lines||[]).join("\\n");
    }
  });

  // request initial
  send({type:"REQUEST_STATE"});
<\/script>
</body>
</html>`;
}

/* ==========================================================
   MINI PILL (main page)
========================================================== */
function updateMiniPill(q=1){
  const pill = document.getElementById('pillMini');
  const a = audioCtx ? audioCtx.state : 'off';
  const src = (currentSource==="mic")
    ? (micStream ? "mic:on" : "mic:off")
    : (fileAudioEl && fileAudioEl.src ? (fileAudioEl.paused ? "file:loaded" : "file:play") : "file:empty");
  pill.textContent = `audio:${a} | src:${src} | q:${q.toFixed(2)}`;
}

/* ==========================================================
   DEVICE SELECT (Entry mirror)
========================================================== */
const entrySelMic = document.getElementById('entrySelMic');
entrySelMic.addEventListener('change', async (e)=>{
  currentMicDeviceId = e.target.value;
  sset('currentMicDeviceId', currentMicDeviceId);
  if(currentSource==="mic" && micStream) await startMic(currentMicDeviceId, false);
  publishToPopup({ type:"STATE", state: snapshotState() });
});

/* Enable mic buttons only after audio unlocked */
function updateEntryMicButtons(){
  const can = !!audioCtx && (currentSource==="mic");
  document.getElementById('entryMicOn').disabled  = !can || !!micStream;
  document.getElementById('entryMicOff').disabled = !can || !micStream;
}
setInterval(updateEntryMicButtons, 200);

/* ==========================================================
   STARTUP
========================================================== */
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function clampInt(x,a,b){ x = isFinite(x)?x:a; return Math.max(a, Math.min(b, x|0)); }

applySourceUI();
updateMiniPill(1);
startStatus("Start Audio â†’ Mic/File ì„ íƒ â†’ Enter");

window.addEventListener('pagehide', ()=>{
  try{ stopMic(); }catch(e){}
  try{ if(fileAudioEl) fileAudioEl.pause(); }catch(e){}
});
</script>
</body>
</html>
