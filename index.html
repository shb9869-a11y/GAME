<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>TouchMe + Mic Visualizer (Wave + Reactive Particles)</title>
<style>
  :root{color-scheme:dark}
  html,body{height:100%;margin:0}
  body{
    background:#0b0b0b;color:#eee;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    touch-action:manipulation;
    -webkit-tap-highlight-color:transparent;
  }
  #hint{
    position:fixed; inset:0; z-index:2147483647;
    display:flex; align-items:center; justify-content:center;
    pointer-events:none;
    background:radial-gradient(circle, rgba(255,255,255,0.06), transparent 55%);
  }
  #hint .box{
    max-width:760px;
    padding:18px 16px;
    border:1px solid #333;border-radius:16px;
    background:rgba(15,15,15,.86);
    text-align:center;
    pointer-events:none;
  }
  #wrap{max-width:1200px;margin:0 auto;padding:18px}
  .card{background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px}
  .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
  .row>*{flex:1; min-width:220px}
  button,input{
    width:100%;
    padding:12px; border-radius:12px;
    border:1px solid #333; background:#0f0f0f; color:#eee;
  }
  button{cursor:pointer}
  button:disabled{opacity:.55; cursor:not-allowed}
  label{display:block;margin-top:10px;font-size:13px;opacity:.9}
  .meter{height:10px;border-radius:999px;background:#1a1a1a;border:1px solid #2a2a2a;overflow:hidden}
  .meter>div{height:100%;width:0%;background:#eaeaea;opacity:.9}
  .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:12px}
  @media(min-width:980px){ .grid{grid-template-columns:1fr 1fr} }
  .viz{background:#0f0f0f;border:1px solid #2a2a2a;border-radius:14px;padding:10px}
  canvas{width:100%;height:220px;display:block;border-radius:10px;background:#0a0a0a}
  #log{
    margin-top:12px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
    font-size:12px;
    background:#0f0f0f;border:1px solid #2a2a2a;border-radius:12px;
    padding:12px;white-space:pre-wrap;
  }
  .hint{font-size:12px;opacity:.75;line-height:1.5}
</style>
</head>
<body>

<div id="hint">
  <div class="box">
    <h2 style="margin:0 0 8px">TouchMe + Mic Visualizer</h2>
    <div style="opacity:.92;line-height:1.55">
      <b>í™”ë©´ ì•„ë¬´ ê³³ 1íšŒ í´ë¦­/í„°ì¹˜</b> â†’ ì˜¤ë””ì˜¤/MIDI ì¤€ë¹„<br/>
      ê·¸ ë‹¤ìŒ <b>Mic On</b> â†’ ì›ìŒ(dry) ë“¤ë¦¼ + íŒŒí˜• í‘œì‹œ<br/>
      <b>TouchMe</b> ëˆ„ë¥´ëŠ” ë™ì•ˆ â†’ FX(wet) + ë¹„ì£¼ì–¼ íŒŒí¸/ì§„ë™ ì¦ê°€
    </div>
    <div class="hint" style="margin-top:8px">
      â€» í•˜ìš¸ë§ ë°©ì§€ë¡œ ì´ì–´í°/í—¤ë“œí° ì¶”ì²œ. (HTTPS/localhostê°€ ì œì¼ ì•ˆì •ì )
    </div>
  </div>
</div>

<div id="wrap">
  <div class="card">
    <div class="row">
      <button id="micBtn" disabled>Mic On</button>
      <button id="micOffBtn" disabled>Mic Off</button>
      <button id="beepBtn" disabled>Test Beep</button>
      <button id="panicBtn" disabled>Panic (Mute)</button>
    </div>

    <div class="row">
      <div>
        <label>Mic level</label>
        <div class="meter"><div id="micBar"></div></div>
      </div>
      <div>
        <label>TouchMe velocity</label>
        <div class="meter"><div id="midiBar"></div></div>
      </div>
    </div>

    <div class="row">
      <div><label>DRY (ì›ìŒ)</label><input id="dry" type="range" min="0" max="100" value="82" disabled></div>
      <div><label>WET MAX (TouchMe ëˆ„ë¥¼ ë•Œ FX)</label><input id="wetmax" type="range" min="0" max="100" value="88" disabled></div>
      <div><label>Smear (Delay/Blur)</label><input id="smear" type="range" min="0" max="100" value="62" disabled></div>
      <div><label>Muffle (LPF)</label><input id="muffle" type="range" min="0" max="100" value="70" disabled></div>
    </div>

    <div class="grid">
      <div class="viz">
        <label>MIC WAVE (ìˆ˜ìŒ íŒŒí˜•)</label>
        <canvas id="waveMic"></canvas>
      </div>
      <div class="viz">
        <label>REACTIVE FIELD (TouchMe + Mic ë°˜ì‘)</label>
        <canvas id="field"></canvas>
      </div>
    </div>

    <div id="log">waitingâ€¦</div>
  </div>
</div>

<script>
(() => {
  const $=id=>document.getElementById(id);
  const logEl=$("log");
  const log=(m)=>{ logEl.textContent = m + "\n" + logEl.textContent; };

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const norm=(x)=>clamp(x/100,0,1);

  // ===== Audio state
  let ctx=null;
  let micStream=null, micSrc=null;

  let dryGain=null, wetGain=null, master=null;
  let lp=null, delay=null, fb=null, shaper=null;

  // analysers
  let anMic=null;     // mic waveform
  let anOut=null;     // optional output meter

  // MIDI state (TouchMe)
  let midiVel=0;     // 0..1
  let pressed=0;
  let wetGate=0;

  // ===== Canvas
  const cvMic=$("waveMic");
  const cvField=$("field");
  const gMic=cvMic.getContext("2d");
  const gField=cvField.getContext("2d");

  let dpr=1;
  function resizeCanvas(){
    dpr=Math.max(1,window.devicePixelRatio||1);
    [cvMic,cvField].forEach(cv=>{
      const r=cv.getBoundingClientRect();
      cv.width=Math.floor(r.width*dpr);
      cv.height=Math.floor(r.height*dpr);
    });
  }

  // ===== UI enable
  function enableUI(on){
    ["micBtn","micOffBtn","beepBtn","panicBtn","dry","wetmax","smear","muffle"]
      .forEach(id=>$(id).disabled=!on);
  }

  // ===== DSP helpers
  function makeCurve(amount){
    const n=4096;
    const curve=new Float32Array(n);
    const k=amount*40;
    for(let i=0;i<n;i++){
      const x=(i/(n-1))*2-1;
      curve[i]=(1+k)*x/(1+k*Math.abs(x));
    }
    return curve;
  }

  function buildAudioGraph(){
    master = ctx.createGain();
    master.gain.value = 0.95;
    master.connect(ctx.destination);

    dryGain = ctx.createGain();
    wetGain = ctx.createGain();
    dryGain.gain.value = norm($("dry").value);
    wetGain.gain.value = 0.0;

    dryGain.connect(master);
    wetGain.connect(master);

    // FX chain: mic -> shaper -> lp -> delay -> wetGain
    shaper = ctx.createWaveShaper();
    shaper.curve = makeCurve(0.8);
    shaper.oversample = "4x";

    lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 2000;
    lp.Q.value = 0.7;

    delay = ctx.createDelay(1.0);
    delay.delayTime.value = 0.18;

    fb = ctx.createGain();
    fb.gain.value = 0.35;

    delay.connect(fb);
    fb.connect(delay);

    anMic = ctx.createAnalyser();
    anMic.fftSize = 2048;
    anMic.smoothingTimeConstant = 0.85;

    anOut = ctx.createAnalyser();
    anOut.fftSize = 2048;
    anOut.smoothingTimeConstant = 0.85;

    master.connect(anOut);
  }

  function updateParams(){
    if(!ctx) return;

    dryGain.gain.value = norm($("dry").value);

    const smear = norm($("smear").value);
    const muffle= norm($("muffle").value);

    lp.frequency.value    = lerp(14000, 700, muffle);
    delay.delayTime.value = lerp(0.04, 0.28, smear);
    fb.gain.value         = clamp(lerp(0.05, 0.88, smear), 0, 0.92);
  }

  function updateWetGate(){
    const wetMax = norm($("wetmax").value);
    const on = pressed>0 ? 1 : 0;
    const target = on ? clamp(wetMax*(0.20 + 0.95*midiVel), 0, 1) : 0;

    wetGate = lerp(wetGate, target, on ? 0.18 : 0.10);
    wetGain.gain.value = wetGate;

    if(!on) midiVel *= 0.985;
    $("midiBar").style.width = `${Math.round(midiVel*100)}%`;
  }

  // ===== Mic
  async function micOn(){
    micStream = await navigator.mediaDevices.getUserMedia({
      audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    const t = micStream.getAudioTracks()[0];
    log("Mic track: " + (t?.readyState||"n/a") + " / " + (t?.label||"no label"));

    micSrc = ctx.createMediaStreamSource(micStream);

    // analyser tap
    micSrc.connect(anMic);

    // DRY always
    micSrc.connect(dryGain);

    // WET
    micSrc.connect(shaper);
    shaper.connect(lp);
    lp.connect(delay);
    delay.connect(wetGain);

    log("Mic ON âœ… (ì›ìŒ + ë¹„ì£¼ì–¼)");
  }

  function micOff(){
    if(micSrc){ try{ micSrc.disconnect(); }catch(e){} micSrc=null; }
    if(micStream){ try{ micStream.getTracks().forEach(tr=>tr.stop()); }catch(e){} micStream=null; }
    log("Mic OFF");
  }

  // ===== Beep / Panic
  function testBeep(){
    const osc=ctx.createOscillator();
    const g=ctx.createGain();
    osc.type="sine";
    osc.frequency.value=880;
    g.gain.value=0;
    g.connect(master);

    const t=ctx.currentTime;
    g.gain.setValueAtTime(0.0, t);
    g.gain.linearRampToValueAtTime(0.18, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.25);

    osc.connect(g);
    osc.start(t);
    osc.stop(t+0.26);

    log("BEEP ğŸ”ˆ (ì•ˆ ë“¤ë¦¬ë©´: íƒ­ ìŒì†Œê±°/ì‚¬ì´íŠ¸ ì†Œë¦¬ ì°¨ë‹¨/OS ì¶œë ¥ ì¥ì¹˜ í™•ì¸)");
  }

  function panic(){
    const prev=master.gain.value;
    master.gain.value=0;
    setTimeout(()=>master.gain.value=prev, 250);
    log("PANIC");
  }

  // ===== MIDI (TouchMe)
  async function initMIDI(){
    if(!navigator.requestMIDIAccess){
      log("MIDI âŒ (WebMIDI ë¯¸ì§€ì›)");
      return;
    }
    const access = await navigator.requestMIDIAccess({sysex:false});
    const inputs = Array.from(access.inputs.values());
    if(inputs.length===0){
      log("MIDI ì…ë ¥ ì—†ìŒ (TouchMe ì—°ê²° í™•ì¸)");
      return;
    }

    // ì²« ì…ë ¥ì— ì—°ê²° (í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ name í•„í„°ë§ ê°€ëŠ¥)
    const inp = inputs[0];
    inp.onmidimessage = (msg)=>{
      const [st,,vel]=msg.data;
      const cmd = st & 0xF0;

      if(cmd===0x90 && vel>0){
        pressed++;
        midiVel = clamp(vel/127,0,1);
      } else if(cmd===0x80 || (cmd===0x90 && vel===0)){
        pressed = Math.max(0, pressed-1);
      }
    };

    log("MIDI âœ… connected: " + (inp.name || "input"));
  }

  // ===== Visuals
  function drawMicWave(){
    const W=cvMic.width, H=cvMic.height;
    gMic.clearRect(0,0,W,H);

    // grid faint
    gMic.globalAlpha=0.25;
    gMic.strokeStyle="#ffffff";
    gMic.lineWidth=1*dpr;
    gMic.beginPath();
    gMic.moveTo(0,H/2); gMic.lineTo(W,H/2);
    gMic.stroke();
    gMic.globalAlpha=1;

    if(!anMic) return {rms:0};

    const data=new Uint8Array(anMic.fftSize);
    anMic.getByteTimeDomainData(data);

    // waveform
    gMic.strokeStyle="#eaeaea";
    gMic.lineWidth=2*dpr;
    gMic.beginPath();
    const mid=H/2;

    let rms=0;
    for(let i=0;i<data.length;i++){
      const x = (i/(data.length-1))*W;
      const v = (data[i]-128)/128;
      const y = mid + v*(H*0.42);
      if(i===0) gMic.moveTo(x,y); else gMic.lineTo(x,y);
      rms += v*v;
    }
    gMic.stroke();

    rms = Math.sqrt(rms/data.length);
    return {rms};
  }

  // particle field reacting to mic rms + midiVel
  const P = [];
  const N = 220;

  function initParticles(){
    P.length=0;
    const W=cvField.width, H=cvField.height;
    for(let i=0;i<N;i++){
      P.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vx:(Math.random()*2-1)*0.6*dpr,
        vy:(Math.random()*2-1)*0.6*dpr,
        a: Math.random()*1.0
      });
    }
  }

  function drawField(micRms){
    const W=cvField.width, H=cvField.height;

    // trail
    gField.fillStyle="rgba(10,10,10,0.20)";
    gField.fillRect(0,0,W,H);

    // center pulse by midi + mic
    const energy = clamp(micRms*3.0,0,1);
    const touch  = clamp(midiVel,0,1);
    const press  = pressed>0 ? 1 : 0;
    const k = clamp(0.15 + 0.85*(0.55*energy + 0.45*touch), 0, 1);

    // subtle â€œgravityâ€ to center when pressed (gathering / crumbling voice)
    const cx=W/2, cy=H/2;
    const gather = press ? (0.6 + 1.8*touch) : 0.2;

    // draw
    gField.globalAlpha = 0.9;
    gField.strokeStyle = "#eaeaea";
    gField.lineWidth = 1*dpr;

    // update particles
    for(const p of P){
      // turbulence from mic energy
      const n1 = (Math.random()*2-1) * (0.8 + 6.0*energy) * dpr;
      const n2 = (Math.random()*2-1) * (0.8 + 6.0*energy) * dpr;

      // pull to center when touch pressed (fragment voice ëŠë‚Œ)
      const dx=cx-p.x, dy=cy-p.y;
      p.vx += (dx/W) * gather * (0.6 + 1.4*k);
      p.vy += (dy/H) * gather * (0.6 + 1.4*k);

      // shatter kick when touch on
      if(press){
        p.vx += n1*(0.30 + 0.90*touch);
        p.vy += n2*(0.30 + 0.90*touch);
      }else{
        p.vx += n1*(0.10 + 0.35*k);
        p.vy += n2*(0.10 + 0.35*k);
      }

      // damping
      const damp = press ? (0.86 - 0.10*touch) : 0.90;
      p.vx *= damp;
      p.vy *= damp;

      p.x += p.vx;
      p.y += p.vy;

      // wrap
      if(p.x<0) p.x+=W; else if(p.x>W) p.x-=W;
      if(p.y<0) p.y+=H; else if(p.y>H) p.y-=H;

      // draw points
      const r = (0.8 + 2.6*(0.6*energy + 0.4*touch))*dpr;
      gField.globalAlpha = 0.18 + 0.72*(0.35*energy + 0.65*touch);
      gField.beginPath();
      gField.arc(p.x,p.y,r,0,Math.PI*2);
      gField.stroke();
    }

    // center ring
    gField.globalAlpha = 0.25 + 0.55*k;
    gField.lineWidth = (1 + 2.0*k)*dpr;
    const R = (18 + 140*k)*dpr;
    gField.beginPath();
    gField.arc(cx,cy,R,0,Math.PI*2);
    gField.stroke();
    gField.globalAlpha = 1;
  }

  // ===== Main loops
  function loop(){
    if(ctx){
      // keep updating
      updateWetGate();
      const {rms} = drawMicWave();
      $("micBar").style.width = `${Math.round(clamp(rms*3.0,0,1)*100)}%`;
      drawField(rms);
    }
    requestAnimationFrame(loop);
  }

  // ===== Start: â€œí™”ë©´ ì•„ë¬´ ê³³ 1íšŒ í´ë¦­â€ë¡œ ê°•ì œ ì˜¤í”ˆ
  async function startAll(ev){
    if(ctx) return;
    ev.preventDefault?.();
    ev.stopPropagation?.();

    // remove hint
    const hint=$("hint"); if(hint) hint.remove();

    ctx = new (window.AudioContext||window.webkitAudioContext)();
    await ctx.resume();

    buildAudioGraph();
    enableUI(true);
    updateParams();

    resizeCanvas();
    initParticles();
    window.addEventListener("resize", ()=>{ resizeCanvas(); initParticles(); });

    // MIDI init (touchme)
    initMIDI();

    log("STARTED âœ…  state=" + ctx.state + "  sr=" + ctx.sampleRate);
    requestAnimationFrame(loop);
  }

  ["pointerdown","touchstart","mousedown"].forEach(t=>{
    window.addEventListener(t, startAll, {capture:true, passive:false});
  });

  // ===== UI events
  enableUI(false);

  $("micBtn").addEventListener("click", async ()=>{
    try{
      await micOn();
      $("micBtn").disabled=true;
      $("micOffBtn").disabled=false;
    }catch(e){
      log("Mic error: " + e.message);
    }
  });

  $("micOffBtn").addEventListener("click", ()=>{
    micOff();
    $("micBtn").disabled=false;
    $("micOffBtn").disabled=true;
  });

  $("beepBtn").addEventListener("click", ()=>{ if(ctx) testBeep(); });
  $("panicBtn").addEventListener("click", ()=>{ if(ctx) panic(); });

  ["dry","wetmax","smear","muffle"].forEach(id=>{
    $(id).addEventListener("input", updateParams);
  });

})();
</script>
</body>
</html>
