<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Grave Run — D-Pad 컨트롤</title>
<meta name="theme-color" content="#140c1c" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Grave Run" />
<style>
  :root{
    --bg:#0a0812; --fg:#eae6ff; --accent:#ff7a33;
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bot: env(safe-area-inset-bottom, 0px);
    --safe-left: env(safe-area-inset-left, 0px);
    --safe-right: env(safe-area-inset-right, 0px);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
  body{display:grid;place-items:center;font-family:ui-monospace,"SF Mono",Menlo,Consolas,monospace;}
  #wrap{position:relative;width:100vw;height:100svh;overflow:hidden;background:var(--bg);
        padding:var(--safe-top) var(--safe-right) var(--safe-bot) var(--safe-left);}
  canvas{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
         image-rendering:pixelated;image-rendering:crisp-edges;touch-action:none;}

  .badge{position:absolute;right:calc(10px + var(--safe-right));top:calc(8px + var(--safe-top));
         font-size:12px;opacity:.8;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.15);
         padding:4px 8px;border-radius:8px;}
  .btnE{position:absolute;right:calc(16px + var(--safe-right));bottom:calc(16px + var(--safe-bot));
         width:120px;height:52px;border-radius:12px;border:1px solid rgba(255,255,255,.25);
         background:rgba(0,0,0,.38);color:#fff;display:none;place-items:center;font:600 13px ui-monospace,monospace;}
  .dialog{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);}
  .dialog .box{min-width:260px;max-width:86vw;background:#1b142a;color:#eee;border:1px solid rgba(255,255,255,.2);border-radius:10px;padding:12px;box-shadow:0 10px 24px rgba(0,0,0,.6);font:12px/1.6 ui-monospace,monospace;}
  .dialog .box h3{margin:0 0 8px;font:700 12px ui-monospace,monospace;color:#ffd4a6;}
  .choices{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
  .choices button{padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.25);background:#33265a;color:#fff;font:600 12px ui-monospace,monospace;}

  /* ===== D-Pad ===== */
  .dpad{
    position:absolute;left:calc(16px + var(--safe-left));bottom:calc(16px + var(--safe-bot));
    width:196px;height:196px;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);
    gap:10px;opacity:.96;filter:drop-shadow(0 2px 8px rgba(0,0,0,.6));
    touch-action:none;
  }
  .dpad .cell{display:grid;place-items:center;}
  .dpad button{
    width:100%;height:100%;min-width:0;min-height:0;border-radius:14px;
    border:1px solid rgba(255,255,255,.25);background:rgba(255,255,255,.08);color:#fff;
    font:700 14px ui-monospace,monospace;letter-spacing:.2px;
    user-select:none; -webkit-user-select:none;
  }
  .dpad button:active{background:rgba(255,255,255,.2);}
  .dpad .empty{pointer-events:none;opacity:0;}
  @media (pointer:fine){
    /* 데스크톱에선 기본적으로 숨김(키보드로) */
    .dpad{display:none;}
  }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="256" height="256"></canvas>

    <!-- D-Pad: 상/하/좌/우 -->
    <div class="dpad" id="dpad" aria-hidden="false">
      <div class="cell"></div>
      <div class="cell"><button data-dir="up">▲</button></div>
      <div class="cell"></div>

      <div class="cell"><button data-dir="left">◀</button></div>
      <div class="cell" class="empty"></div>
      <div class="cell"><button data-dir="right">▶</button></div>

      <div class="cell"></div>
      <div class="cell"><button data-dir="down">▼</button></div>
      <div class="cell"></div>
    </div>

    <div class="badge" id="badge">ROOM: 비석의 방 · 하단 출구 → 전화기의 방</div>
    <button id="btnE" class="btnE">E: 상호작용</button>

    <div id="dialog" class="dialog" role="dialog" aria-modal="true">
      <div class="box">
        <h3 id="dgTitle">기록</h3>
        <div id="dgBody">...</div>
        <div id="dgChoices" class="choices"></div>
      </div>
    </div>
  </div>
<script>
(()=>{
  /* ---------- SFX ---------- */
  let AC, masterGain, unlocked=false;
  function initAudio(){ if(unlocked) return; AC=new (window.AudioContext||window.webkitAudioContext)(); masterGain=AC.createGain(); masterGain.gain.value=0.22; masterGain.connect(AC.destination); unlocked=true; }
  async function unlockAudio(){ initAudio(); try{ if(AC.state==='suspended') await AC.resume(); }catch(e){} }
  ['pointerdown','touchstart','keydown'].forEach(ev=> addEventListener(ev, unlockAudio, {passive:true}));
  function beep({freq=440,type='square',dur=0.1,attack=0.002,release=0.06,vol=0.3,slide=0}={}){
    if(!unlocked) return; const t=AC.currentTime, o=AC.createOscillator(), g=AC.createGain();
    o.type=type; o.frequency.setValueAtTime(freq,t); if(slide) o.frequency.exponentialRampToValueAtTime(Math.max(40,freq*slide), t+dur*0.9);
    g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vol,t+attack); g.gain.linearRampToValueAtTime(0.0001,t+dur+release);
    o.connect(g); g.connect(masterGain); o.start(t); o.stop(t+dur+release+0.01);
  }
  const SFX={
    step(i=0){beep({freq:i%2?520:460,dur:0.06,vol:0.2});},
    interact(){beep({freq:900,dur:0.08,vol:0.26});beep({freq:1300,dur:0.08,vol:0.22,slide:0.8});},
    select(){beep({freq:660,dur:0.07,vol:0.22});},
    ring(){beep({freq:660,type:'square',dur:0.12,vol:0.28}); setTimeout(()=>beep({freq:660,type:'square',dur:0.12,vol:0.28}),140);}
  };

  /* ---------- Canvas / scale ---------- */
  const wrap=document.getElementById('wrap'), game=document.getElementById('game'), badge=document.getElementById('badge');
  const g=game.getContext('2d',{alpha:false}); g.imageSmoothingEnabled=false;
  const TILE=16, MAP_W=16, MAP_H=16;
  function fit(){ const {clientWidth:cw,clientHeight:ch}=wrap; const s=Math.max(1,Math.floor(Math.min(cw/game.width,ch/game.height))); game.style.width=(game.width*s)+'px'; game.style.height=(game.height*s)+'px'; }
  new ResizeObserver(fit).observe(wrap);

  /* ---------- Colors ---------- */
  const C={ bg:'#201335', plate:'#6d58a5', plate2:'#584787', border:'#2a2144', dot:'#3a2c5d',
            grave:'#7c6ac0', graveDark:'#362a56', shadow:'rgba(0,0,0,.55)',
            seekerBody:'#aab9cc', seekerEye:'#37a5ff',
            player:'#ff7a33', playerDark:'#b74f14',
            brick:'#70322a', brickDark:'#3a1713', phone:'#d63c2f', phoneDial:'#e9c8a8' };

  /* ---------- Levels ---------- */
  const LEVEL0=Array.from({length:MAP_H},()=>Array(MAP_W).fill(1));
  for(let y=2;y<MAP_H-1;y+=2){ for(let x=1;x<MAP_W-1;x++) LEVEL0[y][x]=0; }
  for(let x=2;x<MAP_W-1;x+=2){ for(let y=1;y<MAP_H-1;y++) LEVEL0[y][x]=0; }
  for(let y=1;y<5;y++) for(let x=12;x<15;x++) LEVEL0[y][x]=0;
  LEVEL0[8][8]=0; LEVEL0[7][8]=0; LEVEL0[8][7]=0; LEVEL0[8][9]=0;
  for(let x=6;x<=9;x++) LEVEL0[MAP_H-1][x]=0;

  const LEVEL1=Array.from({length:MAP_H},()=>Array(MAP_W).fill(0));
  for(let x=0;x<MAP_W;x++){ LEVEL1[0][x]=1; LEVEL1[MAP_H-1][x]=1; }
  for(let y=0;y<MAP_H;y++){ LEVEL1[y][0]=1; LEVEL1[y][MAP_W-1]=1; }
  for(let x=6;x<=9;x++) LEVEL1[MAP_H-1][x]=0;

  const PHONES=[[1,3],[1,6],[1,9],[1,12],[4,1],[7,1],[10,1],[14,3],[14,6],[14,9],[4,13],[7,13],[10,13],[13,13]];
  const phoneSet=new Set(PHONES.map(([x,y])=>`${x},${y}`));

  /* ---------- Entities ---------- */
  function makePlayer(x,y){ return {x,y,spd:0.09,anim:0,stepTimer:0,stepPhase:0}; }
  function makeSeeker(x,y){ return {x,y,spd:0.07,path:[],target:null,repathAt:0}; }
  const player=makePlayer(13.5,2.5);
  const seeker=makeSeeker(8.5,8.5);

  /* ---------- Input (keyboard) ---------- */
  const keys=new Set(); addEventListener('keydown',e=>{const k=e.key.toLowerCase(); if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','e'].includes(k)) e.preventDefault(); keys.add(k);});
  addEventListener('keyup',e=> keys.delete(e.key.toLowerCase()));

  /* ---------- D-Pad (touch/buttons) ---------- */
  const dpad=document.getElementById('dpad');
  const heldDirs=new Set(); // 'up','down','left','right'
  function updateDirFromHeld(){
    // 계산된 축으로 변환
    let ax=0, ay=0;
    if(heldDirs.has('left')) ax-=1;
    if(heldDirs.has('right')) ax+=1;
    if(heldDirs.has('up')) ay-=1;
    if(heldDirs.has('down')) ay+=1;
    dpadState.ax=ax; dpadState.ay=ay;
  }
  const dpadState={ax:0, ay:0};
  function bindDirBtn(btn){
    const dir=btn.dataset.dir;
    const onDown=(e)=>{ e.preventDefault(); heldDirs.add(dir); updateDirFromHeld(); btn.classList.add('active'); };
    const onUp=(e)=>{ e.preventDefault(); heldDirs.delete(dir); updateDirFromHeld(); btn.classList.remove('active'); };
    btn.addEventListener('pointerdown', onDown);
    btn.addEventListener('pointerup', onUp);
    btn.addEventListener('pointercancel', onUp);
    btn.addEventListener('pointerleave', onUp);
    // 멀티터치 허용
    btn.addEventListener('touchstart', onDown, {passive:false});
    btn.addEventListener('touchend', onUp, {passive:false});
    btn.addEventListener('touchcancel', onUp, {passive:false});
  }
  dpad.querySelectorAll('button[data-dir]').forEach(bindDirBtn);

  /* ---------- Room state / collision ---------- */
  let room=0;
  function solidAt(tx,ty){
    if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return true;
    if(room===0) return LEVEL0[ty][tx]===1;
    if(LEVEL1[ty][tx]===1) return true;
    if(phoneSet.has(`${tx},${ty}`)) return true;
    return false;
  }
  function moveEntity(e,ax,ay){
    const spd=e.spd; let nx=e.x+ax*spd, ny=e.y+ay*spd;
    if(!solidAt(nx|0, e.y|0)) e.x=nx;
    if(!solidAt(e.x|0, ny|0)) e.y=ny;
  }

  /* ---------- UI / Interaction ---------- */
  const btnE=document.getElementById('btnE'), dialog=document.getElementById('dialog');
  const dgTitle=document.getElementById('dgTitle'), dgBody=document.getElementById('dgBody'), dgChoices=document.getElementById('dgChoices');
  function closeDialog(){ dialog.style.display='none'; dgChoices.innerHTML=''; }
  dialog.addEventListener('click', (e)=>{ if(e.target===dialog) closeDialog(); });

  function graveText(x,y){
    const lines=["나는 얼굴을 잃고, 귀로만 걷는다.","빛이 고요를 문질러 소리가 났다.","오차가 감정이고, 잔향이 초상이다.","돌은 서 있고, 이야기는 흘러간다.","너와 나 사이, 빈칸이 숨을 쉰다.","시간의 모서리에 귀를 댔다.","여기 눕힌 건 말들이다.","망각의 틈에서 작은 불이 켜진다."];
    const idx=(x*31+y*17)%lines.length; return lines[idx];
  }
  function nearestGrave(px,py){
    let best=null, bd=1e9;
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL0[y][x]===1){
      const cx=x+0.5, cy=y+0.5; const d=Math.hypot(px-cx,py-cy);
      if(d<bd){bd=d; best={x,y,cx,cy};}
    }
    return {grave:best, dist:bd};
  }
  function nearestPhone(px,py){
    let best=null,bd=1e9;
    for(const [x,y] of PHONES){
      const cx=x+0.5, cy=y+0.5; const d=Math.hypot(px-cx,py-cy);
      if(d<bd){bd=d; best={x,y,cx,cy};}
    }
    return {phone:best, dist:bd};
  }

  // 로봇 대화(룸0)
  const convo=[
    {npc:"……신호 포착. 너는 소리를 어떻게 듣지?",choices:["몸으로 먼저 듣는다.","기억으로 해석한다."],replies:["좋아. 몸은 진실을 숨기지 않지.","그래, 기억은 언제나 편집본이야."]},
    {npc:"여기 비석들은 잊힌 말들의 좌표야.",choices:["좌표를 따라가면 어디에 닿을까?","말이 사라지면 무엇이 남지?"],replies:["아마 네가 모르는 너에게.","침묵. 그리고 방향."]},
    {npc:"마지막 질문. 너는 왜 계속 걷고 있어?",choices:["누군가의 잔향을 찾고 있어.","멈추면, 들리지 않을까 봐."],replies:["그 잔향이 네 지도를 바꿀 거야.","걷는 침묵은 언제나 열려 있지."]}
  ];
  let inConvo=false, stepIdx=0;
  function openRobotConvo(){ inConvo=true; stepIdx=0; renderConvoStep(); dialog.style.display='flex'; SFX.interact(); }
  function renderConvoStep(){
    dgTitle.textContent='로봇(비석의 방 순찰)';
    const s=convo[stepIdx]; dgBody.innerHTML=`<div style="white-space:pre-wrap">${s.npc}</div>`; dgChoices.innerHTML='';
    s.choices.forEach((text,i)=>{ const b=document.createElement('button'); b.textContent=text;
      b.onclick=()=>{ SFX.select(); const reply=s.replies[i]; dgBody.innerHTML+=`\n\n> 너: ${text}\n로봇: ${reply}`; stepIdx++; if(stepIdx<convo.length){ setTimeout(()=>renderConvoStep(),420);} else { dgChoices.innerHTML=''; const done=document.createElement('button'); done.textContent='끝내기'; done.onclick=()=>{ inConvo=false; dialog.style.display='none'; }; dgChoices.appendChild(done);} };
      dgChoices.appendChild(b);
    });
  }

  /* ---------- Robot patrol (room0) ---------- */
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function randomWalkableTile0(){ let tx,ty; do{ tx=(Math.random()*MAP_W)|0; ty=(Math.random()*MAP_H)|0; }while(LEVEL0[ty]?.[tx]!==0); return {tx,ty}; }
  function bfsPath(level, fromX,fromY,toX,toY){
    const Q=[[fromX,fromY]], V=new Set([fromX+','+fromY]), P={}, dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const solid=(x,y)=>{ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return true; return level===0 ? (LEVEL0[y][x]===1) : (LEVEL1[y][x]===1 || phoneSet.has(`${x},${y}`)); };
    while(Q.length){
      const [x,y]=Q.shift(); if(x===toX&&y===toY) break;
      for(const [dx,dy] of dirs){
        const nx=x+dx, ny=y+dy; if(solid(nx,ny)) continue;
        const k=nx+','+ny; if(V.has(k)) continue; V.add(k); P[k]=[x,y]; Q.push([nx,ny]);
      }
    }
    const key=toX+','+toY; if(!(key in P) && !(fromX===toX && fromY===toY)) return [];
    let path=[[toX,toY]]; let cx=toX, cy=toY;
    while(!(cx===fromX && cy===fromY)){ const prev=P[cx+','+cy]; if(!prev) break; path.push(prev); cx=prev[0]; cy=prev[1]; }
    path.reverse(); return path;
  }
  function ensurePatrolTarget(force=false){
    if(room!==0||inConvo) return;
    const now=performance.now();
    if(force || !seeker.target || now>seeker.repathAt || seeker.path.length===0){
      let t=randomWalkableTile0(), tries=0;
      while(dist({x:t.tx+0.5,y:t.ty+0.5}, player)<3 && tries++<10) t=randomWalkableTile0();
      seeker.target=t;
      const sx=seeker.x|0, sy=seeker.y|0;
      seeker.path=bfsPath(0, sx,sy,t.tx,t.ty);
      seeker.repathAt=now+5000+Math.random()*5000;
    }
  }
  function stepSeeker(){
    if(room!==0||inConvo) return;
    ensurePatrolTarget();
    if(seeker.path.length>0){
      const [nx,ny]=seeker.path[0], tx=nx+0.5, ty=ny+0.5;
      const dx=tx-seeker.x, dy=ty-seeker.y, m=Math.hypot(dx,dy);
      if(m<0.05){ seeker.x=tx; seeker.y=ty; seeker.path.shift(); }
      else{ const ax=dx/m, ay=dy/m; moveEntity(seeker, ax, ay); }
    }else ensurePatrolTarget(true);
  }

  /* ---------- Pre-render layers ---------- */
  function makeLayer(drawFn){
    const off=document.createElement('canvas'); off.width=game.width; off.height=game.height;
    const gg=off.getContext('2d'); gg.imageSmoothingEnabled=false; drawFn(gg); return off;
  }
  function drawCommonBoard(gg){
    gg.fillStyle=C.bg; gg.fillRect(0,0,game.width,game.height);
    gg.fillStyle=C.border; gg.fillRect(6,6,game.width-12,game.height-12);
    gg.fillStyle=C.plate;  gg.fillRect(12,12,game.width-24,game.height-24);
    gg.fillStyle=C.dot; for(let i=0;i<190;i++){ const x=12+((i*73)% (game.width-24)); const y=12+((i*97)% (game.height-24)); gg.fillRect(x,y,1,1); }
  }
  function drawGrave(gg,px,py){
    gg.fillStyle=C.shadow; gg.fillRect(px+2,py+TILE-3,TILE-2,2);
    gg.fillStyle=C.graveDark; gg.fillRect(px+3,py+3,TILE-6,TILE-6);
    gg.fillStyle=C.grave; gg.fillRect(px+2,py+4,TILE-6,TILE-7);
    gg.fillStyle='rgba(255,255,255,.08)'; gg.fillRect(px+3,py+4,TILE-8,1);
  }
  function drawBrick(gg,px,py){
    gg.fillStyle=C.brickDark; gg.fillRect(px,py,TILE,TILE);
    gg.fillStyle=C.brick; gg.fillRect(px+1,py+1,TILE-2,TILE-2);
    gg.fillStyle='rgba(0,0,0,.25)'; gg.fillRect(px+1,py+TILE-4,TILE-2,3);
  }
  function drawPhone(gg,px,py){
    gg.fillStyle=C.phone; gg.fillRect(px+2,py+5,12,8);
    gg.fillStyle=C.phoneDial; gg.fillRect(px+5,py+7,6,4);
    gg.fillStyle='rgba(255,255,255,.12)'; gg.fillRect(px+3,py+6,8,1);
    gg.fillStyle=C.shadow; gg.fillRect(px+2,py+TILE-2,12,2);
  }

  const layer0 = makeLayer((gg)=>{
    drawCommonBoard(gg);
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL0[y][x]===1) drawGrave(gg,x*TILE,y*TILE);
    gg.fillStyle=C.plate2; gg.fillRect(6*TILE,15*TILE,4*TILE,TILE);
  });
  const layer1 = makeLayer((gg)=>{
    drawCommonBoard(gg);
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) if(LEVEL1[y][x]===1) drawBrick(gg,x*TILE,y*TILE);
    for(const [x,y] of PHONES) drawPhone(gg,x*TILE,y*TILE);
    gg.fillStyle=C.plate2; gg.fillRect(6*TILE,15*TILE,4*TILE,TILE);
  });

  /* ---------- Render helpers ---------- */
  function drawSeeker(){
    if(room!==0) return;
    const px=Math.round(seeker.x*TILE - TILE/2), py=Math.round(seeker.y*TILE - TILE/2);
    g.fillStyle=C.seekerBody; g.fillRect(px+3,py+6,10,6);
    g.fillStyle='#ffffff'; g.fillRect(px+2,py+4,12,6);
    g.fillStyle=C.seekerEye; g.fillRect(px+5,py+6,2,2); g.fillRect(px+9,py+6,2,2);
    g.fillStyle='#111'; g.fillRect(px+1,py+8,2,3); g.fillRect(px+13,py+8,2,3);
  }
  function drawPlayer(p){
    const px=Math.round(p.x*TILE - TILE/2), py=Math.round(p.y*TILE - TILE/2);
    g.fillStyle=C.shadow; g.fillRect(px+2,py+TILE-2,TILE-4,2);
    g.fillStyle=C.player; g.fillRect(px+4,py+5,8,7);
    g.fillStyle=C.playerDark; g.fillRect(px+4,py+4,8,2);
    if(((p.anim*10)|0)%20<10){ g.fillStyle='#000'; g.fillRect(px+6, py+7, 1,1); g.fillRect(px+9, py+7, 1,1); }
  }

  /* ---------- Loop ---------- */
  let last=0; function loop(t){ requestAnimationFrame(loop); const dt=Math.min(32,(t-last)||16); last=t; update(dt/16); render(); }

  function update(dt){
    // 키보드 + D패드 결합 입력
    let ax=0, ay=0;
    if(keys.has('a')||keys.has('arrowleft')) ax-=1;
    if(keys.has('d')||keys.has('arrowright')) ax+=1;
    if(keys.has('w')||keys.has('arrowup')) ay-=1;
    if(keys.has('s')||keys.has('arrowdown')) ay+=1;
    ax+=dpadState.ax; ay+=dpadState.ay;
    const m=Math.hypot(ax,ay)||1; ax/=m; ay/=m;

    // 플레이어 이동 + 발소리
    const moving=Math.hypot(ax,ay)>0.1 && !inConvo;
    if(!inConvo) moveEntity(player,ax,ay);
    player.anim+=dt;
    if(moving){ player.stepTimer+=dt*1000; if(player.stepTimer>=180){ player.stepTimer=0; SFX.step(player.stepPhase++); } } else player.stepTimer=0;

    // 로봇 순찰
    stepSeeker();

    // 방 전환(하단 6..9)
    if((player.y|0)===MAP_H-1 && (player.x|0)>=6 && (player.x|0)<=9){
      room = room===0 ? 1 : 0;
      badge.textContent = room===0 ? 'ROOM: 비석의 방 · 하단 출구 → 전화기의 방' : 'ROOM: 전화기의 방 · 하단 출구 → 비석의 방';
      player.x=8.5; player.y=14.2;
      inConvo=false; dialog.style.display='none'; dgChoices.innerHTML='';
    }

    // 상호작용 버튼 표시/동작
    let label="", action=null;
    if(room===0){
      if(!inConvo && Math.hypot(player.x-seeker.x, player.y-seeker.y)<0.85){ label='E: 로봇과 대화'; action=()=> openRobotConvo(); }
      else{
        const ng=nearestGrave(player.x,player.y);
        if(ng.grave && ng.dist<1.1){ label='E: 비석에 귀 기울이기'; action=()=>{ SFX.interact(); dgTitle.textContent='비석의 기록'; dgBody.textContent=graveText(ng.grave.x,ng.grave.y); dgChoices.innerHTML=''; dialog.style.display='flex'; }; }
      }
    }else{
      const np=nearestPhone(player.x,player.y);
      if(np.phone && np.dist<1.1){ label='E: 수화기 들기'; action=()=>{ SFX.ring(); dgTitle.textContent='전화기의 방'; dgBody.textContent='...여보세요? (침묵 속의 목소리가 미세하게 울린다)'; dgChoices.innerHTML=''; dialog.style.display='flex'; }; }
    }
    if(action){ btnE.style.display='grid'; btnE.textContent=label; btnE.onclick=action; } else { btnE.style.display='none'; btnE.onclick=null; }
  }

  function render(){
    g.clearRect(0,0,game.width,game.height);
    g.drawImage(room===0 ? layer0 : layer1, 0, 0); // 단일 레이어만
    drawSeeker();
    drawPlayer(player);
  }

  // 키보드 E
  addEventListener('keydown', e=>{ if((e.key==='e'||e.key==='E')){ if(btnE.style.display!=='none'){ e.preventDefault(); btnE.click(); }}});

  fit(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
