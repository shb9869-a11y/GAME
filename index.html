<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport"
        content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,interactive-widget=resizes-content">
  <title>PIXEL RABBIT – SLEEP</title>

  <!-- 픽셀 게임 폰트 -->
  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">

  <style>
    :root{
      --bg-main: #111;
      --fg-light: #f5f5f5;
      --fg-mid: #bfbfbf;
      --fg-dark: #333;
      --accent: #ff3333; /* 빨간 토끼 */
    }

    *{
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body{
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at top, #444 0, #000 55%);
      color: var(--fg-light);
      font-family: "Press Start 2P", system-ui, sans-serif;
      overscroll-behavior: none;
      -webkit-font-smoothing: none;
      image-rendering: pixelated;
      touch-action: none;
    }

    #game-root{
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
    }

    .frame{
      border: 4px solid #666;
      box-shadow: 0 0 0 4px #000, 0 12px 32px rgba(0,0,0,0.8);
      background: #222;
      border-radius: 12px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-width: min(520px, 100%);
      max-height: 100%;
    }

    .top-bar{
      display: flex;
      justify-content: space-between;
      font-size: 8px;
      color: #aaa;
      letter-spacing: 1px;
    }

    .top-bar span{
      opacity: 0.8;
    }

    #game-canvas{
      background: #0d0d0d;
      border-radius: 4px;
      border: 2px solid #555;
      width: min(480px, 100vw - 32px);
      height: calc(min(480px, 100vw - 32px) * 0.75); /* 4:3 비율 */
      image-rendering: pixelated;
      touch-action: none;
    }

    .bottom-bar{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 8px;
      color: #ccc;
    }

    #msg{
      flex: 1;
      min-height: 2.5em;
      line-height: 1.3;
      overflow: hidden;
      white-space: normal;
    }

    .btn-row{
      display: flex;
      gap: 4px;
    }

    button{
      font-family: inherit;
      font-size: 8px;
      padding: 4px 6px;
      border-radius: 3px;
      border: 1px solid #777;
      background: #202020;
      color: #eee;
      cursor: pointer;
      letter-spacing: 1px;
    }

    button:active{
      transform: translateY(1px);
      background: #101010;
    }

    button[disabled]{
      opacity: 0.35;
      cursor: default;
      transform: none;
    }

    @media (min-width: 768px){
      .frame{
        max-width: 640px;
      }
      #game-canvas{
        width: 512px;
        height: 384px;
      }
    }
  </style>
</head>
<body>
<div id="game-root">
  <div class="frame">
    <div class="top-bar">
      <span>PIXEL RABBIT</span>
      <span id="chapter-label">INTRO</span>
    </div>
    <canvas id="game-canvas" width="320" height="240"></canvas>
    <div class="bottom-bar">
      <div id="msg">화면을 터치해서 시작하세요.</div>
      <div class="btn-row">
        <button id="btn-prev">◀</button>
        <button id="btn-next">▶</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   기본 설정
   ========================= */
const canvas = document.getElementById('game-canvas');
const ctx     = canvas.getContext('2d');
const msgEl   = document.getElementById('msg');
const chapEl  = document.getElementById('chapter-label');
const btnPrev = document.getElementById('btn-prev');
const btnNext = document.getElementById('btn-next');

const WIDTH  = canvas.width;
const HEIGHT = canvas.height;

// 타임 관리
let lastTime = 0;

// 게임 전역 상태
const STATE = {
  chapterIndex: 0,   // 0 = intro, 1~5 챕터
  miniIndex: 0,      // 각 챕터 안의 소게임 인덱스
  currentGame: null,
  pointer: {x:0,y:0,down:false},
};

/* =========================
   유틸
   ========================= */
function setMessage(text){
  msgEl.textContent = text;
}

function setChapterLabel(text){
  chapEl.textContent = text;
}

// 좌표 변환 (캔버스 기준)
function getCanvasPos(evt){
  const rect = canvas.getBoundingClientRect();
  const cx = (evt.touches ? evt.touches[0].clientX : evt.clientX) - rect.left;
  const cy = (evt.touches ? evt.touches[0].clientY : evt.clientY) - rect.top;
  const x = cx * (canvas.width / rect.width);
  const y = cy * (canvas.height / rect.height);
  return {x, y};
}

/* =========================
   빨간 토끼 스프라이트 (8x8 스타일)
   ========================= */
function drawRedRabbit(x, y){
  const s = 8; // 픽셀 사이즈
  ctx.fillStyle = '#ff3333';
  // 간단한 8x8 토끼 (2프레임 정도로도 쓸 수 있음)
  // 머리
  ctx.fillRect(x+2, y+1, s*4/8, s*3/8);
  // 귀
  ctx.fillRect(x+1, y-1, s*1/8, s*3/8);
  ctx.fillRect(x+4, y-1, s*1/8, s*3/8);
  // 몸통
  ctx.fillRect(x+2, y+4, s*4/8, s*3/8);
  // 꼬리
  ctx.fillRect(x+6, y+4, s*2/8, s*2/8);
}

/* =========================
   베이스 미니게임 클래스 형태
   ========================= */
class MiniGame {
  constructor(name, chapter, description){
    this.name = name;
    this.chapter = chapter;
    this.description = description;
    this.isDone = false;
    this.timer = 0;
  }
  init(){
    this.isDone = false;
    this.timer = 0;
    setMessage(this.description);
  }
  update(dt){
    this.timer += dt;
  }
  draw(ctx){}
  pointerDown(x,y){}
}

/* =========================
   CHAPTER 0 – INTRO
   ========================= */
class IntroGame extends MiniGame {
  constructor(){
    super("INTRO", 0,
      "빨간 토끼와 함께 픽셀 세계를 탐험합니다. 화면을 터치해 시작하세요."
    );
    this.t = 0;
  }
  update(dt){
    super.update(dt);
    this.t += dt;
  }
  draw(ctx){
    ctx.fillStyle = "#0b0b0b";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    // 가운데에 큰 텍스트
    ctx.fillStyle = "#f5f5f5";
    ctx.font = "12px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("PIXEL RABBIT", WIDTH/2, HEIGHT/2 - 20);

    ctx.font = "7px 'Press Start 2P'";
    ctx.fillText("TAP TO START", WIDTH/2, HEIGHT/2 + 10);

    // 화면 아래에서 깡총깡총 토끼
    const hop = Math.sin(this.t*4) * 3;
    drawRedRabbit(WIDTH/2 - 4, HEIGHT - 40 + hop);
  }
  pointerDown(){
    nextChapter();
  }
}

/* =========================
   CHAPTER 1 – 급식실 산재 노동자
   1) 정지한 파형
   ========================= */
class WaveGame extends MiniGame {
  constructor(){
    super("정지한 파형", 1,
      "파형이 거의 평평해지는 순간을 터치하세요."
    );
    this.t = 0;
    this.lastTap = null;
    this.resultShown = false;
  }
  init(){
    super.init();
    this.t = 0;
    this.resultShown = false;
  }
  update(dt){
    super.update(dt);
    this.t += dt;
  }
  draw(ctx){
    ctx.fillStyle = "#000000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const midY = HEIGHT/2;
    ctx.strokeStyle = "#f5f5f5";
    ctx.lineWidth = 1;

    ctx.beginPath();
    ctx.moveTo(0, midY);
    const baseAmp = 20;
    // 특정 시간대에 amplitude 작아지게 (flat zone)
    let amp = baseAmp * (0.3 + 0.7*Math.abs(Math.sin(this.t*0.5)));
    // flat 구간
    const phase = this.t * 0.5;
    if(Math.abs(Math.sin(phase*1.2)) < 0.2){
      amp = 2; // 거의 평평
    }

    for(let x=0; x<WIDTH; x++){
      const t = (x/40) + phase;
      const y = midY + Math.sin(t)*amp;
      ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = "#777";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText("TAP WHEN FLAT", 6, 12);
  }
  pointerDown(){
    // 평평할 때: sin(phase*1.2)가 작을 때
    const phase = this.t * 0.5;
    const flatScore = Math.abs(Math.sin(phase*1.2));
    const now = this.timer;
    if(this.lastTap === null){
      this.lastTap = now;
    }
    const delta = now - (this.lastTap || 0);
    this.lastTap = now;

    if(flatScore < 0.15){
      setMessage(`평평한 순간을 포착했습니다. (정확도: ${( (1-flatScore)*100 ).toFixed(1)}%)`);
      this.isDone = true;
    }else{
      setMessage("조금 이른(or 늦은) 포착입니다. 다시 시도해보세요.");
    }
  }
}

/* =========================
   CHAPTER 1 – 2) 사라지는 픽셀
   ========================= */
class FadingPixelGame extends MiniGame {
  constructor(){
    super("사라지는 픽셀", 1,
      "서서히 어두워지는 픽셀을 찾아 터치하세요."
    );
    this.gridSize = 5;
    this.specialIndex = 0;
    this.startTime = 0;
    this.found = false;
  }
  init(){
    super.init();
    this.gridSize = Math.random() < 0.5 ? 4 : 5;
    this.specialIndex = Math.floor(Math.random()*this.gridSize*this.gridSize);
    this.startTime = performance.now();
    this.found = false;
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const padding = 40;
    const size = Math.min(WIDTH, HEIGHT) - padding*2;
    const cell = size / this.gridSize;
    const offsetX = (WIDTH - size)/2;
    const offsetY = (HEIGHT - size)/2;

    const elapsed = (performance.now() - this.startTime)/1000;
    const darkFactor = Math.min(elapsed/3, 1); // 3초 동안 어두워짐

    for(let i=0;i<this.gridSize*this.gridSize;i++){
      const gx = i % this.gridSize;
      const gy = Math.floor(i/this.gridSize);
      const x = offsetX + gx*cell;
      const y = offsetY + gy*cell;

      if(i === this.specialIndex){
        // 점점 어두워짐
        const v = 220 - darkFactor*140;
        ctx.fillStyle = `rgb(${v},${v},${v})`;
      }else{
        ctx.fillStyle = "#e0e0e0";
      }
      ctx.fillRect(x+2,y+2,cell-4,cell-4);
    }

    ctx.strokeStyle = "#555";
    ctx.strokeRect(offsetX-4, offsetY-4, size+8, size+8);
  }
  pointerDown(x,y){
    if(this.found) return;
    const padding = 40;
    const size = Math.min(WIDTH, HEIGHT) - padding*2;
    const cell = size / this.gridSize;
    const offsetX = (WIDTH - size)/2;
    const offsetY = (HEIGHT - size)/2;

    const gx = Math.floor((x - offsetX) / cell);
    const gy = Math.floor((y - offsetY) / cell);
    if(gx<0||gy<0||gx>=this.gridSize||gy>=this.gridSize) return;

    const idx = gy*this.gridSize + gx;
    const elapsed = (performance.now() - this.startTime)/1000;

    if(idx === this.specialIndex){
      this.found = true;
      this.isDone = true;
      setMessage(`변화를 ${elapsed.toFixed(2)}초 만에 발견했습니다.`);
    }else{
      setMessage("다른 픽셀입니다. 다시 시도해보세요.");
    }
  }
}

/* =========================
   CHAPTER 2 – 카메룬 내전 난민
   1) 겹치는 곳
   ========================= */
class OverlapGame extends MiniGame {
  constructor(){
    super("겹치는 곳", 2,
      "두 도형이 정확히 겹쳐질 때를 터치하세요."
    );
    this.t = 0;
  }
  init(){
    super.init();
    this.t = 0;
  }
  update(dt){
    super.update(dt);
    this.t += dt;
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const centerY = HEIGHT/2;
    const size = 40;

    // 왼쪽: 프레임 삼각형 (outline)
    const progress = (Math.sin(this.t*0.3) + 1)/2; // 0~1
    const leftX  = WIDTH*0.1 + progress*WIDTH*0.3;
    const rightX = WIDTH*0.9 - progress*WIDTH*0.3;

    ctx.lineWidth = 2;

    // outline triangle
    ctx.strokeStyle = "#f5f5f5";
    ctx.beginPath();
    ctx.moveTo(leftX, centerY - size/2);
    ctx.lineTo(leftX - size/2, centerY + size/2);
    ctx.lineTo(leftX + size/2, centerY + size/2);
    ctx.closePath();
    ctx.stroke();

    // filled triangle
    ctx.fillStyle = "#d0d0d0";
    ctx.beginPath();
    ctx.moveTo(rightX, centerY - size/2);
    ctx.lineTo(rightX - size/2, centerY + size/2);
    ctx.lineTo(rightX + size/2, centerY + size/2);
    ctx.closePath();
    ctx.fill();

    // 겹치는 정도 안내
    const dist = Math.abs(leftX - rightX);
    ctx.fillStyle = "#777";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("TAP WHEN THEY OVERLAP", WIDTH/2, 20);

    // 시각적 보조 (미세 회색 라인)
    ctx.strokeStyle = "#222";
    ctx.beginPath();
    ctx.moveTo(WIDTH/2, 0);
    ctx.lineTo(WIDTH/2, HEIGHT);
    ctx.stroke();
  }
  pointerDown(x,y){
    const progress = (Math.sin(this.t*0.3) + 1)/2;
    const leftX  = WIDTH*0.1 + progress*WIDTH*0.3;
    const rightX = WIDTH*0.9 - progress*WIDTH*0.3;
    const dist = Math.abs(leftX - rightX);
    if(dist < 10){
      this.isDone = true;
      setMessage("겹치는 순간을 포착했습니다.");
    }else{
      setMessage("조금 어긋났습니다. 다시 시도해보세요.");
    }
  }
}

/* =========================
   CHAPTER 3 – 인도 표백 노동자
   1) 떨어지는 픽셀
   ========================= */
class FallingPixelsGame extends MiniGame {
  constructor(){
    super("떨어지는 픽셀", 3,
      "떨어지는 흰 픽셀만 15개 이상 터치하세요."
    );
    this.pixels = [];
    this.spawnTimer = 0;
    this.collected = 0;
  }
  init(){
    super.init();
    this.pixels = [];
    this.spawnTimer = 0;
    this.collected = 0;
  }
  spawnPixel(){
    this.pixels.push({
      x: Math.random()*WIDTH,
      y: -10,
      vy: 30 + Math.random()*40,
      type: Math.random()<0.6 ? "white" : "gray",
      dead: false
    });
  }
  update(dt){
    super.update(dt);
    this.spawnTimer += dt;
    if(this.spawnTimer > 0.4){
      this.spawnTimer = 0;
      this.spawnPixel();
    }
    for(const p of this.pixels){
      p.y += p.vy*dt;
      if(p.y > HEIGHT+10) p.dead = true;
    }
    this.pixels = this.pixels.filter(p=>!p.dead);
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    for(const p of this.pixels){
      if(p.type==="white"){
        ctx.fillStyle = "#ffffff";
      }else{
        ctx.fillStyle = "#777777";
      }
      ctx.fillRect(p.x-3,p.y-3,6,6);
    }

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText(`WHITE: ${this.collected}/15`, 6, 14);
  }
  pointerDown(x,y){
    // 가까운 픽셀 찾기
    for(const p of this.pixels){
      const dx = p.x - x;
      const dy = p.y - y;
      if(Math.sqrt(dx*dx+dy*dy) < 10){
        if(p.type==="white"){
          this.collected++;
          p.dead = true;
          setMessage(`흰 픽셀을 포착했습니다. (${this.collected}/15)`);
          if(this.collected>=15){
            this.isDone = true;
            setMessage("충분한 픽셀을 포착했습니다.");
          }
        }else{
          setMessage("회색 픽셀입니다. 피부가 더 하얘지는 건 아닙니다.");
          // 패널티: 하나 감소 (0 이하로는 내려가지 않게)
          this.collected = Math.max(0, this.collected-1);
        }
        break;
      }
    }
  }
}

/* =========================
   CHAPTER 3 – 2) 픽셀 포착
   ========================= */
class BlinkPixelsGame extends MiniGame {
  constructor(){
    super("픽셀 포착", 3,
      "반짝이는 흰 픽셀을 예측해서 눌러보세요."
    );
    this.points = [];
    this.success = 0;
    this.total = 0;
  }
  init(){
    super.init();
    this.points = [];
    this.success = 0;
    this.total = 0;
    // 몇 개 포인트 생성
    for(let i=0;i<8;i++){
      this.points.push({
        x: 40 + Math.random()*(WIDTH-80),
        y: 40 + Math.random()*(HEIGHT-80),
        phase: Math.random()*Math.PI*2
      });
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const t = this.timer;

    for(const p of this.points){
      const wave = (Math.sin(t*4 + p.phase)+1)/2; // 0~1
      const visible = wave>0.7; // 반짝일 때

      if(visible){
        const size = 5 + wave*4;
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(p.x-size/2, p.y-size/2, size, size);
      }
    }

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    const rate = this.total>0 ? Math.round(this.success/this.total*100) : 0;
    ctx.fillText(`HIT: ${this.success}/${this.total} (${rate}%)`, 6, 14);
  }
  pointerDown(x,y){
    const t = this.timer;
    this.total++;
    let hit = false;
    for(const p of this.points){
      const wave = (Math.sin(t*4 + p.phase)+1)/2;
      const visible = wave>0.7;
      const dx = p.x - x;
      const dy = p.y - y;
      if(visible && Math.sqrt(dx*dx+dy*dy)<10){
        this.success++;
        hit = true;
        break;
      }
    }
    if(hit){
      setMessage("반짝이는 순간을 포착했습니다.");
    }else{
      setMessage("픽셀이 이미 사라졌습니다.");
    }
    if(this.success>=5){
      this.isDone = true;
      setMessage(`예측 성공률 ${(this.success/this.total*100).toFixed(1)}%`);
    }
  }
}

/* =========================
   CHAPTER 4 – 태국 쓰레기산
   1) 픽셀 쌓기 (간단 테트리스 스타일)
   ========================= */
class StackGame extends MiniGame {
  constructor(){
    super("픽셀 쌓기", 4,
      "떨어지는 블록들이 화면 절반 높이까지 쌓이도록 해보세요."
    );
    this.cols = 10;
    this.rows = 16;
    this.grid = [];
    this.current = null;
    this.dropTimer = 0;
    this.dropInterval = 0.5;
  }
  init(){
    super.init();
    this.grid = Array(this.rows).fill(0).map(()=>Array(this.cols).fill(0));
    this.spawnBlock();
    this.dropTimer = 0;
  }
  spawnBlock(){
    const shapes = [
      [[1,1,1,1]],           // I
      [[1,1],[1,1]],         // O
      [[1,1,0],[0,1,1]]      // Z
    ];
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    this.current = {
      shape,
      x: Math.floor(this.cols/2)-1,
      y: 0
    };
  }
  canMove(dx,dy){
    const s = this.current.shape;
    for(let r=0;r<s.length;r++){
      for(let c=0;c<s[0].length;c++){
        if(!s[r][c]) continue;
        const nx = this.current.x + c + dx;
        const ny = this.current.y + r + dy;
        if(nx<0||nx>=this.cols||ny<0||ny>=this.rows) return false;
        if(this.grid[ny][nx]) return false;
      }
    }
    return true;
  }
  lockBlock(){
    const s = this.current.shape;
    for(let r=0;r<s.length;r++){
      for(let c=0;c<s[0].length;c++){
        if(!s[r][c]) continue;
        const gx = this.current.x + c;
        const gy = this.current.y + r;
        if(gy>=0 && gy<this.rows) this.grid[gy][gx] = 1;
      }
    }
    this.current = null;
    this.spawnBlock();
  }
  update(dt){
    super.update(dt);
    this.dropTimer += dt;
    if(this.dropTimer>=this.dropInterval){
      this.dropTimer = 0;
      if(this.canMove(0,1)){
        this.current.y++;
      }else{
        this.lockBlock();
      }
    }

    // 높이 체크
    let maxRow = 0;
    for(let r=0;r<this.rows;r++){
      if(this.grid[r].some(c=>c)) maxRow = this.rows-r;
    }
    if(maxRow >= this.rows/2){
      this.isDone = true;
      setMessage("충분히 쌓였습니다.");
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const cell = 12;
    const gridWidth = this.cols*cell;
    const gridHeight = this.rows*cell;
    const offsetX = (WIDTH - gridWidth)/2;
    const offsetY = (HEIGHT - gridHeight)/2;

    // 고정 블록
    for(let r=0;r<this.rows;r++){
      for(let c=0;c<this.cols;c++){
        if(this.grid[r][c]){
          ctx.fillStyle = "#888";
          ctx.fillRect(offsetX+c*cell+1, offsetY+r*cell+1, cell-2, cell-2);
        }
      }
    }

    // 현재 블록
    if(this.current){
      ctx.fillStyle = "#e0e0e0";
      const s = this.current.shape;
      for(let r=0;r<s.length;r++){
        for(let c=0;c<s[0].length;c++){
          if(!s[r][c]) continue;
          const gx = this.current.x + c;
          const gy = this.current.y + r;
          ctx.fillRect(offsetX+gx*cell+1, offsetY+gy*cell+1, cell-2, cell-2);
        }
      }
    }

    ctx.strokeStyle = "#555";
    ctx.strokeRect(offsetX-1, offsetY-1, gridWidth+2, gridHeight+2);
  }
  pointerDown(x,y){
    // 왼쪽 터치 → 왼쪽, 오른쪽 터치 → 오른쪽
    const left = x < WIDTH/2;
    if(left){
      if(this.canMove(-1,0)) this.current.x--;
    }else{
      if(this.canMove(1,0)) this.current.x++;
    }
  }
}

/* =========================
   CHAPTER 4 – 2) 연결된 픽셀 (리듬 매칭)
   ========================= */
class LinkPixelsGame extends MiniGame {
  constructor(){
    super("연결된 픽셀", 4,
      "같은 리듬으로 깜박이는 픽셀들을 순서대로 이어주세요."
    );
    this.nodes = [];
    this.selected = null;
  }
  init(){
    super.init();
    this.nodes = [];
    const patterns = [0.8, 1.1, 1.5]; // 다른 깜박임 주기
    for(let i=0;i<9;i++){
      this.nodes.push({
        x: 40 + Math.random()*(WIDTH-80),
        y: 40 + Math.random()*(HEIGHT-80),
        pattern: patterns[i%patterns.length],
        links: []
      });
    }
    this.selected = null;
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const t = this.timer;

    // 링크된 선 그리기
    ctx.strokeStyle = "#777";
    ctx.lineWidth = 1;
    for(const n of this.nodes){
      for(const other of n.links){
        ctx.beginPath();
        ctx.moveTo(n.x, n.y);
        ctx.lineTo(other.x, other.y);
        ctx.stroke();
      }
    }

    // 노드 그리기
    for(const n of this.nodes){
      const wave = (Math.sin(t*4/n.pattern)+1)/2;
      const bright = wave>0.7;
      ctx.fillStyle = bright ? "#ffffff" : "#888888";
      ctx.beginPath();
      ctx.arc(n.x,n.y,6,0,Math.PI*2);
      ctx.fill();

      if(this.selected === n){
        ctx.strokeStyle = "#ff3333";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(n.x,n.y,9,0,Math.PI*2);
        ctx.stroke();
      }
    }

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "left";
    ctx.fillText("SAME RHYTHM = LINK", 6, 14);
  }
  pointerDown(x,y){
    let hit = null;
    for(const n of this.nodes){
      const dx = n.x - x;
      const dy = n.y - y;
      if(Math.sqrt(dx*dx+dy*dy)<8){
        hit = n;
        break;
      }
    }
    if(!hit) return;

    if(!this.selected){
      this.selected = hit;
      setMessage("같은 리듬의 픽셀을 찾아 이어보세요.");
    }else{
      if(this.selected === hit) return;
      // 패턴이 같으면 링크
      if(this.selected.pattern === hit.pattern){
        if(!this.selected.links.includes(hit)){
          this.selected.links.push(hit);
        }
        if(!hit.links.includes(this.selected)){
          hit.links.push(this.selected);
        }
        setMessage("연결되었습니다.");
      }else{
        setMessage("리듬이 다릅니다.");
      }
      this.selected = null;
    }

    // 성공 판정: 같은 패턴 노드들이 모두 연결돼 있을 때 대충 성공 처리
    let allLinked = true;
    for(const p of [0.8,1.1,1.5]){
      const group = this.nodes.filter(n=>n.pattern===p);
      // 그룹 내에서 최소 2개 이상 연결되어 있는지?
      const linkedCount = group.filter(n=>n.links.some(o=>o.pattern===p)).length;
      if(linkedCount < group.length){
        allLinked = false;
        break;
      }
    }
    if(allLinked){
      this.isDone = true;
      setMessage("연결된 리듬들이 하나의 지형이 되었습니다.");
    }
  }
}

/* =========================
   CHAPTER 5 – 빅이슈
   1) 시계방향 시곗바늘
   ========================= */
class ClockArrowsGame extends MiniGame {
  constructor(){
    super("시계방향 시곗바늘", 5,
      "모든 시곗바늘을 같은 방향으로 고정해보세요."
    );
    this.grid = [];
  }
  init(){
    super.init();
    this.grid = [];
    const size = 5;
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        this.grid.push({
          x, y,
          angle: Math.floor(Math.random()*4)*Math.PI/2,
          locked: false
        });
      }
    }
  }
  update(dt){
    super.update(dt);
    for(const a of this.grid){
      if(!a.locked){
        a.angle += dt*0.5; // 회전
      }
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    const size = 5;
    const cell = 28;
    const gridWidth = size*cell;
    const offsetX = (WIDTH-gridWidth)/2;
    const offsetY = (HEIGHT-gridWidth)/2;

    for(const a of this.grid){
      const cx = offsetX + a.x*cell + cell/2;
      const cy = offsetY + a.y*cell + cell/2;
      const len = 10;
      const ax = cx + Math.cos(a.angle)*len;
      const ay = cy + Math.sin(a.angle)*len;

      ctx.strokeStyle = a.locked ? "#ffffff" : "#888888";
      ctx.lineWidth = a.locked?2:1;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(ax,ay);
      ctx.stroke();
    }

    ctx.strokeStyle = "#555";
    ctx.strokeRect(offsetX-2,offsetY-2,gridWidth+4,gridWidth+4);

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("TAP TO LOCK", WIDTH/2, 16);
  }
  pointerDown(x,y){
    const size = 5;
    const cell = 28;
    const gridWidth = size*cell;
    const offsetX = (WIDTH-gridWidth)/2;
    const offsetY = (HEIGHT-gridWidth)/2;

    for(const a of this.grid){
      const cx = offsetX + a.x*cell + cell/2;
      const cy = offsetY + a.y*cell + cell/2;
      if(Math.abs(x-cx)<cell/2 && Math.abs(y-cy)<cell/2){
        if(!a.locked){
          // 현재 각도 가장 가까운 4방향으로 스냅
          const dir = Math.round(a.angle/(Math.PI/2))%(4);
          a.angle = dir*(Math.PI/2);
          a.locked = true;
        }else{
          // 한 번 더 누르면 잠금 해제
          a.locked = false;
        }
        break;
      }
    }

    // 모든 잠금 & 모두 같은 방향이면 성공
    const allLocked = this.grid.every(a=>a.locked);
    if(allLocked){
      const first = this.grid[0].angle;
      const allSame = this.grid.every(a=>Math.abs(a.angle-first)<0.01);
      if(allSame){
        this.isDone = true;
        setMessage("모든 시곗바늘이 같은 시간을 가리킵니다.");
      }else{
        setMessage("아직 각도가 제각각입니다.");
      }
    }
  }
}

/* =========================
   CHAPTER 5 – 2) 돌아가는 길
   (숨겨진 점프 조작)
   ========================= */
class PathGame extends MiniGame {
  constructor(){
    super("돌아가는 길", 5,
      "한 번 탭, 두 번 탭, 길게 눌러 서로 다른 점프를 찾아보세요."
    );
    this.rabbitX = 40;
    this.rabbitY = HEIGHT-40;
    this.vy = 0;
    this.platforms = [];
    this.goal = {x: WIDTH-40, y: HEIGHT-80};
    this.grounded = false;
    this.lastTapTime = 0;
    this.holdStart = null;
  }
  init(){
    super.init();
    this.rabbitX = 40;
    this.rabbitY = HEIGHT-40;
    this.vy = 0;
    this.platforms = [
      {x:60,y:HEIGHT-40,w:80},
      {x:160,y:HEIGHT-80,w:80},
      {x:240,y:HEIGHT-120,w:80},
    ];
    this.grounded = true;
    this.lastTapTime = 0;
    this.holdStart = null;
  }
  update(dt){
    super.update(dt);
    // 간단 중력
    this.vy += 200*dt;
    this.rabbitY += this.vy*dt;

    // 플랫폼 충돌
    this.grounded = false;
    for(const p of this.platforms){
      if(this.rabbitX>p.x && this.rabbitX<p.x+p.w){
        if(this.rabbitY>=p.y-8 && this.rabbitY<=p.y+4 && this.vy>0){
          this.rabbitY = p.y-8;
          this.vy = 0;
          this.grounded = true;
        }
      }
    }
    // 바닥
    if(this.rabbitY>HEIGHT-16){
      this.rabbitY = HEIGHT-16;
      this.vy = 0;
      this.grounded = true;
    }

    // 목표 도달
    const dx = this.rabbitX - this.goal.x;
    const dy = this.rabbitY - this.goal.y;
    if(Math.sqrt(dx*dx+dy*dy)<12){
      this.isDone = true;
      setMessage("토끼가 구멍 속으로 사라집니다.");
    }
  }
  draw(ctx){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,WIDTH,HEIGHT);

    // 플랫폼
    ctx.fillStyle = "#555";
    for(const p of this.platforms){
      ctx.fillRect(p.x, p.y, p.w, 4);
    }

    // 목표 구멍
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(this.goal.x,this.goal.y+4,10,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "#777";
    ctx.stroke();

    // 토끼
    drawRedRabbit(this.rabbitX-4, this.rabbitY-8);

    ctx.fillStyle = "#ccc";
    ctx.font = "6px 'Press Start 2P'";
    ctx.textAlign = "center";
    ctx.fillText("TAP / DOUBLE TAP / HOLD", WIDTH/2, 16);
  }
  pointerDown(x,y){
    const now = performance.now();
    // 더블탭 판정
    if(now - this.lastTapTime < 250){
      // 큰 점프
      if(this.grounded){
        this.vy = -220;
        setMessage("두 번 점프! 더 멀리 날아갑니다.");
      }
    }else{
      // 길게 누르기 시작인지 기록
      this.holdStart = now;
      // 작은 점프
      if(this.grounded){
        this.vy = -150;
        setMessage("작은 점프.");
      }
    }
    this.lastTapTime = now;
  }
  pointerUp(){
    if(this.holdStart){
      const dur = performance.now()-this.holdStart;
      if(dur>400 && this.grounded){
        this.vy = -280;
        setMessage("길게 눌러 높은 점프!");
      }
      this.holdStart = null;
    }
  }
}

/* =========================
   챕터/미니게임 등록
   ========================= */

// 각 챕터에 들어갈 미니게임 배열
// 0: intro
const GAMES = [
  [ new IntroGame() ],
  [ new WaveGame(), new FadingPixelGame() ],
  [ new OverlapGame() ],
  [ new FallingPixelsGame(), new BlinkPixelsGame() ],
  [ new StackGame(), new LinkPixelsGame() ],
  [ new ClockArrowsGame(), new PathGame() ],
];

function loadCurrentGame(){
  const c = STATE.chapterIndex;
  const m = STATE.miniIndex;
  STATE.currentGame = GAMES[c][m];
  STATE.currentGame.init();

  if(c === 0){
    setChapterLabel("INTRO");
  }else{
    setChapterLabel(`CH${c}-${m+1}`);
  }

  // 버튼 상태
  btnPrev.disabled = (c===0 && m===0);
  btnNext.disabled = false;
}

function nextMiniOrChapter(){
  const c = STATE.chapterIndex;
  const m = STATE.miniIndex;
  const games = GAMES[c];
  if(m < games.length-1){
    STATE.miniIndex++;
  }else{
    // 다음 챕터
    if(c < GAMES.length-1){
      STATE.chapterIndex++;
      STATE.miniIndex = 0;
    }
  }
  loadCurrentGame();
}

function prevMiniOrChapter(){
  const c = STATE.chapterIndex;
  const m = STATE.miniIndex;
  if(c===0 && m===0) return;

  if(m>0){
    STATE.miniIndex--;
  }else{
    if(c>0){
      STATE.chapterIndex--;
      const games = GAMES[STATE.chapterIndex];
      STATE.miniIndex = games.length-1;
    }
  }
  loadCurrentGame();
}

function nextChapter(){
  if(STATE.chapterIndex < GAMES.length-1){
    STATE.chapterIndex++;
    STATE.miniIndex = 0;
    loadCurrentGame();
  }
}

/* =========================
   입력 처리
   ========================= */
canvas.addEventListener('mousedown', (e)=>{
  const pos = getCanvasPos(e);
  STATE.pointer = {x:pos.x,y:pos.y,down:true};
  STATE.currentGame?.pointerDown(pos.x,pos.y);
});
canvas.addEventListener('mouseup', ()=>{
  STATE.pointer.down = false;
  if(STATE.currentGame?.pointerUp){
    STATE.currentGame.pointerUp();
  }
});
canvas.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  const pos = getCanvasPos(e);
  STATE.pointer = {x:pos.x,y:pos.y,down:true};
  STATE.currentGame?.pointerDown(pos.x,pos.y);
},{passive:false});
canvas.addEventListener('touchend', (e)=>{
  e.preventDefault();
  STATE.pointer.down = false;
  if(STATE.currentGame?.pointerUp){
    STATE.currentGame.pointerUp();
  }
},{passive:false});

btnNext.addEventListener('click', ()=>{
  nextMiniOrChapter();
});
btnPrev.addEventListener('click', ()=>{
  prevMiniOrChapter();
});

/* =========================
   메인 루프
   ========================= */
function loop(timestamp){
  const dt = (timestamp-lastTime)/1000;
  lastTime = timestamp;

  const g = STATE.currentGame;
  if(g){
    g.update(dt);
    g.draw(ctx);

    // 완료된 게임이면 NEXT 버튼 활성화 안내
    if(g.isDone){
      btnNext.disabled = false;
    }
  }

  requestAnimationFrame(loop);
}

/* =========================
   시작
   ========================= */
function start(){
  STATE.chapterIndex = 0;
  STATE.miniIndex = 0;
  loadCurrentGame();
  requestAnimationFrame(loop);
}

start();
</script>
</body>
</html>
