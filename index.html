<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>LIMEN WORKSHOP â€“ Monitorable Sound/Touch Reactive Field</title>
<style>
/* ==========================================================
   MAIN WINDOW STYLES
========================================================== */
  html,body{margin:0;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;}

  /* Hint / Entry */
  #hint{
    position:fixed; inset:0;
    display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.72);
    color:#ddd; font-family:system-ui, -apple-system, sans-serif;
    text-align:center; padding:20px;
    z-index:50;
  }
  #hint .box{
    width:min(720px, 94vw);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:18px 16px;
    background:rgba(0,0,0,.55);
    text-align:left;
  }

  /* Top-left / Top-right buttons */
  #topLeft{
    position:fixed; left:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  #topRight{
    position:fixed; right:12px; top:12px;
    display:flex; gap:8px;
    z-index:40;
  }
  .iconBtn{
    width:42px; height:42px;
    display:grid; place-items:center;
    background:rgba(0,0,0,.38);
    color:#eee;
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px;
    backdrop-filter: blur(10px);
    cursor:pointer;
    user-select:none;
    font-size:18px;
  }
  .iconBtn:hover{border-color:rgba(255,255,255,.30)}
  .iconBtn:active{transform:translateY(1px)}
  .iconBtn.danger{
    border-color:rgba(255,80,80,.55);
    color:#ffb9b9;
  }
  .iconBtn.danger:hover{border-color:rgba(255,120,120,.75)}

  /* Settings panel (Hidden in main window, visible in popup) */
  #ui{
    /* ë©”ì¸ ì°½ì—ì„œëŠ” ì™„ì „íˆ ìˆ¨ê¹€. íŒì—… ì°½ì—ì„œë§Œ ë³´ì´ë„ë¡ */
    display:none;
    position:fixed; right:12px; top:62px;
    width:min(560px, calc(100vw - 24px));
    color:#ddd;
    font-family:system-ui, -apple-system, sans-serif;
    background:rgba(0,0,0,.42);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    box-shadow:0 0 0 1px rgba(255,255,255,.06) inset;
    backdrop-filter: blur(10px);
    overflow:hidden;
    z-index:40;
    transform-origin: top right;
  }
  
  /* The rest of the styles are for the settings UI, used in the pop-up */
  #bar{
    display:flex; align-items:center; gap:8px;
    padding:10px 10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  #bar .title{font-weight:750; font-size:13px; color:#eee;}
  #bar .pill{
    margin-left:auto;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px; color:#bbb;
    padding:6px 8px;
    border:1px solid rgba(255,255,255,.12);
    border-radius:999px;
    background:rgba(0,0,0,.25);
    white-space:nowrap;
  }

  button, select, input[type="range"], input[type="number"]{
    background:#0f0f0f; color:#eee;
    border:1px solid rgba(255,255,255,.16);
    border-radius:10px;
    padding:8px 10px;
    font-weight:650;
    outline:none;
  }
  input[type="range"]{padding:6px 10px;}
  button:hover, select:hover{border-color:rgba(255,255,255,.32)}
  button:disabled, select:disabled{opacity:.5; cursor:not-allowed}

  #tabs{
    display:flex; gap:6px; padding:10px;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .tab{
    flex:1;
    padding:8px 10px;
    font-size:12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.22);
    cursor:pointer;
    text-align:center;
    user-select:none;
  }
  .tab.active{
    border-color:rgba(255,255,255,.34);
    background:rgba(255,255,255,.06);
  }
  #panels{padding:10px;}
  .panel{display:none;}
  .panel.active{display:block;}

  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:8px 0;}
  .label{font-size:12px; color:#aaa; width:132px;}
  .grow{flex:1; min-width:200px;}

  .meter{
    height:10px; border-radius:999px;
    background:rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .meter > i{
    display:block; height:100%;
    width:0%;
    background:rgba(255,255,255,.85);
  }

  .small{font-size:11px; color:#9aa; line-height:1.45;}
  .mono{
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    color:#bbb;
    white-space:pre-wrap;
    word-break:break-word;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:10px;
    padding:8px;
    max-height:190px;
    overflow:auto;
  }

  .fileLine{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
  .fileLine input[type="file"]{
    padding:6px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.22);
    color:#ddd;
  }

  .two{
    display:flex; gap:10px; flex-wrap:wrap;
  }
  .two > .box{
    flex:1; min-width:240px;
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px;
    background:rgba(0,0,0,.20);
  }

  .pillBtn{
    border-radius:999px;
    padding:6px 10px;
    font-size:12px;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(255,255,255,.06);
    cursor:pointer;
  }
  .pillBtn.on{
    border-color:rgba(255,255,255,.34);
    background:rgba(255,255,255,.10);
  }

  /* tiny HUD for touch */
  #touchHUD{
    position:fixed; left:12px; bottom:12px;
    z-index:39;
    color:#ddd;
    font-family:ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size:11px;
    background:rgba(0,0,0,.28);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:8px 10px;
    backdrop-filter: blur(10px);
    pointer-events:none;
  }
  #touchHUD .bar{height:8px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;border:1px solid rgba(255,255,255,.10);margin-top:6px;}
  #touchHUD .bar i{display:block;height:100%;width:0%;background:rgba(255,80,80,.90);}

  /* Entry header */
  .entryTitle{font-weight:900; font-size:16px; margin-bottom:10px;}
  .entryGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  @media (min-width:720px){
    .entryGrid{grid-template-columns: 1fr 1fr;}
  }
  .entryCard{
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px;
    background:rgba(0,0,0,.20);
  }
</style>
</head>
<body>

<div id="hint">
  <div class="box">
    <div class="entryTitle">LIMEN WORKSHOP â€“ Entry</div>
    <div class="small" style="margin-bottom:12px;">
      1) **Start Audio (Unlock Only)** ë²„íŠ¼ì„ **ê°€ì¥ ë¨¼ì €** ëˆ„ë¥´ê±°ë‚˜, **í™”ë©´ ì•„ë¬´ ê³³ì´ë‚˜ í´ë¦­**í•˜ì—¬ ì˜¤ë””ì˜¤ ì ê¸ˆ í•´ì œ<br/>
      2) ì˜¤ë””ì˜¤ê°€ ì¤€ë¹„ë˜ë©´ <b>Mic ON</b> ë˜ëŠ” <b>File Play</b> ë²„íŠ¼ìœ¼ë¡œ ì…ì¥í•©ë‹ˆë‹¤.<br/>
      3) <b>âš™ï¸ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì„¤ì • ì°½ì´ ìƒˆ íŒì—… ì°½ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤.</b>
    </div>

    <div class="row" style="justify-content:space-between;">
      <div class="row" style="margin:0;">
        <button id="btnStartAudio">Start Audio (Unlock Only)</button>
        <button id="btnFS">Fullscreen</button>
      </div>
      <div class="small" id="startStatus" style="opacity:.9; margin-left:10px;">Audio Context Locked.</div>
    </div>

    <div class="entryGrid">
      <div class="entryCard">
        <div class="row" style="margin-top:0;">
          <div class="label">Input</div>
          <select id="entrySelSrc" class="grow">
            <option value="mic" selected>Mic (Live input)</option>
            <option value="file">File (MP3/WAV)</option>
          </select>
        </div>

        <div id="entryMicBox">
          <div class="row">
            <div class="label">Mic device</div>
            <select id="entrySelMic" class="grow" disabled>
              <option>Start Audio í›„ ëª©ë¡ ë¡œë“œ</option>
            </select>
          </div>
          <div class="row">
            <button id="entryMicOn" class="grow" disabled>Mic ON (Enter)</button>
            <button id="entryMicOff" class="grow" disabled>Mic OFF</button>
          </div>
          <div class="small">Mic ONì„ ëˆ„ë¥´ë©´ Entry í™”ë©´ì´ ë‹«íˆê³ (ì…ì¥) ë¹„ì£¼ì–¼ì´ ì‹œì‘ë©ë‹ˆë‹¤.</div>
        </div>

        <div id="entryFileBox" style="display:none;">
          <div class="row">
            <div class="label">Audio file</div>
            <div class="grow">
              <div class="fileLine">
                <input id="entryFileAudio" type="file" accept="audio/*">
              </div>
              <div class="small" id="entryFileTxt">íŒŒì¼ ì„ íƒ í›„ Playë¡œ ì…ì¥</div>
            </div>
          </div>
          <div class="row">
            <button id="entryFilePlay" class="grow" disabled>Play (Enter)</button>
            <button id="entryFilePause" class="grow" disabled>Pause</button>
            <button id="entryFileStop" class="grow" disabled>Stop</button>
          </div>
        </div>
      </div>

      <div class="entryCard">
        <div class="small" style="margin-bottom:8px;">
          âœ… ë ‰(í”„ë¦¬ì¦ˆ/ê³¼ë¶€í•˜) ê°ì§€ ì‹œ <b>ìë™ìœ¼ë¡œ ì´ Entry í™”ë©´ìœ¼ë¡œ ë˜ëŒì•„ì˜µë‹ˆë‹¤</b>.<br/>
          (í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ì´ ì•„ë‹ˆë¼ â€œì…ì¥ ë‹¨ê³„ë¡œ ë³µê·€â€)
        </div>
        <div class="small" style="margin-bottom:8px;">
          âœ… ì„±ëŠ¥ ë¬¸ì œê°€ ìˆë‹¤ë©´ âš™ï¸ ì„¤ì • íŒì—…ì—ì„œ **Perf limit**ì™€ **Line density**ë¥¼ ë‚®ì¶°ì£¼ì„¸ìš”.
        </div>
        <div class="small">
          âœ… í˜„ì¬ ì„ íƒëœ ì¥ì¹˜: <b id="currentMicDisplay">Default</b>
        </div>
      </div>
    </div>
  </div>
</div>

<canvas id="c"></canvas>

<div id="touchHUD">
  touch: <span id="hudTouch">0.000</span> | amp: <span id="hudAmp">0.000</span><br/>
  <span id="hudMidi">midi: -</span>
  <div class="bar"><i id="hudTouchBar"></i></div>
</div>

<div id="topLeft">
  <div class="iconBtn danger" id="btnReset" title="RESET (Back to Entry)">âŸ²</div>
</div>

<div id="topRight">
  <div class="iconBtn" id="btnGear" title="Settings (Open Pop-up)">âš™ï¸</div>
  <div class="iconBtn" id="btnMuteQuick" title="Mute">ğŸ”ˆ</div>
  <div class="iconBtn" id="btnFSQuick" title="Fullscreen">â›¶</div>
</div>

<div id="ui" class="hidden">
  <div id="bar">
    <div class="title">Settings</div>
    <button id="btnHideUI" title="Close">íŒì—… ë‹«ê¸°</button>
    <div class="pill" id="topPill">audio:off | src:off | q:1.00</div>
  </div>

  <div id="tabs">
    <div class="tab active" data-tab="visual">VISUAL</div>
    <div class="tab" data-tab="audio">AUDIO</div>
    <div class="tab" data-tab="midi">MIDI</div>
    <div class="tab" data-tab="system">SYSTEM</div>
  </div>

  <div id="panels">
    <div class="panel active" id="panel-visual">
      <div class="row">
        <div class="label">Mode</div>
        <select id="selMode" class="grow">
          <option value="calm">Calm (quiet 3D dots)</option>
          <option value="pulse" selected>Pulse (amp-driven)</option>
          <option value="burst">Burst (delta-driven)</option>
          <option value="piano">Piano (low chaos, high reaction)</option>
          <option value="melancholy">Melancholy (slow, subtle)</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Particles</div>
        <select id="selN" class="grow">
          <option value="160">160</option>
          <option value="220" selected>220</option>
          <option value="320">320</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Keep in screen</div>
        <select id="selBounds" class="grow">
          <option value="soft" selected>Soft boundary</option>
          <option value="bounce">Bounce</option>
          <option value="wrap">Wrap</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Quiet lines</div>
        <select id="selQuietLines" class="grow">
          <option value="0">Off</option>
          <option value="1" selected>Very subtle</option>
          <option value="2">On</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Point color</div>
        <select id="selPointColor" class="grow">
          <option value="red" selected>Red</option>
          <option value="white">White</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Idle Drama</div>
        <div class="grow">
          <input id="rngIdleDrama" type="range" min="0" max="1" step="0.01" value="0.20" style="width:100%;">
          <div class="small" id="txtIdleDrama">idle drama: 0.20 (ì²œì²œíˆ ì›€ì§ì´ëŠ” ì •ë„)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Visual Sens</div>
        <div class="grow">
          <input id="rngVisSens" type="range" min="0.6" max="2.6" step="0.01" value="1.55" style="width:100%;">
          <div class="small" id="txtVisSens">visual sens: 1.55Ã— (ë°˜ì‘ ë¯¼ê°ë„)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Line density</div>
        <div class="grow">
          <input id="rngLine" type="range" min="0.2" max="1.2" step="0.01" value="0.75" style="width:100%;">
          <div class="small" id="txtLine">line density: 0.75Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Perf limit</div>
        <div class="grow">
          <input id="rngPerf" type="range" min="0.25" max="1" step="0.01" value="0.72" style="width:100%;">
          <div class="small" id="txtPerf">perf limit: 0.72</div>
        </div>
      </div>

      <div class="row">
        <div class="label">BG fade</div>
        <div class="grow">
          <input id="rngFade" type="range" min="0.02" max="0.20" step="0.005" value="0.03" style="width:100%;">
          <div class="small" id="txtFade">fade: 0.030 (ë°°ê²½ì´ ì§€ì›Œì§€ëŠ” ì†ë„)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Point size</div>
        <div class="grow">
          <input id="rngPointSize" type="range" min="0.4" max="1.2" step="0.01" value="0.60" style="width:100%;">
          <div class="small" id="txtPointSize">point size: 0.60Ã—</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Glow</div>
        <div class="grow">
          <input id="rngGlow" type="range" min="0.10" max="1.0" step="0.01" value="0.45" style="width:100%;">
          <div class="small" id="txtGlow">glow: 0.45Ã—</div>
        </div>
      </div>

      <div class="small">
        âœ… ë ‰/ë©ˆì¶¤ ì˜¤ë©´ <b>Perf limitâ†“</b> â†’ <b>Line densityâ†“</b> â†’ <b>Particlesâ†“</b><br/>
        âœ… ì‹¬í•˜ê²Œ ë©ˆì¶”ë©´ ì‹œìŠ¤í…œì´ <b>ìë™ìœ¼ë¡œ Entry</b>ë¡œ ë³µê·€í•©ë‹ˆë‹¤.
      </div>
    </div>

    <div class="panel" id="panel-audio">
      <div class="row">
        <div class="label">Input level</div>
        <div class="grow"><div class="meter"><i id="meterIn"></i></div></div>
      </div>

      <div class="row">
        <div class="label">Media Gain</div>
        <div class="grow">
          <input id="rngMediaGain" type="range" min="0.2" max="3.0" step="0.01" value="1.00" style="width:100%;">
          <div class="small" id="txtMediaGain">media gain: 1.00Ã— (ì…ë ¥ ë³¼ë¥¨ ì¦í­)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Analysis Sens</div>
        <div class="grow">
          <input id="rngSens" type="range" min="1" max="12" step="0.1" value="7.0" style="width:100%;">
          <div class="small" id="txtSens">analysis sens: 7.0Ã— (ë¶„ì„ ë¯¼ê°ë„)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Gamma boost</div>
        <div class="grow">
          <input id="rngGamma" type="range" min="0.45" max="1.20" step="0.01" value="0.72" style="width:100%;">
          <div class="small" id="txtGamma">gamma: 0.72 (ì‘ì€ ì†Œë¦¬ ì¦í­)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Amp cap</div>
        <div class="grow">
          <input id="rngCap" type="range" min="0.10" max="0.70" step="0.01" value="0.42" style="width:100%;">
          <div class="small" id="txtCap">amp cap: 0.42 (ìµœëŒ€ ì§„í­ ì œí•œ)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">EQ Low</div>
        <div class="grow">
          <input id="rngEQLow" type="range" min="-20" max="20" step="0.5" value="0" style="width:100%;">
          <div class="small" id="txtEQLow">low: 0 dB (200Hz)</div>
        </div>
      </div>
      <div class="row">
        <div class="label">EQ Mid</div>
        <div class="grow">
          <input id="rngEQMid" type="range" min="-20" max="20" step="0.5" value="0" style="width:100%;">
          <div class="small" id="txtEQMid">mid: 0 dB (1kHz)</div>
        </div>
      </div>
      <div class="row">
        <div class="label">EQ High</div>
        <div class="grow">
          <input id="rngEQHigh" type="range" min="-20" max="20" step="0.5" value="0" style="width:100%;">
          <div class="small" id="txtEQHigh">high: 0 dB (4kHz)</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Amp / Î”</div>
        <div class="mono grow" id="txtAmp">amp: 0.0000 | dAmp: 0.0000</div>
      </div>
      <div class="row">
        <div class="label">FX (Touch)</div>
        <div class="mono grow" id="txtFx">drive: - | filter: - | ring: - | widen: -</div>
      </div>

      <div class="small">
        EQëŠ” <b>ë§ˆì´í¬/íŒŒì¼</b> ê³µí†µ ì ìš©. <b>TouchMe(MIDI)</b>ëŠ” FX/ë¹„ì£¼ì–¼ì„ ê°•í•˜ê²Œ í”ë“­ë‹ˆë‹¤.
      </div>
    </div>

    <div class="panel" id="panel-midi">
      <div class="row" style="justify-content:space-between;">
        <div class="small" id="txtMIDISupport" style="opacity:.95"></div>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button id="btnMIDIInit" class="pillBtn">Connect MIDI</button>
          <button id="btnMIDILearn" class="pillBtn">LEARN</button>
        </div>
      </div>

      <div class="two">
        <div class="box">
          <div class="row">
            <div class="label">MIDI Input</div>
            <select id="selMIDIIn" class="grow">
              <option value="">Loadingâ€¦</option>
            </select>
          </div>

          <div class="row">
            <div class="label">Map Source</div>
            <select id="selMIDIType" class="grow">
              <option value="cc" selected>Control Change (CC)</option>
              <option value="note">Note Velocity</option>
            </select>
          </div>

          <div class="row">
            <div class="label">CC / Note#</div>
            <input id="numMIDINum" class="grow" type="number" min="0" max="127" step="1" value="1" />
          </div>

          <div class="row">
            <div class="label">Channel</div>
            <select id="selMIDICh" class="grow">
              <option value="-1" selected>Any</option>
              <option value="0">1</option><option value="1">2</option><option value="2">3</option><option value="3">4</option>
              <option value="4">5</option><option value="5">6</option><option value="6">7</option><option value="7">8</option>
              <option value="8">9</option><option value="9">10</option><option value="10">11</option><option value="11">12</option>
              <option value="12">13</option><option value="13">14</option><option value="14">15</option><option value="15">16</option>
            </select>
          </div>

          <div class="row">
            <div class="label">Invert</div>
            <select id="selMIDIInvert" class="grow">
              <option value="0" selected>Normal</option>
              <option value="1">Invert (1-x)</option>
            </select>
          </div>

          <div class="row">
            <div class="label">Deadzone</div>
            <div class="grow">
              <input id="rngMIDIDead" type="range" min="0" max="0.25" step="0.005" value="0.02" style="width:100%;">
              <div class="small" id="txtMIDIDead">deadzone: 0.020</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Gain</div>
            <div class="grow">
              <input id="rngMIDIGain" type="range" min="0.3" max="3.0" step="0.01" value="1.60" style="width:100%;">
              <div class="small" id="txtMIDIGain">gain: 1.60Ã—</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Curve</div>
            <div class="grow">
              <input id="rngMIDICurve" type="range" min="0.4" max="2.8" step="0.01" value="0.85" style="width:100%;">
              <div class="small" id="txtMIDICurve">curve: 0.85 ( <1 = ë” ì˜ˆë¯¼ )</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Smoothing</div>
            <div class="grow">
              <input id="rngMIDISmooth" type="range" min="0.02" max="0.50" step="0.01" value="0.22" style="width:100%;">
              <div class="small" id="txtMIDISmooth">smooth: 0.22</div>
            </div>
          </div>

          <div class="row">
            <div class="label">Sim Touch</div>
            <div class="grow">
              <input id="rngSimTouch" type="range" min="0" max="1" step="0.001" value="0" style="width:100%;">
              <div class="small">ë¯¸ë””ê°€ ë§‰íŒ í™˜ê²½ì—ì„œ ì´ ìŠ¬ë¼ì´ë”ë¡œ FX/ë¹„ì£¼ì–¼ í…ŒìŠ¤íŠ¸</div>
            </div>
          </div>
        </div>

        <div class="box">
          <div class="row">
            <div class="label">Touch value</div>
            <div class="grow"><div class="meter"><i id="meterTouch"></i></div></div>
          </div>

          <div class="row">
            <div class="label">Mapped</div>
            <div class="mono grow" id="txtMIDIRaw">raw: -</div>
          </div>

          <div class="row">
            <div class="label">Last MIDI (raw)</div>
            <div class="mono grow" id="txtMIDILast">Waitingâ€¦</div>
          </div>

          <div class="row">
            <div class="label">MIDI log</div>
            <div class="mono grow" id="txtMIDI">Waitingâ€¦</div>
          </div>

          <div class="small">
            âœ… <b>LEARN</b> ëˆ„ë¥´ê³  TouchMe í•œë²ˆ í„°ì¹˜ â†’ ìë™ìœ¼ë¡œ CC/NOTE#, ì±„ë„ì´ ì„¤ì •ë©ë‹ˆë‹¤<br/>
            âœ… â€œLast MIDI(raw)â€ê°€ ê°±ì‹ ë˜ë©´ <b>ë¯¸ë””ëŠ” ë“¤ì–´ì˜¤ê³  ìˆëŠ” ê²ƒ</b>ì…ë‹ˆë‹¤
          </div>
        </div>
      </div>
    </div>

    <div class="panel" id="panel-system">
      <div class="row">
        <div class="label">Audio context</div>
        <button id="btnResume" class="grow">Resume / Unlock Audio</button>
      </div>

      <div class="row">
        <div class="label">Input source</div>
        <select id="selSrc" class="grow">
          <option value="mic" selected>Mic (Live input)</option>
          <option value="file">File (MP3/WAV)</option>
        </select>
      </div>

      <div class="row" id="rowMic">
        <div class="label">Mic input</div>
        <select id="selMic" class="grow" disabled>
          <option>ì¥ì¹˜ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦</option>
        </select>
      </div>

      <div class="row" id="rowFile" style="display:none;">
        <div class="label">Audio file</div>
        <div class="grow">
          <div class="fileLine">
            <input id="fileAudio" type="file" accept="audio/*">
            <button id="btnFilePlay" disabled>Play</button>
            <button id="btnFilePause" disabled>Pause</button>
            <button id="btnFileStop" disabled>Stop</button>
          </div>
          <div class="small" id="txtFile">íŒŒì¼ì„ ì„ íƒí•˜ë©´ ì…ë ¥ ì²´ì¸(preGainâ†’EQâ†’FXâ†’analyser)ìœ¼ë¡œ ë“¤ì–´ê°‘ë‹ˆë‹¤.</div>
        </div>
      </div>

      <div class="row">
        <div class="label">Speaker output</div>
        <select id="selSpk" class="grow" disabled>
          <option>ë¸Œë¼ìš°ì € ì§€ì› í™•ì¸ ì¤‘â€¦</option>
        </select>
      </div>

      <div class="row">
        <div class="label">Mic control</div>
        <button id="btnMicOn" class="grow" disabled>Mic ON</button>
        <button id="btnMicOff" class="grow" disabled>Mic OFF</button>
      </div>

      <div class="row">
        <div class="label">Auto Reboot</div>
        <select id="selAutoReboot" class="grow">
          <option value="1" selected>ON (lag/freeze â†’ ENTRY)</option>
          <option value="0">OFF</option>
        </select>
      </div>

      <div class="small" id="txtSupport"></div>
      <div class="small">
        âŸ² RESET / ìë™ ë³µê·€ëŠ” â€œì™„ì „ ì²˜ìŒ ì•ˆë‚´ í˜ì´ì§€â€ê°€ ì•„ë‹ˆë¼ <b>Entry(ì…ì¥ í™”ë©´)</b>ë¡œ ë³µê·€í•©ë‹ˆë‹¤.
      </div>
    </div>
  </div>
</div>

<script>
/* ==========================================================
    SETTINGS PERSISTENCE (localStorage) - GLOBAL/SHARED
========================================================== */
const STORE_KEY = "limen_workshop_settings_v3_entry";
function loadSettings(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
function saveSettings(obj){ localStorage.setItem(STORE_KEY, JSON.stringify(obj)); }
let S = loadSettings(); 

function applySelectValue(id, fallback){
  const el = document.getElementById(id);
  const v = (S[id] ?? fallback);
  if(el) el.value = v;
}
function hookSelectSave(id){
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('change', ()=>{ S[id] = el.value; saveSettings(S); });
}
function hookRangeSave(id, fallback){
  const el = document.getElementById(id);
  if(!el) return;
  el.value = (S[id] ?? fallback);
  el.addEventListener('input', ()=>{ S[id] = parseFloat(el.value); saveSettings(S); });
}
function hookNumberSave(id, fallback){
  const el = document.getElementById(id);
  if(!el) return;
  el.value = (S[id] ?? fallback);
  el.addEventListener('input', ()=>{ S[id] = parseInt(el.value,10); saveSettings(S); });
}

/* ==========================================================
    CANVAS / DPR - MAIN WINDOW ONLY
========================================================== */
const isMainWindow = (window.opener === null);
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let W=0,H=0,DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  W = innerWidth|0; H = innerHeight|0;
  canvas.width  = (W*DPR)|0;
  canvas.height = (H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
if(isMainWindow){
  addEventListener('resize', resize);
  resize();
}


/* ==========================================================
    AUDIO CORE + ANALYSER - MAIN WINDOW ONLY
========================================================== */
let audioCtx;
let analyser, timeData;

let micStream = null;
let inputNode = null;

let masterGain, isMuted=false;

// EQ nodes
let eqLow, eqMid, eqHigh;

// FX nodes
let preGain, driveWS, driveGain, filter, ringOsc, ringGain, ringMult, dL, dR, merger, comp;
let splitter;

let amp=0, ampSmooth=0, ampDelta=0, prevAmp=0;

// file source
let fileAudioEl = null;
let fileNode = null;
let currentSource = S.currentSource ?? "mic"; // "mic" | "file"

function makeWaveshaper(amount=20){
  const n=2048;
  const curve=new Float32Array(n);
  const k=amount;
  for(let i=0;i<n;i++){
    const x = (i*2/n)-1;
    curve[i] = (1+k)*x/(1+k*Math.abs(x));
  }
  return curve;
}

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();

  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 1024;
  timeData = new Uint8Array(analyser.fftSize);

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;

  preGain = audioCtx.createGain(); preGain.gain.value = 1.0;

  // EQ (ê³µìš©)
  eqLow = audioCtx.createBiquadFilter();
  eqLow.type = "lowshelf";
  eqLow.frequency.value = 200;
  eqLow.gain.value = 0;

  eqMid = audioCtx.createBiquadFilter();
  eqMid.type = "peaking";
  eqMid.frequency.value = 1000;
  eqMid.Q.value = 1.0;
  eqMid.gain.value = 0;

  eqHigh = audioCtx.createBiquadFilter();
  eqHigh.type = "highshelf";
  eqHigh.frequency.value = 4000;
  eqHigh.gain.value = 0;

  driveWS = audioCtx.createWaveShaper();
  driveWS.curve = makeWaveshaper(10);
  driveWS.oversample = '4x';
  driveGain = audioCtx.createGain(); driveGain.gain.value = 1.0;

  filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 900;
  filter.Q.value = 2.0;

  ringOsc = audioCtx.createOscillator();
  ringOsc.type = 'sine';
  ringOsc.frequency.value = 35;

  ringGain = audioCtx.createGain();
  ringGain.gain.value = 0.0;

  ringMult = audioCtx.createGain();
  ringMult.gain.value = 1.0;
  ringOsc.connect(ringGain);
  ringGain.connect(ringMult.gain);

  splitter = audioCtx.createChannelSplitter(2);

  dL = audioCtx.createDelay(0.05);
  dR = audioCtx.createDelay(0.05);
  dL.delayTime.value = 0.004;
  dR.delayTime.value = 0.011;

  merger = audioCtx.createChannelMerger(2);

  comp = audioCtx.createDynamicsCompressor();
  comp.threshold.value = -22;
  comp.knee.value = 28;
  comp.ratio.value = 7;
  comp.attack.value = 0.003;
  comp.release.value = 0.14;

  // chain: input â†’ preGain â†’ EQ â†’ drive â†’ filter â†’ ring â†’ widen â†’ comp â†’ analyser â†’ master
  preGain.connect(eqLow);
  eqLow.connect(eqMid);
  eqMid.connect(eqHigh);

  eqHigh.connect(driveWS);
  driveWS.connect(driveGain);
  driveGain.connect(filter);
  filter.connect(ringMult);

  ringMult.connect(splitter);
  splitter.connect(dL, 0);
  splitter.connect(dR, 1);
  dL.connect(merger, 0, 0);
  dR.connect(merger, 0, 1);

  merger.connect(comp);
  comp.connect(analyser);
  analyser.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  ringOsc.start();
  updateTopPill(1);
}
if(isMainWindow) window.ensureAudio = ensureAudio;

/* ==========================================================
    AUDIO UI + PARAMS - SHARED
========================================================== */
hookRangeSave('rngMediaGain', 1.00);
hookRangeSave('rngSens', 7.0);
hookRangeSave('rngGamma', 0.72);
hookRangeSave('rngCap', 0.42);

hookRangeSave('rngEQLow', 0);
hookRangeSave('rngEQMid', 0);
hookRangeSave('rngEQHigh', 0);

const rngMediaGain = document.getElementById('rngMediaGain');
const rngSens = document.getElementById('rngSens');
const rngGamma = document.getElementById('rngGamma');
const rngCap = document.getElementById('rngCap');

const rngEQLow = document.getElementById('rngEQLow');
const rngEQMid = document.getElementById('rngEQMid');
const rngEQHigh = document.getElementById('rngEQHigh');

const txtMediaGain = document.getElementById('txtMediaGain');
const txtSens = document.getElementById('txtSens');
const txtGamma = document.getElementById('txtGamma');
const txtCap = document.getElementById('txtCap');

const txtEQLow = document.getElementById('txtEQLow');
const txtEQMid = document.getElementById('txtEQMid');
const txtEQHigh = document.getElementById('txtEQHigh');

function getMediaGain(){ return Math.max(0.2, Math.min(3.0, parseFloat(rngMediaGain.value)||1)); }
function getSens(){ return Math.max(1, Math.min(12, parseFloat(rngSens.value)||7)); }
function getGamma(){ return Math.max(0.45, Math.min(1.20, parseFloat(rngGamma.value)||0.72)); }
function getCap(){ return Math.max(0.10, Math.min(0.70, parseFloat(rngCap.value)||0.42)); }

function getEQLow(){ return Math.max(-20, Math.min(20, parseFloat(rngEQLow.value)||0)); }
function getEQMid(){ return Math.max(-20, Math.min(20, parseFloat(rngEQMid.value)||0)); }
function getEQHigh(){ return Math.max(-20, Math.min(20, parseFloat(rngEQHigh.value)||0)); }

function refreshAudioLabels(){
  if(!txtMediaGain) return; 
  txtMediaGain.textContent = `media gain: ${getMediaGain().toFixed(2)}Ã—`;
  txtSens.textContent      = `analysis sens: ${getSens().toFixed(1)}Ã—`;
  txtGamma.textContent     = `gamma: ${getGamma().toFixed(2)}`;
  txtCap.textContent       = `amp cap: ${getCap().toFixed(2)}`;

  txtEQLow.textContent  = `low: ${getEQLow().toFixed(1)} dB (200Hz)`;
  txtEQMid.textContent  = `mid: ${getEQMid().toFixed(1)} dB (1kHz)`;
  txtEQHigh.textContent = `high: ${getEQHigh().toFixed(1)} dB (4kHz)`;
}
['input','change'].forEach(ev=>{
  [rngMediaGain,rngSens,rngGamma,rngCap,rngEQLow,rngEQMid,rngEQHigh].forEach(el=>{
    if(el) el.addEventListener(ev, refreshAudioLabels);
  });
});
refreshAudioLabels();

function applyEQ(){
  // Use parent window's audio context if in popup
  const targetCtx = isMainWindow ? audioCtx : (window.opener ? window.opener.audioCtx : null);
  const targetEqLow = isMainWindow ? eqLow : (window.opener ? window.opener.eqLow : null);
  const targetEqMid = isMainWindow ? eqMid : (window.opener ? window.opener.eqMid : null);
  const targetEqHigh = isMainWindow ? eqHigh : (window.opener ? window.opener.eqHigh : null);

  if(!targetCtx || !targetEqLow) return;

  targetEqLow.gain.setTargetAtTime(getEQLow(), targetCtx.currentTime, 0.02);
  targetEqMid.gain.setTargetAtTime(getEQMid(), targetCtx.currentTime, 0.02);
  targetEqHigh.gain.setTargetAtTime(getEQHigh(), targetCtx.currentTime, 0.02);
}

function updateAmp(){
  if(!analyser) return;

  analyser.getByteTimeDomainData(timeData);
  let sum=0;
  for(let i=0;i<timeData.length;i++){
    const v=(timeData[i]-128)/128;
    sum+=v*v;
  }
  const rms=Math.sqrt(sum/timeData.length);

  const rmsG = rms * getMediaGain();
  ampSmooth += (rmsG-ampSmooth)*0.12;

  const boosted = Math.pow(Math.max(0, ampSmooth * getSens()), getGamma());
  const scaled = Math.min(getCap(), boosted);

  amp = scaled;
  ampDelta = Math.abs(amp - prevAmp);
  prevAmp = amp;
}

if(isMainWindow){
  // In the main window, hook the EQ ranges to apply the EQ change immediately
  ['input', 'change'].forEach(ev => {
    [rngEQLow, rngEQMid, rngEQHigh].forEach(el => {
      if(el) el.addEventListener(ev, applyEQ);
    });
  });
}
window.applyEQ = applyEQ; 

/* ==========================================================
    OUTPUT ROUTING (optional) - MAIN WINDOW ONLY
========================================================== */
const selMic = document.getElementById('selMic');
const selSpk = document.getElementById('selSpk');
const txtSupport = document.getElementById('txtSupport');
const currentMicDisplay = document.getElementById('currentMicDisplay');

let currentMicDeviceId = S.currentMicDeviceId ?? "default";
let outputSupported = false;

const monitorAudio = new Audio();
monitorAudio.autoplay = true;
monitorAudio.playsInline = true;
let monitorDest = null;

function setupOutputRouting(){
  if(!audioCtx) return;
  if(monitorDest) return;
  monitorDest = audioCtx.createMediaStreamDestination();
  masterGain.connect(monitorDest);
  monitorAudio.srcObject = monitorDest.stream;
}

async function listDevices(){
  let devices = [];
  try{ 
      // Only request permission if AudioContext is ready and mic is the source
      if (audioCtx && audioCtx.state === 'running' && currentSource === "mic") {
          await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      }
      devices = await navigator.mediaDevices.enumerateDevices(); 
  }catch(e){
      // console.warn("Could not enumerate devices or get mic permission initially:", e);
  }

  const mics = devices.filter(d=>d.kind==="audioinput");
  const spks = devices.filter(d=>d.kind==="audiooutput");

  // SYSTEM mic select
  let selectedMicLabel = "Default";
  if(selMic) {
      selMic.innerHTML = "";
      if(mics.length===0){
        selMic.disabled = true;
        selMic.innerHTML = `<option>ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ</option>`;
      }else{
        selMic.disabled = false;
        for(const d of mics){
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          const label = d.label || `Mic (${d.deviceId.slice(0,6)}â€¦)`;
          opt.textContent = label;
          if(d.deviceId === currentMicDeviceId) {
              opt.selected = true;
              selectedMicLabel = label;
          }
          selMic.appendChild(opt);
        }
      }
  }


  // ENTRY mic select (mirror)
  const entrySelMic = document.getElementById('entrySelMic');
  if(entrySelMic) {
      entrySelMic.innerHTML = "";
      if(mics.length===0){
        entrySelMic.disabled = true;
        entrySelMic.innerHTML = `<option>ë§ˆì´í¬ ì¥ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ</option>`;
      }else{
        entrySelMic.disabled = false;
        for(const d of mics){
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          opt.textContent = d.label || `Mic (${d.deviceId.slice(0,6)}â€¦)`;
          if(d.deviceId === currentMicDeviceId) opt.selected = true;
          entrySelMic.appendChild(opt);
        }
      }
  }
  if(currentMicDisplay) currentMicDisplay.textContent = selectedMicLabel;

  outputSupported = typeof monitorAudio.setSinkId === "function";
  if(selSpk) {
      selSpk.innerHTML = "";
      if(!outputSupported){
        selSpk.disabled = true;
        selSpk.innerHTML = `<option>ë¸Œë¼ìš°ì €ê°€ ì¶œë ¥ ì„ íƒì„ ì§€ì›í•˜ì§€ ì•ŠìŒ</option>`;
      }else{
        selSpk.disabled = false;
        if(spks.length===0){
          selSpk.innerHTML = `<option value="default">default</option>`;
        }else{
          for(const d of spks){
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.textContent = d.label || `Speaker (${d.deviceId.slice(0,6)}â€¦)`;
            if(S.currentSpkDeviceId && d.deviceId===S.currentSpkDeviceId) opt.selected = true;
            selSpk.appendChild(opt);
          }
        }
      }
  }

  if(txtSupport) txtSupport.textContent =
    `ì§€ì› ìƒíƒœ: mic=${mics.length} | spk=${spks.length} | outputSelect=${outputSupported ? 'YES' : 'NO'}\n`+
    `ë ‰/í”„ë¦¬ì¦ˆ ê°ì§€ ì‹œ ìë™ìœ¼ë¡œ Entryë¡œ ë³µê·€ (SYSTEM > Auto Reboot)`;

  if(outputSupported && S.currentSpkDeviceId){
    try{
      setupOutputRouting();
      await monitorAudio.setSinkId(S.currentSpkDeviceId);
    }catch(e){}
  }
}
if(isMainWindow) window.listDevices = listDevices;

if(isMainWindow){
  if(selMic) selMic.addEventListener('change', async ()=>{
    currentMicDeviceId = selMic.value;
    S.currentMicDeviceId = currentMicDeviceId;
    saveSettings(S);
    const entrySelMic = document.getElementById('entrySelMic');
    if(entrySelMic) entrySelMic.value = currentMicDeviceId;

    if(currentSource==="mic" && micStream) await startMic(currentMicDeviceId, false);
  });
  if(document.getElementById('entrySelMic')) document.getElementById('entrySelMic').addEventListener('change', async (e)=>{
    currentMicDeviceId = e.target.value;
    S.currentMicDeviceId = currentMicDeviceId;
    saveSettings(S);
    if(selMic) selMic.value = currentMicDeviceId;
    if(currentSource==="mic" && micStream) await startMic(currentMicDeviceId, false);
  });

  if(selSpk) selSpk.addEventListener('change', async ()=>{
    if(!outputSupported) return;
    S.currentSpkDeviceId = selSpk.value;
    saveSettings(S);
    try{
      setupOutputRouting();
      await monitorAudio.setSinkId(selSpk.value);
    }catch(e){
      console.warn(e);
      alert("ì´ í™˜ê²½ì—ì„œëŠ” ìŠ¤í”¼ì»¤ ì¶œë ¥ ì„ íƒì´ ì‹¤íŒ¨í–ˆì–´ìš”.");
    }
  });
}

/* ==========================================================
    INPUT SOURCE: MIC / FILE - MAIN WINDOW ONLY
========================================================== */
function disconnectInputs(){
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }
}
if(isMainWindow) window.disconnectInputs = disconnectInputs;

async function startMic(deviceId="default", hideEntry=true){
  if(!audioCtx || audioCtx.state !== 'running') {
      startStatus("Audio Contextê°€ ì ê¸ˆ í•´ì œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. Start Audioë¥¼ ë¨¼ì € ëˆŒëŸ¬ì£¼ì„¸ìš”.");
      return;
  }
  
  await audioCtx.resume();
  setupOutputRouting();

  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }

  try{
    startStatus("ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ë° ì—°ê²° ì¤‘...");
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: deviceId ? { exact: deviceId } : undefined,
        echoCancellation:false,
        noiseSuppression:false,
        autoGainControl:false
      }
    });

    const src = audioCtx.createMediaStreamSource(micStream);
    inputNode = src;
    src.connect(preGain);

    await listDevices();
    setMicButtons(true);
    updateTopPill(1);
    startStatus("Mic ON ì„±ê³µ. ë¹„ì£¼ì–¼ ì‹œì‘.");

    if(hideEntry) hideEntryAndEnter();
  }catch(e){
    console.error(e);
    startStatus("Mic ON ì‹¤íŒ¨. ê¶Œí•œ/ì¥ì¹˜ ì„ íƒ í™•ì¸.");
    alert("ë§ˆì´í¬ ê¶Œí•œ ë˜ëŠ” ì¥ì¹˜ ì„ íƒì— ì‹¤íŒ¨í–ˆì–´ìš”. í¬ë¡¬ ê¶Œí•œ í™•ì¸!");
    setMicButtons(false);
  }
}
if(isMainWindow) window.startMic = startMic;

function stopMic(){
  if(micStream){
    micStream.getTracks().forEach(t=>t.stop());
    micStream = null;
  }
  if(inputNode){
    try{ inputNode.disconnect(); }catch(e){}
    inputNode = null;
  }
  setMicButtons(false);
  updateTopPill(1);
}
if(isMainWindow) window.stopMic = stopMic;

function ensureFileAudioEl(){
  if(fileAudioEl) return;
  fileAudioEl = new Audio();
  fileAudioEl.crossOrigin = "anonymous";
  fileAudioEl.loop = true;
  fileAudioEl.preload = "auto";
  fileAudioEl.playsInline = true;
}
if(isMainWindow) window.ensureFileAudioEl = ensureFileAudioEl;

function connectFileToChain(){
  ensureAudio();
  ensureFileAudioEl();
  if(!fileAudioEl.src) return;

  if(micStream){ micStream.getTracks().forEach(t=>t.stop()); micStream = null; }
  if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode = null; }
  if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode = null; }

  try{
    fileNode = audioCtx.createMediaElementSource(fileAudioEl);
    fileNode.connect(preGain);
  }catch(e){
    try{
      const oldSrc = fileAudioEl.src;
      fileAudioEl.pause();
      fileAudioEl.srcObject = null;
      fileAudioEl = null;
      ensureFileAudioEl();
      fileAudioEl.src = oldSrc;
      fileNode = audioCtx.createMediaElementSource(fileAudioEl);
      fileNode.connect(preGain);
    }catch(err){
      console.error(err);
      alert("íŒŒì¼ ì†ŒìŠ¤ë¥¼ ì˜¤ë””ì˜¤ ì²´ì¸ì— ì—°ê²°í•˜ëŠ”ë° ì‹¤íŒ¨í–ˆì–´ìš”.");
    }
  }
  setMicButtons(false);
  updateTopPill(1);
}
if(isMainWindow) window.connectFileToChain = connectFileToChain;

/* ENTRY <-> SYSTEM ë²„íŠ¼ ìƒíƒœë¥¼ ë™ì‹œì— ê´€ë¦¬ */
function setMicButtons(micOn){
  const audioUnlocked = !!audioCtx && audioCtx.state === 'running';

  // System UI
  const btnMicOn = document.getElementById('btnMicOn');
  const btnMicOff = document.getElementById('btnMicOff');
  if(btnMicOn) btnMicOn.disabled  = !audioUnlocked || micOn || (currentSource!=="mic");
  if(btnMicOff) btnMicOff.disabled = !micOn;

  // Entry UI
  const btnStartAudio = document.getElementById('btnStartAudio');
  if(btnStartAudio) btnStartAudio.disabled = audioUnlocked; // Always enable if audio isn't running

  const entryMicOn = document.getElementById('entryMicOn');
  const entryMicOff = document.getElementById('entryMicOff');
  if(entryMicOn) entryMicOn.disabled  = !audioUnlocked || micOn || (currentSource!=="mic");
  if(entryMicOff) entryMicOff.disabled = !micOn;
  
  // File buttons in Entry
  const fileLoaded = (currentSource === "file" && fileAudioEl && fileAudioEl.src);
  const filePlaying = fileLoaded && !fileAudioEl.paused;
  
  const entryFilePlay = document.getElementById('entryFilePlay');
  const entryFilePause = document.getElementById('entryFilePause');
  const entryFileStop = document.getElementById('entryFileStop');
  
  if(entryFilePlay) entryFilePlay.disabled = !audioUnlocked || !fileLoaded || filePlaying || (currentSource!=="file");
  if(entryFilePause) entryFilePause.disabled = !audioUnlocked || !filePlaying;
  if(entryFileStop) entryFileStop.disabled = !audioUnlocked || !fileLoaded;
}
if(isMainWindow) window.setMicButtons = setMicButtons;

function startStatus(msg){
  const el = document.getElementById('startStatus');
  if(el) el.textContent = msg;
}
if(isMainWindow) window.startStatus = startStatus;

/* ==========================================================
    OUTPUT ROUTING SETUP + DEVICE LIST ONCE AUDIO UNLOCKED - MAIN WINDOW ONLY
========================================================== */
async function afterAudioUnlocked(){
  await listDevices();
  setMicButtons(!!micStream);
  updateTopPill(1);
}
if(isMainWindow) window.afterAudioUnlocked = afterAudioUnlocked;

/* ==========================================================
    MIDI (TouchMe) - SHARED (but MIDI access only in main window)
========================================================== */
let midiAccess = null;
let midiInput = null;

let touchRaw = 0;
let touch = 0;
let touchSmooth = 0;
let lastMidiAt = 0;
let lastMidiRawText = "Waitingâ€¦";

let midiName="MIDI: ?";
let midiLog = [];
let midiLearn = false;

function pushMidiLog(line){
  const txtMIDI = document.getElementById('txtMIDI');
  if(!txtMIDI) return;
  midiLog.push(line);
  if(midiLog.length>18) midiLog.shift();
  txtMIDI.textContent = `${midiName}\n` + midiLog.join('\n');
}

const selMIDIIn = document.getElementById('selMIDIIn');
const selMIDIType = document.getElementById('selMIDIType');
const numMIDINum = document.getElementById('numMIDINum');
const selMIDICh = document.getElementById('selMIDICh');
const selMIDIInvert = document.getElementById('selMIDIInvert');

if(isMainWindow){
    hookSelectSave('selMIDIType');
    hookNumberSave('numMIDINum', 1);
    hookSelectSave('selMIDICh');
    hookSelectSave('selMIDIInvert');
    hookRangeSave('rngMIDIDead', 0.02);
    hookRangeSave('rngMIDIGain', 1.60);
    hookRangeSave('rngMIDICurve', 0.85);
    hookRangeSave('rngMIDISmooth', 0.22);
}

const rngMIDIDead = document.getElementById('rngMIDIDead');
const rngMIDIGain = document.getElementById('rngMIDIGain');
const rngMIDICurve = document.getElementById('rngMIDICurve');
const rngMIDISmooth = document.getElementById('rngMIDISmooth');
const txtMIDIDead = document.getElementById('txtMIDIDead');
const txtMIDIGain = document.getElementById('txtMIDIGain');
const txtMIDICurve = document.getElementById('txtMIDICurve');
const txtMIDISmooth = document.getElementById('txtMIDISmooth');
const txtMIDIRaw = document.getElementById('txtMIDIRaw');
const txtMIDILast = document.getElementById('txtMIDILast');
const txtMIDISupport = document.getElementById('txtMIDISupport');
const rngSimTouch = document.getElementById('rngSimTouch');

function refreshMIDILabels(){
  if(!txtMIDIDead) return;
  txtMIDIDead.textContent = `deadzone: ${parseFloat(rngMIDIDead.value).toFixed(3)}`;
  txtMIDIGain.textContent = `gain: ${parseFloat(rngMIDIGain.value).toFixed(2)}Ã—`;
  txtMIDICurve.textContent = `curve: ${parseFloat(rngMIDICurve.value).toFixed(2)} ( <1 = ë” ì˜ˆë¯¼ )`;
  txtMIDISmooth.textContent = `smooth: ${parseFloat(rngMIDISmooth.value).toFixed(2)}`;
}
['input','change'].forEach(ev=>{
  [rngMIDIDead,rngMIDIGain,rngMIDICurve,rngMIDISmooth].forEach(el=>{
      if(el) el.addEventListener(ev, refreshMIDILabels);
  });
});
refreshMIDILabels();

function getMIDIDead(){ return Math.max(0, Math.min(0.25, parseFloat(rngMIDIDead.value)||0)); }
function getMIDIGain(){ return Math.max(0.3, Math.min(3.0, parseFloat(rngMIDIGain.value)||1)); }
function getMIDICurve(){ return Math.max(0.4, Math.min(2.8, parseFloat(rngMIDICurve.value)||1)); }
function getMIDISmooth(){ return Math.max(0.02, Math.min(0.50, parseFloat(rngMIDISmooth.value)||0.18)); }

function shapeMIDI(x){
  if(!selMIDIInvert) return 0; // Safety check
  const inv = (selMIDIInvert.value==="1");
  if(inv) x = 1-x;

  const dead = getMIDIDead();
  if(x < dead) x = 0;
  else x = (x-dead) / (1-dead);

  x *= getMIDIGain();
  x = Math.max(0, Math.min(1, x));

  const curve = getMIDICurve();
  x = Math.pow(x, curve);
  return Math.max(0, Math.min(1, x));
}

function updateTouch(){
  const k = getMIDISmooth();
  touchSmooth += (touch - touchSmooth) * k;

  const now = performance.now();
  const idleMs = now - lastMidiAt;
  if(idleMs > 250 && !midiLearn){
    touch *= 0.985;
  }
}
if(isMainWindow) window.updateTouch = updateTouch;

function midiParseRaw(data){
  const st = data[0] & 0xF0;
  const ch = data[0] & 0x0F;
  const d1 = data[1] ?? 0;
  const d2 = data[2] ?? 0;

  let type = "other";
  if(st===0xB0) type="cc";
  else if(st===0x90) type="noteon";
  else if(st===0x80) type="noteoff";
  return {st, ch, d1, d2, type};
}

function midiMsgToValue(data){
  const st = data[0] & 0xF0;
  const ch = data[0] & 0x0F;
  const d1 = data[1] ?? 0;
  const d2 = data[2] ?? 0;

  if(!selMIDICh || !numMIDINum || !selMIDIType) return null; // Safety check for popup

  const wantCh = parseInt(selMIDICh.value,10);
  if(wantCh !== -1 && ch !== wantCh) return null;

  const mode = selMIDIType.value;
  const num = Math.max(0, Math.min(127, parseInt(numMIDINum.value,10)||0));

  if(mode==="cc"){
    if(st !== 0xB0) return null;
    if(d1 !== num) return null;
    return { raw01: d2/127, ch, type:"cc", num:d1, val:d2 };
  }else{
    if(st !== 0x90 && st !== 0x80) return null;
    if(d1 !== num) return null;
    const vel = (st===0x80) ? 0 : d2;
    return { raw01: vel/127, ch, type:"note", num:d1, val:vel };
  }
}

async function initMIDI(){
  if(!navigator.requestMIDIAccess){
    if(txtMIDISupport) txtMIDISupport.textContent = "âš ï¸ ì´ ë¸Œë¼ìš°ì €ëŠ” WebMIDIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. â†’ Sim Touchë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥";
    pushMidiLog("requestMIDIAccess ì—†ìŒ");
    return;
  }
  try{
    midiAccess = await navigator.requestMIDIAccess({sysex:false});
    midiAccess.onstatechange = ()=> rebuildMIDIInputs();
    rebuildMIDIInputs(true);
    if(txtMIDISupport) txtMIDISupport.textContent = "âœ… WebMIDI OK. TouchMe ì—°ê²° í›„ LEARN ëˆ„ë¥´ê³  í•œ ë²ˆ í„°ì¹˜í•˜ì„¸ìš”.";
    pushMidiLog("MIDI ready.");
  }catch(e){
    console.error(e);
    midiName="MIDI: blocked";
    if(txtMIDISupport) txtMIDISupport.textContent = "âš ï¸ MIDI ì ‘ê·¼ì´ ì°¨ë‹¨ë¨. Chrome ê¶Œí•œ/ë³´ì•ˆ(https) í™•ì¸.";
    pushMidiLog("MIDI access failed");
  }
}
if(isMainWindow) window.initMIDI = initMIDI;

function rebuildMIDIInputs(autoselect=false){
  if(!midiAccess || !selMIDIIn) return; // Safety check
  
  const inputs = [...midiAccess.inputs.values()];
  selMIDIIn.innerHTML = "";
  if(inputs.length===0){
    selMIDIIn.innerHTML = `<option value="">No MIDI inputs</option>`;
    midiName="MIDI: no inputs";
    pushMidiLog("No MIDI devices. TouchMe USB/BT í™•ì¸.");
    return;
  }

  for(const inp of inputs){
    const opt = document.createElement('option');
    opt.value = inp.id;
    opt.textContent = inp.name || `MIDI (${inp.id.slice(0,6)}â€¦)`;
    selMIDIIn.appendChild(opt);
  }

  const savedId = S.midiInputId ?? "";
  const hasSaved = inputs.some(i=>i.id===savedId);

  if(hasSaved){
    selMIDIIn.value = savedId;
    attachMIDIInput(savedId);
  }else if(autoselect){
    selMIDIIn.value = inputs[0].id;
    attachMIDIInput(inputs[0].id);
  }
}

function setLearn(on){
  midiLearn = on;
  const b = document.getElementById('btnMIDILearn');
  if(!b) return;
  b.classList.toggle('on', on);
  b.textContent = on ? "LEARN (ON)" : "LEARN";
  if(on) pushMidiLog("LEARN: TouchMeë¥¼ í•œ ë²ˆ í„°ì¹˜í•˜ì„¸ìš” (CC/NOTE ìë™ ë§¤í•‘).");
}

function attachMIDIInput(id){
  if(!midiAccess || !selMIDIIn) return;
  const inp = [...midiAccess.inputs.values()].find(i=>i.id===id);
  if(!inp) return;

  if(midiInput) midiInput.onmidimessage = null;
  midiInput = inp;
  S.midiInputId = id;
  saveSettings(S);

  midiName = "MIDI: " + (midiInput.name || "input");
  pushMidiLog("Connected: " + midiName);

  midiInput.onmidimessage = (e)=>{
    const data = e.data;
    const r = midiParseRaw(data);
    lastMidiAt = performance.now();
    lastMidiRawText = `st:0x${r.st.toString(16)} | ch:${r.ch+1} | d1:${r.d1} | d2:${r.d2} | type:${r.type}`;
    if(txtMIDILast) txtMIDILast.textContent = lastMidiRawText;

    if(midiLearn){
      if(r.st===0xB0){
        selMIDIType.value = "cc";
        numMIDINum.value = r.d1;
        selMIDICh.value = String(r.ch);
        saveSettings(Object.assign(S, {
          selMIDIType:"cc",
          numMIDINum: r.d1,
          selMIDICh: String(r.ch)
        }));
        pushMidiLog(`LEARN OK: CC #${r.d1} ch:${r.ch+1}`);
        setLearn(false);
      }else if(r.st===0x90 || r.st===0x80){
        selMIDIType.value = "note";
        numMIDINum.value = r.d1;
        selMIDICh.value = String(r.ch);
        saveSettings(Object.assign(S, {
          selMIDIType:"note",
          numMIDINum: r.d1,
          selMIDICh: String(r.ch)
        }));
        pushMidiLog(`LEARN OK: NOTE #${r.d1} ch:${r.ch+1}`);
        setLearn(false);
      }
    }

    const parsed = midiMsgToValue(data);
    if(!parsed){
      if(Math.random() < 0.18) pushMidiLog(`raw=[${[...data].join(',')}] (not mapped)`);
      return;
    }

    touchRaw = parsed.raw01;
    touch = shapeMIDI(touchRaw);

    if(txtMIDIRaw) txtMIDIRaw.textContent =
      `raw01:${touchRaw.toFixed(3)} -> touch:${touch.toFixed(3)} | ${parsed.type.toUpperCase()} #${parsed.num} ch:${parsed.ch+1} val:${parsed.val}`;

    if(Math.random() < 0.22){
      pushMidiLog(`mapped ${parsed.type} #${parsed.num} ch:${parsed.ch+1} -> touch=${touch.toFixed(3)}`);
    }
  };
}
if(isMainWindow) window.attachMIDIInput = attachMIDIInput;

if(isMainWindow){
  if(selMIDIIn) selMIDIIn.addEventListener('change', ()=> attachMIDIInput(selMIDIIn.value));
  if(document.getElementById('btnMIDIInit')) document.getElementById('btnMIDIInit').addEventListener('click', initMIDI);
  if(document.getElementById('btnMIDILearn')) document.getElementById('btnMIDILearn').addEventListener('click', ()=> setLearn(!midiLearn));

  /* restore midi controls */
  applySelectValue('selMIDIType', 'cc');
  applySelectValue('selMIDICh', '-1');
  applySelectValue('selMIDIInvert', '0');
  hookSelectSave('selMIDIType');
  hookSelectSave('selMIDICh');
  hookSelectSave('selMIDIInvert');
  hookNumberSave('numMIDINum', 1);

  if(rngSimTouch){
    rngSimTouch.value = (S.rngSimTouch ?? 0);
    rngSimTouch.addEventListener('input', ()=>{
      S.rngSimTouch = parseFloat(rngSimTouch.value);
      saveSettings(S);
    });
  }
}

/* ==========================================================
    FX MAPPING (Touch) - MAIN WINDOW ONLY
========================================================== */
function applyFX(){
  if(!audioCtx) return;

  const sim = Math.max(0, Math.min(1, parseFloat(rngSimTouch.value)||0));
  const t = Math.max(touchSmooth, sim);

  const driveAmt = 10 + t*95;
  driveWS.curve = makeWaveshaper(driveAmt);

  preGain.gain.setTargetAtTime(0.85 + t*1.25, audioCtx.currentTime, 0.03);
  driveGain.gain.setTargetAtTime(0.95 + t*1.10, audioCtx.currentTime, 0.03);

  const f = 180 + Math.pow(t, 1.35) * 7200;
  const q = 1.0 + t*18.0;
  filter.frequency.setTargetAtTime(f, audioCtx.currentTime, 0.03);
  filter.Q.setTargetAtTime(q, audioCtx.currentTime, 0.03);

  const ringHz = 10 + t*360;
  ringOsc.frequency.setTargetAtTime(ringHz, audioCtx.currentTime, 0.03);
  ringGain.gain.setTargetAtTime(t*0.95, audioCtx.currentTime, 0.03);

  const wob = (Math.sin(performance.now()*0.0017)*0.5+0.5);
  dL.delayTime.setTargetAtTime(0.0015 + t*0.014 + wob*0.0012, audioCtx.currentTime, 0.05);
  dR.delayTime.setTargetAtTime(0.0040 + t*0.020 + (1-wob)*0.0014, audioCtx.currentTime, 0.05);

  const txtFx = document.getElementById('txtFx');
  if(txtFx) txtFx.textContent =
    `drive:${driveAmt.toFixed(1)} | filter:${f.toFixed(0)}Hz Q:${q.toFixed(1)} | ring:${ringHz.toFixed(1)}Hz depth:${(t*0.95).toFixed(2)} | widen:${t.toFixed(2)}`;
}
if(isMainWindow) window.applyFX = applyFX;

/* ==========================================================
    VISUAL UI + PARAMS - SHARED
========================================================== */
// Idle Drama ê¸°ë³¸ê°’ì„ 0.55ì—ì„œ 0.20ìœ¼ë¡œ ë‚®ì¶° ì „ë°˜ì ì¸ ì›€ì§ì„ ì†ë„ë¥¼ ì¤„ì…ë‹ˆë‹¤.
hookRangeSave('rngIdleDrama', 0.20);
hookRangeSave('rngVisSens', 1.55);
hookRangeSave('rngLine', 0.75);
hookRangeSave('rngPerf', 0.72);
hookRangeSave('rngFade', 0.03);
hookRangeSave('rngPointSize', 0.60);
hookRangeSave('rngGlow', 0.45);

if(isMainWindow){
    applySelectValue('selPointColor', 'red');
    hookSelectSave('selPointColor');
}

function getIdleDrama(){ return Math.max(0, Math.min(1, parseFloat(rngIdleDrama.value)||0.20)); }
function getVisSens(){ return Math.max(0.6, Math.min(2.6, parseFloat(rngVisSens.value)||1.55)); }
function getLineMul(){ return Math.max(0.2, Math.min(1.2, parseFloat(rngLine.value)||0.75)); }
function getPerfLim(){ return Math.max(0.25, Math.min(1.0, parseFloat(rngPerf.value)||0.72)); }
function getFade(){ return Math.max(0.02, Math.min(0.20, parseFloat(rngFade.value)||0.03)); }
function getPointSize(){ return Math.max(0.4, Math.min(1.2, parseFloat(rngPointSize.value)||0.6)); }
function getGlow(){ return Math.max(0.10, Math.min(1.0, parseFloat(rngGlow.value)||0.45)); }
function getPointColor(){
  const selPointColor = document.getElementById('selPointColor');
  return (selPointColor && selPointColor.value === "red") ? "#ff3b3b" : "#ffffff";
}
function getMode(){ 
    const selMode = document.getElementById('selMode');
    return selMode ? selMode.value : 'pulse'; 
}

/* ==========================================================
    VISUAL FIELD - MAIN WINDOW ONLY
========================================================== */
let N = 220;
let pts = [];
let rot = 0;

const BASE_QUIET_TH = 0.0032;
const BASE_ACTIVE_TH = 0.0065;
const BASE_ONSET_TH  = 0.0060;

let energy = 0;
let burstEnergy = 0;

function initPoints(){
  pts = [];
  for(let i=0;i<N;i++){
    pts.push({
      x:(Math.random()*2-1)*(W*0.34),
      y:(Math.random()*2-1)*(H*0.34),
      z:(Math.random()*2-1)*340,
      vx:0,vy:0,vz:0
    });
  }
}
if(isMainWindow) window.initPoints = initPoints;

function project(p){
  const s=Math.sin(rot), c=Math.cos(rot);
  const x = p.x*c - p.z*s;
  const z = p.x*s + p.z*c;
  const depth = 900;
  const k = depth/(depth+z);
  return { x:x*k + W/2, y:p.y*k + H/2, k, z };
}

function applyBounds(p, mode){
  if(mode==="wrap"){
    const maxX=W*0.65, maxY=H*0.65, maxZ=560;
    if(p.x> maxX) p.x=-maxX;
    if(p.x<-maxX) p.x= maxX;
    if(p.y> maxY) p.y=-maxY;
    if(p.y<-maxY) p.y= maxY;
    if(p.z> maxZ) p.z=-maxZ;
    if(p.z<-maxZ) p.z= maxZ;
    return;
  }

  const maxX=W*0.58, maxY=H*0.58, maxZ=560;

  if(mode==="bounce"){
    if(p.x> maxX){ p.x=maxX; p.vx*=-0.7; }
    if(p.x<-maxX){ p.x=-maxX; p.vx*=-0.7; }
    if(p.y> maxY){ p.y=maxY; p.vy*=-0.7; }
    if(p.y<-maxY){ p.y=-maxY; p.vy*=-0.7; }
    if(p.z> maxZ){ p.z=maxZ; p.vz*=-0.7; }
    if(p.z<-maxZ){ p.z=-maxZ; p.vz*=-0.7; }
    return;
  }

  const pull = 0.0026;
  const edgeX = Math.max(0, Math.abs(p.x) - maxX);
  const edgeY = Math.max(0, Math.abs(p.y) - maxY);
  const edgeZ = Math.max(0, Math.abs(p.z) - maxZ);
  if(edgeX>0) p.vx += (-Math.sign(p.x)) * edgeX * pull;
  if(edgeY>0) p.vy += (-Math.sign(p.y)) * edgeY * pull;
  if(edgeZ>0) p.vz += (-Math.sign(p.z)) * edgeZ * pull;
}

/* ==========================================================
    UI / TOGGLES - MAIN WINDOW ONLY
========================================================== */
function updateTopPill(q=1){
  const pill = document.getElementById('topPill');
  if(!pill) return; // Safety check
  const a = audioCtx ? audioCtx.state : 'off';
  const src = (currentSource==="mic")
    ? (micStream ? "mic:on" : "mic:off")
    : (fileAudioEl && fileAudioEl.src ? (fileAudioEl.paused ? "file:loaded" : "file:play") : "file:empty");
  pill.textContent = `audio:${a} | src:${src} | q:${q.toFixed(2)}`;
}
if(isMainWindow) window.updateTopPill = updateTopPill;

const ui = document.getElementById('ui');
const btnGear = document.getElementById('btnGear');
const btnHideUI = document.getElementById('btnHideUI');

// Main window: Open settings in a new pop-up window
if(isMainWindow){
  let settingsPopup = null;

  btnGear.addEventListener('click', ()=>{
    if(settingsPopup && !settingsPopup.closed){
      settingsPopup.focus();
      return;
    }
    
    // Create the content HTML string
    const uiClone = document.getElementById('ui').cloneNode(true);
    uiClone.id = 'ui-popup';
    uiClone.style.display = 'block';
    uiClone.classList.remove('hidden');

    // Create a temporary container to get the inner HTML
    const tempContainer = document.createElement('div');
    tempContainer.appendChild(uiClone);
    
    // The main script body for the popup window
    const popupScript = `
      <script>
        const STORE_KEY = "limen_workshop_settings_v3_entry";
        function loadSettings(){ try{ return JSON.parse(localStorage.getItem(STORE_KEY)||"{}"); }catch(e){ return {}; } }
        let S = loadSettings();
        
        // --- Mirrored Logic Functions ---
        // These rely on the elements being present in the popup or calling the opener
        
        ${window.applyEQ.toString()}
        ${window.getEQLow.toString()}
        ${window.getEQMid.toString()}
        ${window.getEQHigh.toString()}
        ${window.refreshAudioLabels.toString()}
        
        ${window.getIdleDrama.toString()}
        ${window.getVisSens.toString()}
        ${window.getLineMul.toString()}
        ${window.getPerfLim.toString()}
        ${window.getFade.toString()}
        ${window.getPointSize.toString()}
        ${window.getGlow.toString()}
        ${window.getPointColor.toString()}
        ${window.getMode.toString()}
        ${window.refreshVisualLabels.toString()}
        
        ${window.getMIDIDead.toString()}
        ${window.getMIDIGain.toString()}
        ${window.getMIDICurve.toString()}
        ${window.getMIDISmooth.toString()}
        ${window.refreshMIDILabels.toString()}
        
        // --- Setup and Event Handlers ---
        window.addEventListener('DOMContentLoaded', ()=>{
            const opener = window.opener;
            if(!opener) {
                alert("ì„¤ì • íŒì—…ì´ ë©”ì¸ ì°½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì°½ì„ ë‹«ì•„ì£¼ì„¸ìš”.");
                return;
            }
            const uiPopup = document.getElementById('ui-popup');
            uiPopup.style.position = 'static';
            uiPopup.style.margin = '0 auto';
            uiPopup.style.width = 'calc(100% - 20px)';
            uiPopup.style.maxWidth = '560px';

            // Function to update local storage and notify opener
            function updateSettings(el) {
                const isFloat = (el.type === 'number' || el.type === 'range') && el.step.includes('.');
                const value = isFloat ? parseFloat(el.value) : (el.type === 'number' ? parseInt(el.value, 10) : el.value);
                
                S[el.id] = value;
                localStorage.setItem(STORE_KEY, JSON.stringify(S));
                if (opener.S) opener.S = S; 

                refreshAudioLabels();
                refreshVisualLabels();
                
                if (el.id.startsWith('rngEQ') && opener.audioCtx) {
                    applyEQ();
                }
                if (el.id === 'selMode' && opener.document.getElementById('selMode')) {
                    // Trigger mode preset change in opener if required
                    opener.document.getElementById('selMode').dispatchEvent(new Event('change'));
                }
            }

            // Apply saved settings and attach listeners
            document.querySelectorAll('select, input[type="range"], input[type="number"]').forEach(el => {
                if (S.hasOwnProperty(el.id)) {
                    el.value = S[el.id];
                }
                ['input', 'change'].forEach(ev => {
                    el.addEventListener(ev, () => updateSettings(el));
                });
            });

            // Handle TAB switching
            document.querySelectorAll('#ui-popup .tab').forEach(t=>{
                t.addEventListener('click', ()=>{
                    document.querySelectorAll('#ui-popup .tab').forEach(x=>x.classList.remove('active'));
                    document.querySelectorAll('#ui-popup .panel').forEach(x=>x.classList.remove('active'));
                    t.classList.add('active');
                    document.getElementById('panel-'+t.dataset.tab).classList.add('active');
                    S.activeTab = t.dataset.tab;
                    localStorage.setItem(STORE_KEY, JSON.stringify(S));
                    if (opener.S) opener.S = S;
                    
                    if (t.dataset.tab === "system" && opener.listDevices) opener.listDevices();
                    if (t.dataset.tab === "midi" && opener.initMIDI) opener.initMIDI();
                });
            });
            
            // Restore active tab
            if(S.activeTab){
                const tabEl = document.querySelector(\`#ui-popup .tab[data-tab="\${S.activeTab}"]\`);
                if(tabEl) tabEl.click();
            } else {
                document.querySelector('#ui-popup .tab[data-tab="visual"]').click();
            }


            // --- Opener Function Proxies ---
            document.getElementById('btnHideUI').addEventListener('click', ()=> window.close());
            document.getElementById('btnResume').addEventListener('click', ()=> opener.document.getElementById('btnResume').click());
            document.getElementById('btnMicOn').addEventListener('click', ()=> opener.document.getElementById('btnMicOn').click());
            document.getElementById('btnMicOff').addEventListener('click', ()=> opener.document.getElementById('btnMicOff').click());
            document.getElementById('btnFilePlay').addEventListener('click', ()=> opener.document.getElementById('btnFilePlay').click());
            document.getElementById('btnFilePause').addEventListener('click', ()=> opener.document.getElementById('btnFilePause').click());
            document.getElementById('btnFileStop').addEventListener('click', ()=> opener.document.getElementById('btnFileStop').click());

            document.getElementById('selSrc').addEventListener('change', (e)=> {
                 opener.document.getElementById('selSrc').value = e.target.value;
                 opener.document.getElementById('selSrc').dispatchEvent(new Event('change'));
                 opener.setMicButtons(!!opener.micStream);
            });
            document.getElementById('selMic').addEventListener('change', (e)=> {
                 opener.document.getElementById('selMic').value = e.target.value;
                 opener.document.getElementById('selMic').dispatchEvent(new Event('change'));
            });
            document.getElementById('selSpk').addEventListener('change', (e)=> {
                 opener.document.getElementById('selSpk').value = e.target.value;
                 opener.document.getElementById('selSpk').dispatchEvent(new Event('change'));
            });
            
            // File input cannot pass File object directly, let the user know
            document.getElementById('fileAudio').addEventListener('change', (e)=>{
                if(e.target.files.length > 0) alert("íŒŒì¼ ë¡œë“œëŠ” ë©”ì¸ í™”ë©´ì˜ 'SYSTEM' íƒ­ì—ì„œ ì§ì ‘ ì§„í–‰í•´ì•¼ í•©ë‹ˆë‹¤.");
            });
            
            // MIDI controls
            document.getElementById('selMIDIIn').addEventListener('change', (e)=> {
                if (opener.attachMIDIInput) opener.attachMIDIInput(e.target.value);
            });
            document.getElementById('btnMIDIInit').addEventListener('click', ()=> {
                if (opener.initMIDI) opener.initMIDI();
            });
            document.getElementById('btnMIDILearn').addEventListener('click', ()=> {
                if (opener.document.getElementById('btnMIDILearn')) opener.document.getElementById('btnMIDILearn').click();
            });
            
            // Initial call to update visual labels in the popup
            refreshAudioLabels();
            refreshVisualLabels();
        });
      </script>
    `;

    settingsPopup = window.open('about:blank', 'LimenSettings', 'width=600,height=800,scrollbars=yes');
    if(!settingsPopup) {
      alert("íŒì—… ì°¨ë‹¨ìœ¼ë¡œ ì„¤ì • ì°½ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íŒì—… ì°¨ë‹¨ì„ í•´ì œí•´ì£¼ì„¸ìš”.");
      return;
    }
    
    const finalHTML = `
        <!doctype html>
        <html lang="ko">
        <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
        <title>LIMEN WORKSHOP â€“ Settings</title>
        <style>
          body { background: #000; margin: 0; padding: 10px; }
          #ui-popup { position: static !important; }
        </style>
        <style>${document.head.querySelector('style').textContent}</style>
        </head>
        <body>
        ${tempContainer.innerHTML}
        ${popupScript}
        </body>
        </html>
    `;
    
    settingsPopup.document.write(finalHTML);
    settingsPopup.document.close();
  });
}


function toggleFullscreen(){
  const el = document.documentElement;
  if(!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
}
document.getElementById('btnFS').addEventListener('click', toggleFullscreen);
document.getElementById('btnFSQuick').addEventListener('click', toggleFullscreen);

// System Tab resume button handler
document.getElementById('btnResume').addEventListener('click', async ()=>{
  ensureAudio();
  await audioCtx.resume();
  await afterAudioUnlocked();
});

document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click', ()=>{
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    document.getElementById('panel-'+t.dataset.tab).classList.add('active');
    S.activeTab = t.dataset.tab;
    saveSettings(S);
    
    if(t.dataset.tab === "system"){
        if(listDevices) listDevices();
    }else if(t.dataset.tab === "midi"){
        if(initMIDI) initMIDI();
    }
  });
});

/* ==========================================================
    SOURCE SELECT UI (SYSTEM) + (ENTRY mirror) - MAIN WINDOW ONLY
========================================================== */
const selSrc = document.getElementById('selSrc');
const rowMic = document.getElementById('rowMic');
const rowFile = document.getElementById('rowFile');

const entrySelSrc = document.getElementById('entrySelSrc');
const entryMicBox = document.getElementById('entryMicBox');
const entryFileBox = document.getElementById('entryFileBox');

function applySourceUI(){
  currentSource = selSrc.value;
  S.currentSource = currentSource;
  saveSettings(S);

  rowMic.style.display = (currentSource==="mic") ? "" : "none";
  rowFile.style.display = (currentSource==="file") ? "" : "none";

  // entry mirror
  entrySelSrc.value = currentSource;
  entryMicBox.style.display = (currentSource==="mic") ? "" : "none";
  entryFileBox.style.display = (currentSource==="file") ? "" : "none";
  
  // Update Start Audio Button state
  const btnStartAudio = document.getElementById('btnStartAudio');
  if(btnStartAudio){
      btnStartAudio.textContent = "Start Audio (Unlock Only)";
      btnStartAudio.disabled = !!audioCtx && audioCtx.state !== 'suspended';
  }

  setMicButtons(!!micStream);
  
  if(currentSource === "mic" && !!audioCtx && audioCtx.state === 'running'){
      listDevices();
  }
  
  updateTopPill(1);
}
if(isMainWindow){
  selSrc.addEventListener('change', async ()=>{
    applySourceUI();
    if(currentSource==="mic"){
      if(fileAudioEl){ try{ fileAudioEl.pause(); }catch(e){} }
      if(fileNode){ try{ fileNode.disconnect(); }catch(e){} fileNode=null; }
      ampSmooth=amp=ampDelta=prevAmp=0;
    }else{
      stopMic();
      if(inputNode){ try{ inputNode.disconnect(); }catch(e){} inputNode=null; }
      ampSmooth=amp=ampDelta=prevAmp=0;
      if(fileAudioEl && fileAudioEl.src){
        ensureAudio(); await audioCtx.resume();
        connectFileToChain();
      }
    }
  });
  entrySelSrc.addEventListener('change', async ()=>{
    selSrc.value = entrySelSrc.value;
    applySourceUI();
    if(currentSource==="file"){
      stopMic();
    }
  });

  applySelectValue('selSrc', (S.currentSource ?? 'mic'));
  hookSelectSave('selSrc');
  applySourceUI();
}


/* ==========================================================
    FILE CONTROLS (SYSTEM + ENTRY mirror) - MAIN WINDOW ONLY
========================================================== */
const fileAudio = document.getElementById('fileAudio');
const btnFilePlay = document.getElementById('btnFilePlay');
const btnFilePause = document.getElementById('btnFilePause');
const btnFileStop = document.getElementById('btnFileStop');
const txtFile = document.getElementById('txtFile');

const entryFileAudio = document.getElementById('entryFileAudio');
const entryFilePlay = document.getElementById('entryFilePlay');
const entryFilePause = document.getElementById('entryFilePause');
const entryFileStop = document.getElementById('entryFileStop');
const entryFileTxt = document.getElementById('entryFileTxt');

function setSystemFileBtns(enabled){
  if(btnFilePlay) btnFilePlay.disabled = !enabled;
  if(btnFilePause) btnFilePause.disabled = !enabled;
  if(btnFileStop) btnFileStop.disabled = !enabled;
}

async function loadFileFromInput(file){
  if(!file) return;
  if(!audioCtx || audioCtx.state !== 'running') {
      startStatus("Audio Contextê°€ ì ê¸ˆ í•´ì œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. Start Audioë¥¼ ë¨¼ì € ëˆŒëŸ¬ì£¼ì„¸ìš”.");
      return;
  }

  ensureAudio();
  await audioCtx.resume();
  setupOutputRouting();
  ensureFileAudioEl();

  const url = URL.createObjectURL(file);
  try{ fileAudioEl.pause(); }catch(e){}
  fileAudioEl.src = url;
  fileAudioEl.loop = true;

  if(txtFile) txtFile.textContent = `loaded: ${file.name} (${Math.round(file.size/1024)} KB)`;
  if(entryFileTxt) entryFileTxt.textContent = `loaded: ${file.name} (${Math.round(file.size/1024)} KB)`;

  if(currentSource!=="file"){
    if(selSrc) selSrc.value = "file";
    applySourceUI();
  }

  connectFileToChain();
  setSystemFileBtns(true);
  setMicButtons(!!micStream);
  updateTopPill(1);
}

if(isMainWindow){
  if(fileAudio) fileAudio.addEventListener('change', async ()=>{
    const f = fileAudio.files && fileAudio.files[0];
    if(!f) return;
    await loadFileFromInput(f);
  });
  if(entryFileAudio) entryFileAudio.addEventListener('change', async ()=>{
    const f = entryFileAudio.files && entryFileAudio.files[0];
    if(!f) return;
    await loadFileFromInput(f);
  });

  /* ==========================================================
      ENTRY ENTER: Mic ON / File Play -> hide entry
  ========================================================== */
  function hideEntryAndEnter(){
    const hint = document.getElementById('hint');
    if(hint) hint.style.display='none';
  }
  function showEntry(msg=""){
    const hint = document.getElementById('hint');
    if(hint) hint.style.display='flex';
    if(msg) startStatus(msg);
  }

  // --- Mic Entry Buttons ---
  if(document.getElementById('entryMicOn')) document.getElementById('entryMicOn').addEventListener('click', async ()=>{
    if(currentSource!=="mic") return;
    await startMic(currentMicDeviceId, true);
  });
  if(document.getElementById('entryMicOff')) document.getElementById('entryMicOff').addEventListener('click', ()=> stopMic());


  // --- File Entry Buttons ---
  if(entryFilePlay) entryFilePlay.addEventListener('click', async ()=>{
    if(currentSource!=="file") return;
    if(!fileAudioEl || !fileAudioEl.src) {
        startStatus("íŒŒì¼ì„ ë¨¼ì € ì„ íƒí•´ ì£¼ì„¸ìš”.");
        return;
    }
    if(!audioCtx || audioCtx.state !== 'running') {
        startStatus("Audio Contextê°€ ì ê¸ˆ í•´ì œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. Start Audioë¥¼ ë¨¼ì € ëˆŒëŸ¬ì£¼ì„¸ìš”.");
        return;
    }

    ensureAudio(); await audioCtx.resume();
    connectFileToChain();
    try{ await fileAudioEl.play(); }catch(e){
      alert("ì¬ìƒì´ ë§‰í˜”ì–´ìš”. í™”ë©´ì„ í•œë²ˆ í„°ì¹˜/í´ë¦­í•œ ë’¤ ë‹¤ì‹œ Play ëˆŒëŸ¬ì£¼ì„¸ìš”.");
      return;
    }
    updateTopPill(1);
    hideEntryAndEnter();
  });
  if(entryFilePause) entryFilePause.addEventListener('click', ()=>{
    if(!fileAudioEl) return;
    try{ fileAudioEl.pause(); }catch(e){}
    updateTopPill(1);
    setMicButtons(!!micStream);
  });
  if(entryFileStop) entryFileStop.addEventListener('click', ()=>{
    if(!fileAudioEl) return;
    try{ fileAudioEl.pause(); fileAudioEl.currentTime = 0; }catch(e){}
    updateTopPill(1);
    setMicButtons(!!micStream);
  });

  // --- System File Buttons ---
  if(btnFilePlay) btnFilePlay.addEventListener('click', async ()=>{
    if(!fileAudioEl || !fileAudioEl.src) return;
    ensureAudio(); await audioCtx.resume();
    connectFileToChain();
    try{ await fileAudioEl.play(); }catch(e){
      alert("ì¬ìƒì´ ë§‰í˜”ì–´ìš”. í™”ë©´ì„ í•œë²ˆ í„°ì¹˜/í´ë¦­í•œ ë’¤ ë‹¤ì‹œ Play ëˆŒëŸ¬ì£¼ì„¸ìš”.");
    }
    updateTopPill(1);
    setMicButtons(!!micStream);
  });
  if(btnFilePause) btnFilePause.addEventListener('click', ()=>{
    if(!fileAudioEl) return;
    try{ fileAudioEl.pause(); }catch(e){}
    updateTopPill(1);
    setMicButtons(!!micStream);
  });
  if(btnFileStop) btnFileStop.addEventListener('click', ()=>{
    if(!fileAudioEl) return;
    try{ fileAudioEl.pause(); fileAudioEl.currentTime = 0; }catch(e){}
    updateTopPill(1);
    setMicButtons(!!micStream);
  });

  /* ==========================================================
      ENTRY: Start Audio (unlock)
      >>> THIS IS THE CRITICAL START BUTTON <<<
  ========================================================== */
  async function handleAudioUnlock(){
    ensureAudio();
    const state = await audioCtx.resume();
    if(state === 'running'){
        await afterAudioUnlocked();
        await initMIDI();
        startStatus("âœ… Audio Context ì ê¸ˆ í•´ì œ ì„±ê³µ! Mic ON ë˜ëŠ” File Playë¥¼ ëˆŒëŸ¬ ì…ì¥í•˜ì„¸ìš”.");
        setMicButtons(!!micStream); // Update buttons after unlock
        
        // Remove global listener once unlocked
        window.removeEventListener('pointerdown', handleAudioUnlock, true); 
    }
  }
  
  // 1. Button Click Listener (Primary method)
  document.getElementById('btnStartAudio').addEventListener('click', handleAudioUnlock);

  // 2. Global Fallback Listener (Highly reliable method)
  // Use capture phase (true) to ensure it runs first
  window.addEventListener('pointerdown', handleAudioUnlock, true); 
}

/* ==========================================================
    VISUAL SELECT RESTORE - MAIN WINDOW ONLY
========================================================== */
if(isMainWindow){
  applySelectValue('selMode', 'pulse');
  applySelectValue('selN', '220');
  applySelectValue('selBounds', 'soft');
  applySelectValue('selQuietLines', '1');
  applySelectValue('selAutoReboot', '1');

  ['selMode','selN','selBounds','selQuietLines','selAutoReboot'].forEach(hookSelectSave);

  if(document.getElementById('selN')) document.getElementById('selN').addEventListener('change', (e)=>{
    N = parseInt(e.target.value,10);
    initPoints();
  });
  
  // Custom logic for Mode presets
  if(document.getElementById('selMode')) document.getElementById('selMode').addEventListener('change', (e) => {
      const mode = e.target.value;
      const rngIdleDramaEl = document.getElementById('rngIdleDrama');
      const rngVisSensEl = document.getElementById('rngVisSens');
      const rngLineEl = document.getElementById('rngLine');
      const rngPointSizeEl = document.getElementById('rngPointSize');
      const selPointColorEl = document.getElementById('selPointColor');
      
      const updateAndDispatch = (el, value) => {
          if (el) {
              el.value = value;
              el.dispatchEvent(new Event('input'));
              el.dispatchEvent(new Event('change'));
          }
      };
      
      switch (mode) {
          case 'piano':
              updateAndDispatch(rngIdleDramaEl, 0.10);
              updateAndDispatch(rngVisSensEl, 2.0);
              updateAndDispatch(rngLineEl, 1.0);
              updateAndDispatch(rngPointSizeEl, 0.80);
              updateAndDispatch(selPointColorEl, 'white');
              break;
          case 'melancholy':
              updateAndDispatch(rngIdleDramaEl, 0.05);
              updateAndDispatch(rngVisSensEl, 0.8);
              updateAndDispatch(rngLineEl, 0.45);
              updateAndDispatch(rngPointSizeEl, 0.50);
              updateAndDispatch(selPointColorEl, 'red');
              break;
          case 'calm':
              updateAndDispatch(rngIdleDramaEl, 0.55);
              updateAndDispatch(rngVisSensEl, 1.0);
              updateAndDispatch(rngLineEl, 0.75);
              updateAndDispatch(rngPointSizeEl, 0.60);
              updateAndDispatch(selPointColorEl, 'red');
              break;
          case 'pulse':
          case 'burst':
          default:
              updateAndDispatch(rngIdleDramaEl, 0.20);
              updateAndDispatch(rngVisSensEl, 1.55);
              updateAndDispatch(rngLineEl, 0.75);
              updateAndDispatch(rngPointSizeEl, 0.60);
              updateAndDispatch(selPointColorEl, 'red');
              break;
      }
  });
}


/* ==========================================================
    ENTRY REBOOT (í•µì‹¬ ë³€ê²½!) - MAIN WINDOW ONLY
========================================================== */
function clearRuntime(){
  amp = 0; ampSmooth = 0; ampDelta = 0; prevAmp = 0;
  touchRaw = 0; touch = 0; touchSmooth = 0; lastMidiAt = 0;
  energy = 0; burstEnergy = 0; rot = 0;
  initPoints();

  document.getElementById('hudMidi').textContent = "midi: -";
  document.getElementById('hudTouch').textContent = "0.000";
  document.getElementById('hudAmp').textContent = "0.000";
  document.getElementById('hudTouchBar').style.width = "0%";

  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,W,H);
}

async function entryReboot(reason="lag"){
  console.warn("ENTRY REBOOT:", reason);

  // stop inputs
  try{ stopMic(); }catch(e){}
  try{
    if(fileAudioEl){
      try{ fileAudioEl.pause(); }catch(e){}
    }
  }catch(e){}

  try{ disconnectInputs(); }catch(e){}
  fileNode = null;
  inputNode = null;

  // close audio context to truly clear overload
  try{
    if(audioCtx){
      try{ await audioCtx.close(); }catch(e){}
    }
  }catch(e){}
  audioCtx = null;
  analyser = null;
  timeData = null;
  masterGain = null;
  preGain = null;
  eqLow = eqMid = eqHigh = null;
  driveWS = driveGain = null;
  filter = null;
  ringOsc = null;
  ringGain = null;
  ringMult = null;
  splitter = null;
  dL = dR = null;
  merger = null;
  comp = null;
  monitorDest = null;

  clearRuntime();

  // buttons back to "locked"
  setMicButtons(false);
  updateTopPill(1);

  // Entry UI states (enable/disable) â€” Start Audio must be pressed again
  const entrySelMic = document.getElementById('entrySelMic');
  if(entrySelMic) entrySelMic.disabled = true;
  if(entrySelMic) entrySelMic.innerHTML = `<option>Start Audio í›„ ëª©ë¡ ë¡œë“œ</option>`;
  
  showEntry(`ë ‰ ê°ì§€ â†’ Entryë¡œ ë³µê·€ (reason: ${reason})`);
  
  // Re-enable the main Start Audio button
  const btnStartAudio = document.getElementById('btnStartAudio');
  if(btnStartAudio) btnStartAudio.disabled = false;
}
if(isMainWindow) window.entryReboot = entryReboot;

document.getElementById("btnReset").addEventListener("click", ()=> entryReboot("manual reset"));

/* ==========================================================
    AUTO REBOOT ON LAG / FREEZE - MAIN WINDOW ONLY
========================================================== */
const selAutoReboot = document.getElementById('selAutoReboot');
function autoRebootEnabled(){ return (selAutoReboot && selAutoReboot.value === "1"); }

let lastFrameT = performance.now();
let frameMsSmooth = 16.7;
let lagTimer = 0;

let lastAnimTick = performance.now();
if(isMainWindow){
  setInterval(()=>{
    const now = performance.now();
    if(!autoRebootEnabled()) return;
    if(now - lastAnimTick > 1600){
      entryReboot("freeze watchdog");
      lastAnimTick = now;
    }
  }, 400);

  function checkLag(dt){
    if(!autoRebootEnabled()) return;
    if(dt > 45){
      lagTimer += dt;
      if(lagTimer > 2200){
        entryReboot("lag reboot");
        lagTimer = 0;
      }
    }else{
      lagTimer = Math.max(0, lagTimer - 50);
    }
  }
}

/* ==========================================================
    MAIN LOOP - MAIN WINDOW ONLY
========================================================== */
const meterIn = document.getElementById('meterIn');
const meterTouch = document.getElementById('meterTouch');
let lastUiT = 0;

if(isMainWindow){
  function loop(){
    const now = performance.now();
    lastAnimTick = now;

    const dt = now - lastFrameT;
    lastFrameT = now;
    frameMsSmooth += (dt - frameMsSmooth) * 0.08;

    checkLag(dt);

    let qAuto = 1 - Math.max(0, (frameMsSmooth - 16) / 45);
    qAuto = Math.max(0.28, Math.min(1, qAuto));
    const q = Math.min(qAuto, getPerfLim());

    ctx.fillStyle = `rgba(0,0,0,${getFade().toFixed(3)})`;
    ctx.fillRect(0,0,W,H);

    if(audioCtx){
      applyEQ();
      updateAmp();
    }else{
      // audio locked ìƒíƒœì—ì„œë„ visualsê°€ ëŒì•„ê°€ë˜ amp=0ë¡œ ìœ ì§€
      amp = 0; ampDelta = 0;
    }

    updateTouch();
    if(audioCtx) applyFX();

    if(now - lastUiT > 110){
      lastUiT = now;
      const inPct = Math.max(0, Math.min(1, amp*6.0));
      if(meterIn) meterIn.style.width = (inPct*100).toFixed(1)+"%";
      const txtAmp = document.getElementById('txtAmp');
      if(txtAmp) txtAmp.textContent =
        `amp: ${amp.toFixed(4)} | dAmp: ${ampDelta.toFixed(4)} | frame:${frameMsSmooth.toFixed(1)}ms | q:${q.toFixed(2)}`;

      const sim = Math.max(0, Math.min(1, parseFloat(rngSimTouch.value)||0));
      const tv = Math.max(touchSmooth, sim);
      if(meterTouch) meterTouch.style.width = (tv*100).toFixed(1)+"%";

      document.getElementById('hudTouch').textContent = tv.toFixed(3);
      document.getElementById('hudAmp').textContent = amp.toFixed(3);
      document.getElementById('hudMidi').textContent = midiName;
      document.getElementById('hudTouchBar').style.width = (tv*100).toFixed(1)+"%";

      updateTopPill(q);
    }

    const visSens = getVisSens();
    const idleDrama = getIdleDrama();

    // Visual Sens Multiplier Adjustment for slower movement
    const visSensFactor = 0.65; 

    const QUIET_TH = BASE_QUIET_TH / visSens * visSensFactor;
    const ACTIVE_TH = BASE_ACTIVE_TH / visSens * visSensFactor;
    const ONSET_TH  = BASE_ONSET_TH / visSens * visSensFactor;

    const targetEnergy = (amp > ACTIVE_TH) ? 1 : (amp < QUIET_TH ? 0 : energy);
    energy += (targetEnergy - energy) * 0.05;

    const energyFloor = 0.02 + idleDrama * 0.10; // Lowered idle floor
    energy = Math.max(energyFloor, energy);

    const onset = Math.max(0, (ampDelta - ONSET_TH));
    burstEnergy += (onset*8.0 - burstEnergy) * 0.12;
    burstEnergy *= 0.92;
    burstEnergy = Math.min(1.5, burstEnergy);

    const mode = getMode();
    const boundsMode = document.getElementById('selBounds').value;
    const quietLines = parseInt(document.getElementById('selQuietLines').value,10);

    const t = now*0.001;
    const breathe = 0.5 + 0.5*Math.sin(t*1.2);

    const sim = Math.max(0, Math.min(1, parseFloat(rngSimTouch.value)||0));
    const touchV = Math.max(touchSmooth, sim);

    // BASE SPEED: Slower Defaults for a calmer feel
    let baseSpeedQuiet = 0.05 + idleDrama*0.03; // Lowered
    let baseChaosQuiet = 0.25 + idleDrama*0.50; // Lowered

    let baseSpeedActive = (0.08 + Math.min(0.20, amp*1.8)) * visSens; // Lowered multiplier
    
    let baseChaosActive =
      Math.min(20, // Max chaos reduced
        (ampDelta*80) + // Lowered multiplier
        (touchV*60) +   // Lowered multiplier
        burstEnergy*30  // Lowered multiplier
      ) * visSens;
      
    // Mode specific adjustments
    if(mode==="calm"){ baseSpeedQuiet *= 0.88; baseChaosQuiet *= 0.75; }
    if(mode==="burst"){ baseSpeedQuiet *= 1.05; baseChaosQuiet *= 1.18; }
    if(mode==="piano"){ 
        baseSpeedQuiet *= 0.70; baseChaosQuiet *= 0.15; // Very low idle chaos
        baseSpeedActive *= 1.1; baseChaosActive *= 1.5; // High reactive chaos
    }
    if(mode==="melancholy"){
        baseSpeedQuiet *= 0.50; baseChaosQuiet *= 0.05; // Extremely slow and low chaos
        baseSpeedActive *= 0.6; baseChaosActive *= 0.4;
    }


    let speed = baseSpeedQuiet*(1-energy) + baseSpeedActive*energy;
    let chaos = baseChaosQuiet*(1-energy) + baseChaosActive*energy;

    const lineMul = getLineMul();
    const linkDistQuiet = 26 + idleDrama*10;
    const linkDistActiveRaw = (50 + amp*200 + touchV*400 + burstEnergy*80) * lineMul * visSens;
    const linkDistActive = Math.min(180, linkDistActiveRaw);
    const linkDist = linkDistQuiet*(1-energy) + linkDistActive*energy;

    const centerPull = (0.005 + touchV*0.020) * (1.0 - Math.min(1, amp*1.2)) * (0.75 + idleDrama*0.6); // Lowered pull
    const burst = (amp*0.012 + ampDelta*0.040 + touchV*0.015 + burstEnergy*0.015) * visSens; // Lowered burst

    const freeze = energy * Math.max(0, 1 - (ampDelta*20));
    const rotSpeedBase = (0.0012 + energy*0.010 + burstEnergy*0.008 + touchV*0.010) * (1 - 0.7*freeze);
    const rotSpeed = rotSpeedBase * (0.65 + idleDrama*0.8);
    rot += rotSpeed;

    const scale = 1.0 + energy*(breathe-0.5)*0.25;

    for(const p of pts){
      p.vx += (Math.random()-0.5)*chaos;
      p.vy += (Math.random()-0.5)*chaos;
      p.vz += (Math.random()-0.5)*chaos*0.55;

      p.vx += (-p.x)*centerPull*(0.9 - energy*0.4);
      p.vy += (-p.y)*centerPull*(0.9 - energy*0.4);
      p.vz += (-p.z)*centerPull*(0.6 - energy*0.2);

      p.vx += (p.x)*burst*energy;
      p.vy += (p.y)*burst*energy;
      p.vz += (p.z)*burst*energy*0.6;

      p.vx *= 0.90 - energy*0.05;
      p.vy *= 0.90 - energy*0.05;
      p.vz *= 0.92 - energy*0.04;

      p.x = (p.x + p.vx*speed) * scale + (1-scale)*p.x;
      p.y = (p.y + p.vy*speed) * scale + (1-scale)*p.y;
      p.z = (p.z + p.vz*speed) * (0.92 + 0.08*scale) + (1-(0.92 + 0.08*scale))*p.z;

      applyBounds(p, boundsMode);
    }

    const pr = pts.map(project);

    if(energy > 0.05 || quietLines>0){
      const cell = Math.max(22, Math.floor(linkDist));
      const inv = 1 / cell;
      const grid = new Map();

      for(let i=0;i<N;i++){
        const a = pr[i];
        const cx = (a.x*inv)|0;
        const cy = (a.y*inv)|0;
        const key = (cx<<16) ^ (cy & 0xffff);
        let arr = grid.get(key);
        if(!arr){ arr=[]; grid.set(key, arr); }
        arr.push(i);
      }

      const baseMax = (900 + energy*700 + burstEnergy*600 + touchV*500) * lineMul; // Lowered base max
      const maxLines = Math.floor(baseMax * q);

      let linesDrawn = 0;
      const stride = (q < 0.45) ? 2 : 1;

      for(let i=0;i<N;i+=stride){
        if(linesDrawn >= maxLines) break;
        const a = pr[i];
        const cx = (a.x*inv)|0;
        const cy = (a.y*inv)|0;

        for(let oy=-1; oy<=1; oy++){
          for(let ox=-1; ox<=1; ox++){
            if(linesDrawn >= maxLines) break;

            const k = ((cx+ox)<<16) ^ ((cy+oy) & 0xffff);
            const bucket = grid.get(k);
            if(!bucket) continue;

            for(let bi=0; bi<bucket.length; bi++){
              const j = bucket[bi];
              if(j<=i) continue;

              const b = pr[j];
              const dx=a.x-b.x, dy=a.y-b.y;
              const d = Math.hypot(dx,dy);
              if(d<linkDist){
                const alpha = 1 - d/linkDist;

                const quietGain = (quietLines===0) ? 0 : (quietLines===1 ? 0.12 : 0.24);
                const onGain = 0.30 + amp*1.2*visSens + burstEnergy*1.2*visSens + touchV*1.0; // Lowered OnGain
                const punch = Math.min(1, alpha * (quietGain*(1-energy) + onGain*energy));

                ctx.globalAlpha = punch * getGlow();
                ctx.strokeStyle = "rgba(255,255,255,0.9)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(a.x,a.y);
                ctx.lineTo(b.x,b.y);
                ctx.stroke();

                linesDrawn++;
                if(linesDrawn >= maxLines) break;
              }
            }
          }
        }
      }
    }

    const glow = getGlow();
    const pSize = getPointSize();
    const pCol = getPointColor();

    for(let i=0;i<N;i++){
      const p = pr[i];

      const baseR = (0.6 + p.k*0.3) * pSize;
      const rQuiet = Math.max(0.9, baseR * (1.05 + idleDrama*0.15));
      const rActive = baseR * (1.15 + amp*2.2*visSens + touchV*1.6 + burstEnergy*0.9);
      const r = rQuiet*(1-energy) + rActive*energy;

      const aQuiet = 0.32 + idleDrama*0.12;
      const aActive = Math.min(1, 0.40 + amp*0.95*visSens + touchV*0.65 + burstEnergy*0.60);
      const a = aQuiet*(1-energy) + aActive*energy;

      ctx.globalAlpha = a * glow;
      ctx.fillStyle = pCol;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    requestAnimationFrame(loop);
  }
  loop();
}

/* ==========================================================
    SYSTEM / RESTORE
========================================================== */
if(isMainWindow){
  if(S.activeTab){
    const tabEl = document.querySelector(`.tab[data-tab="${S.activeTab}"]`);
    if(tabEl) tabEl.click();
  }

  /* ==========================================================
      STARTUP
  ========================================================== */
  N = parseInt(document.getElementById('selN').value,10);
  initPoints();
  updateTopPill(1);
  startStatus("Start Audio ë²„íŠ¼ì„ ëˆ„ë¥´ê±°ë‚˜, í™”ë©´ì„ í´ë¦­í•˜ì—¬ ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œì„ ì¤€ë¹„í•˜ì„¸ìš”.");

  window.addEventListener('pagehide', ()=>{
    try{ stopMic(); }catch(e){}
    try{ if(fileAudioEl) fileAudioEl.pause(); }catch(e){}
  });
}
</script>
</body>
</html>
