<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TouchMe – LIVE Mic Granular + Wave Viz</title>
  <style>
    :root{color-scheme:dark}
    body{margin:0;padding:18px;background:#0b0b0b;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1100px;margin:0 auto}
    .card{background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px}
    h1{font-size:18px;margin:0 0 10px}
    p{opacity:.9;line-height:1.55;margin:8px 0}
    label{display:block;margin-top:10px;font-size:13px;opacity:.9}
    input,select,button{width:100%;margin-top:6px;padding:12px;border-radius:12px;border:1px solid #333;background:#0f0f0f;color:#eee}
    button{cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > *{flex:1;min-width:220px}
    .grid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:12px}
    @media(min-width:980px){ .grid{grid-template-columns:1.2fr .8fr} }
    .viz{background:#0f0f0f;border:1px solid #2a2a2a;border-radius:14px;padding:10px}
    canvas{width:100%;height:280px;display:block;border-radius:10px;background:#0a0a0a}
    .hint{font-size:12px;opacity:.78;margin-top:8px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:#0f0f0f;border:1px solid #2a2a2a;border-radius:12px;padding:12px;white-space:pre-wrap}
    .split{display:grid;grid-template-columns:1fr;gap:10px}
    .small{font-size:12px;opacity:.8}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>LIVE 마이크 → “늘어짐/멀어짐/파편화” 제너레이팅 + 파형/스펙트럼 시각화 (TouchMe/MIDI 옵션)</h1>
    <p>
      1) <b>Start</b> → 2) <b>Mic On</b> (권한 허용) → 소리가 실시간으로 뭉개지고 파편화됨.<br>
      TouchMe를 쓰면 <b>MIDI Input</b>에서 선택 → 손 세기(velocity)로 변형 강도 맵핑.
    </p>

    <div class="row">
      <button id="startBtn">Start (AudioContext)</button>
      <button id="micBtn" disabled>Mic On</button>
      <button id="micOffBtn" disabled>Mic Off</button>
      <button id="panicBtn" disabled>Panic (Mute)</button>
    </div>

    <div class="row">
      <div>
        <label>MIDI Input (TouchMe)</label>
        <select id="midiIn" disabled><option>Start 후 활성화</option></select>
        <div class="hint">※ WebMIDI는 보통 Chrome에서 안정적.</div>
      </div>
      <div>
        <label>Preset</label>
        <select id="preset" disabled>
          <option value="ghost" selected>Ghost (늘어짐+멀어짐)</option>
          <option value="shatter">Shatter (파편+깨짐)</option>
          <option value="cute">Cute (짧은 그레인, 귀여움)</option>
        </select>
      </div>
    </div>

    <div class="grid">
      <div class="viz">
        <label>Waveform (시간 파형)</label>
        <canvas id="wave"></canvas>
        <div class="hint">마이크 입력/가공 후 신호를 실시간 표시.</div>
      </div>
      <div class="viz">
        <label>Spectrum (주파수 스펙트럼)</label>
        <canvas id="spec"></canvas>
        <div class="hint">멀어짐(필터)·깨짐(크러시) 변화가 주파수 분포로 보임.</div>
      </div>
    </div>

    <div class="split" style="margin-top:12px">
      <div>
        <label>Controls (라이브 변형)</label>

        <div class="row">
          <div>
            <label class="small">Intensity (전체 강도)</label>
            <input id="intensity" type="range" min="0" max="100" value="55" disabled />
          </div>
          <div>
            <label class="small">Distance (멀어짐/유령화)</label>
            <input id="distance" type="range" min="0" max="100" value="60" disabled />
          </div>
        </div>

        <div class="row">
          <div>
            <label class="small">Shatter (파편/랜덤 점프)</label>
            <input id="shatter" type="range" min="0" max="100" value="55" disabled />
          </div>
          <div>
            <label class="small">Crush (비트크러시 느낌)</label>
            <input id="crush" type="range" min="0" max="100" value="45" disabled />
          </div>
        </div>

        <div class="row">
          <div>
            <label class="small">Grain ms (그레인 길이)</label>
            <input id="grainMs" type="range" min="15" max="240" value="90" disabled />
          </div>
          <div>
            <label class="small">Voices (겹침 개수)</label>
            <input id="voices" type="range" min="1" max="6" value="3" disabled />
          </div>
        </div>

        <div class="hint">
          - <b>Ghost</b>: distance↑, grain 길게, voices↑ 하면 “멀어지는 유령 말소리”.<br>
          - <b>Shatter</b>: shatter↑, crush↑ 하면 “말 파편/찢김”.
        </div>
      </div>

      <div>
        <label>Log</label>
        <div id="log" class="mono">대기 중…</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const log = (m) => { logEl.textContent = m + "\n" + logEl.textContent; };

  // ---------- state ----------
  let ctx = null;
  let master = null;

  let micStream = null;
  let micSrc = null;

  // analysis + viz
  let analyser = null;
  let analyserIn = null; // (optional) raw mic
  let raf = null;

  // MIDI
  let midiAccess = null;
  let currentInput = null;
  let midiIntensity = 0.0; // 0..1 (velocity)
  let activeNotes = 0;

  // DSP nodes
  let ring = null;
  let ringLen = 0;
  let ringWrite = 0;

  let proc = null;        // ScriptProcessor for granular-ish playback
  let delay = null;
  let delayFb = null;
  let wet = null;
  let dry = null;
  let lp = null;
  let outGain = null;

  // “crush” (sample&hold / downsample) inside processor
  let crushHold = 0;
  let crushCounter = 0;

  // granular voices
  let voices = [];

  // ---------- helpers ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const norm = (x)=>clamp(x/100,0,1);

  function enableUI(on){
    ["micBtn","micOffBtn","panicBtn","midiIn","preset",
     "intensity","distance","shatter","crush","grainMs","voices"
    ].forEach(id=> $(id).disabled = !on);
  }

  function applyPreset(name){
    // set UI defaults (still adjustable)
    if(name==="ghost"){
      $("intensity").value = 55;
      $("distance").value = 70;
      $("shatter").value = 40;
      $("crush").value = 30;
      $("grainMs").value = 120;
      $("voices").value = 4;
    } else if(name==="shatter"){
      $("intensity").value = 65;
      $("distance").value = 45;
      $("shatter").value = 75;
      $("crush").value = 70;
      $("grainMs").value = 65;
      $("voices").value = 3;
    } else { // cute
      $("intensity").value = 45;
      $("distance").value = 35;
      $("shatter").value = 40;
      $("crush").value = 20;
      $("grainMs").value = 55;
      $("voices").value = 2;
    }
    log("preset: " + name);
  }

  // ---------- Granular-ish processor ----------
  // Strategy:
  // - continuously write mic input into ring buffer
  // - output is sum of N “voices”, each plays a short grain window
  // - each grain reads from ring at a randomized (write - offset) position,
  //   with jitter & optional “distance” (slower drift, more smoothing)
  function resetVoices(n){
    voices = [];
    for(let i=0;i<n;i++){
      voices.push({
        // read head position in ring
        readPos: 0,
        // grain samples remaining
        remain: 0,
        // grain length in samples
        grainLen: 0,
        // per-sample increment (time stretch / drift)
        inc: 1.0,
        // base offset from write head (how far back we read)
        back: 0,
      });
    }
  }

  function windowHann(t){ // 0..1
    return 0.5 - 0.5*Math.cos(2*Math.PI*t);
  }

  function readRing(pos){
    // linear interp
    let p = pos;
    while(p < 0) p += ringLen;
    while(p >= ringLen) p -= ringLen;

    const i0 = p|0;
    const i1 = (i0+1) % ringLen;
    const frac = p - i0;
    return ring[i0]*(1-frac) + ring[i1]*frac;
  }

  function scheduleGrain(v, grainSamples, intensity, dist, shat){
    // how far back to read: base 60~600ms (intensity↑ => 더 멀리 점프 가능)
    const backMs = lerp(70, 700, clamp(0.35*intensity + 0.65*shat,0,1));
    const backSamp = backMs * ctx.sampleRate / 1000;

    // jitter: 파편감 (write head 주변 랜덤 점프)
    const jitterMs = lerp(8, 260, clamp(0.2*intensity + 0.8*shat,0,1));
    const jitterSamp = (Math.random()*2-1) * (jitterMs * ctx.sampleRate / 1000);

    // distance: 더 멀어질수록 더 느리게(늘어짐) + 더 부드럽게(필터는 별도)
    const slow = lerp(1.0, 0.45, dist);

    // inc: time warp (늘어짐) + 약간 불안정
    const wobble = lerp(0.00, 0.06, intensity);
    v.inc = slow + (Math.random()*2-1)*wobble;

    v.grainLen = grainSamples;
    v.remain = grainSamples;

    // readPos = (write - back + jitter)
    v.readPos = ringWrite - backSamp + jitterSamp;

    // per-voice slight variation
    v.readPos += (Math.random()*2-1) * (ctx.sampleRate*0.02);
  }

  function buildDSPGraph(){
    // output mix nodes
    dry = ctx.createGain();
    wet = ctx.createGain();

    // delay + feedback (space)
    delay = ctx.createDelay(1.0);
    delay.delayTime.value = 0.18;

    delayFb = ctx.createGain();
    delayFb.gain.value = 0.35;

    // lowpass for “distance”
    lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 9000;
    lp.Q.value = 0.7;

    outGain = ctx.createGain();
    outGain.gain.value = 0.9;

    // analyser after processing
    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;

    // feedback loop: wet -> delay -> lp -> wet
    // (wet path is: proc -> wet -> delay -> lp -> wet mix + output)
    wet.connect(delay);
    delay.connect(lp);
    lp.connect(wet);        // feedback send (controlled by delayFb below)
    // To control feedback safely: insert gain in loop
    lp.disconnect();
    lp.connect(delayFb);
    delayFb.connect(wet);

    // output sum: dry + wet -> analyser -> out
    const sum = ctx.createGain();
    dry.connect(sum);
    wet.connect(sum);
    sum.connect(analyser);
    analyser.connect(outGain);
    outGain.connect(ctx.destination);
  }

  function buildProcessor(){
    // ScriptProcessor (widely supported in Chrome; ok for this art-prototype)
    const bufSize = 1024;
    proc = ctx.createScriptProcessor(bufSize, 1, 1);

    proc.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);

      if(!ring) {
        output.fill(0);
        return;
      }

      // write input into ring buffer (raw mic capture)
      for(let i=0;i<input.length;i++){
        ring[ringWrite] = input[i];
        ringWrite = (ringWrite + 1) % ringLen;
      }

      // params (UI + MIDI velocity boost)
      const uiInt = norm($("intensity").value);
      const uiDist = norm($("distance").value);
      const uiShat = norm($("shatter").value);
      const uiCrush = norm($("crush").value);
      const gMs = Number($("grainMs").value);

      // MIDI note press increases intensity (and makes it more “performable”)
      const midiBoost = clamp(midiIntensity, 0, 1);
      const intensity = clamp(uiInt*0.65 + midiBoost*0.85, 0, 1);
      const dist = clamp(uiDist*0.70 + midiBoost*0.45, 0, 1);
      const shat = clamp(uiShat*0.75 + midiBoost*0.55, 0, 1);
      const crush = clamp(uiCrush*0.85 + midiBoost*0.35, 0, 1);

      const grainSamples = Math.max(16, (gMs * ctx.sampleRate / 1000) | 0);

      // output synthesis
      for(let i=0;i<output.length;i++){
        let s = 0;

        // schedule grains if needed
        for(const v of voices){
          if(v.remain <= 0){
            // chance to emit new grain: intensity↑ => 더 자주(더 제너레이팅)
            const density = lerp(0.15, 0.95, intensity);
            if(Math.random() < density){
              scheduleGrain(v, grainSamples, intensity, dist, shat);
            } else {
              v.remain = 0;
            }
          }

          if(v.remain > 0){
            const t = 1 - (v.remain / v.grainLen); // 0..1
            const w = windowHann(t);
            const x = readRing(v.readPos);
            s += x * w;
            v.readPos += v.inc;
            v.remain--;
          }
        }

        // normalize by voices
        s *= (voices.length > 0) ? (1.0 / Math.sqrt(voices.length)) : 0;

        // crush via downsample/hold (simple “bitcrush-ish” time quantize)
        // crush↑ => hold length↑ => 더 뭉개짐
        const holdN = Math.max(1, (1 + (crush * 30))|0);
        if(crushCounter <= 0){
          crushHold = s;
          crushCounter = holdN;
        } else {
          crushCounter--;
        }
        s = lerp(s, crushHold, clamp(crush*0.9,0,1));

        // output goes to wet path; also feed some dry for intelligibility
        output[i] = s;
      }
    };

    // connect graph:
    // micSrc -> proc (captures input & generates output) -> wet, dry
    proc.connect(wet);
    proc.connect(dry);

    // dry amount (more distance => less dry)
    function updateMix(){
      const dist = norm($("distance").value);
      const inten = norm($("intensity").value);
      const d = clamp(dist*0.8 + midiIntensity*0.4, 0, 1);
      dry.gain.value = lerp(0.55, 0.08, d);
      wet.gain.value = lerp(0.55, 0.95, clamp(0.35*inten + 0.65*d,0,1));

      // delay & feedback & lowpass
      delay.delayTime.value = lerp(0.08, 0.28, d);
      delayFb.gain.value = clamp(lerp(0.18, 0.82, d), 0, 0.92);
      lp.frequency.value = lerp(14000, 1400, d);

      // overall output
      outGain.gain.value = lerp(0.95, 0.75, d);
    }

    ["intensity","distance","shatter","crush","grainMs","voices","preset"].forEach(id=>{
      $(id).addEventListener("input", () => {
        if(id==="voices"){
          resetVoices(Number($("voices").value));
          log("voices: " + $("voices").value);
        }
        updateMix();
      });
      $(id).addEventListener("change", () => {
        if(id==="preset"){
          applyPreset($("preset").value);
          resetVoices(Number($("voices").value));
          updateMix();
        }
      });
    });

    updateMix();
  }

  // ---------- Mic ----------
  async function micOn(){
    if(!ctx) return;
    if(micStream) return;

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    micSrc = ctx.createMediaStreamSource(micStream);

    // optional analyser for raw mic (not drawn by default, but kept if you want)
    analyserIn = ctx.createAnalyser();
    analyserIn.fftSize = 2048;
    micSrc.connect(analyserIn);

    // feed mic to processor input
    micSrc.connect(proc);

    log("Mic ON ✅ (입력 수집 중)");
  }

  function micOff(){
    if(micSrc){
      try { micSrc.disconnect(); } catch(e){}
      micSrc = null;
    }
    if(micStream){
      try { micStream.getTracks().forEach(t=>t.stop()); } catch(e){}
      micStream = null;
    }
    log("Mic OFF");
  }

  function panic(){
    if(outGain) outGain.gain.value = 0.0;
    setTimeout(()=>{ if(outGain) outGain.gain.value = 0.9; }, 180);
    log("PANIC: mute blip");
  }

  // ---------- MIDI ----------
  async function initMIDI(){
    const sel = $("midiIn");
    sel.innerHTML = "";

    if(!navigator.requestMIDIAccess){
      sel.innerHTML = `<option>WebMIDI 미지원</option>`;
      log("WebMIDI 미지원: Chrome 권장");
      return;
    }
    midiAccess = await navigator.requestMIDIAccess({ sysex:false });
    midiAccess.onstatechange = refreshInputs;
    refreshInputs();
    log("MIDI ready ✅");
  }

  function refreshInputs(){
    const sel = $("midiIn");
    sel.innerHTML = "";
    const inputs = midiAccess ? Array.from(midiAccess.inputs.values()) : [];
    if(inputs.length === 0){
      sel.innerHTML = `<option>연결된 MIDI 없음</option>`;
      return;
    }
    inputs.forEach(inp=>{
      const opt = document.createElement("option");
      opt.value = inp.id;
      opt.textContent = `${inp.name || "MIDI Input"}${inp.manufacturer ? " – " + inp.manufacturer : ""}`;
      sel.appendChild(opt);
    });
    if(!currentInput){
      connectInput(inputs[0].id);
      sel.value = inputs[0].id;
    }
  }

  function connectInput(id){
    if(currentInput) currentInput.onmidimessage = null;
    currentInput = midiAccess.inputs.get(id);
    if(!currentInput) return;

    currentInput.onmidimessage = (msg)=>{
      const [status, d1, d2] = msg.data;
      const cmd = status & 0xF0;

      if(cmd === 0x90){ // note on
        const vel = d2;
        if(vel === 0){
          activeNotes = Math.max(0, activeNotes-1);
        } else {
          activeNotes++;
          midiIntensity = clamp(vel/127, 0, 1);
        }
      } else if(cmd === 0x80){ // note off
        activeNotes = Math.max(0, activeNotes-1);
      }

      // release behavior: fade intensity when no notes
      if(activeNotes === 0){
        // quick decay
        midiIntensity *= 0.85;
      }

      log(`MIDI ${cmd===0x90?"ON":"OFF"} vel=${d2} active=${activeNotes}`);
    };

    log("MIDI input connected: " + (currentInput.name || id));
  }

  // ---------- Visualization ----------
  const waveCv = $("wave");
  const specCv = $("spec");
  const wCtx = waveCv.getContext("2d");
  const sCtx = specCv.getContext("2d");

  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    [waveCv, specCv].forEach(cv=>{
      const rect = cv.getBoundingClientRect();
      cv.width = Math.floor(rect.width * dpr);
      cv.height = Math.floor(rect.height * dpr);
    });
  }

  function draw(){
    if(!analyser) return;
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // waveform
    const tData = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(tData);

    wCtx.clearRect(0,0,waveCv.width,waveCv.height);
    wCtx.globalAlpha = 1;
    wCtx.lineWidth = 2*dpr;
    wCtx.strokeStyle = "#eaeaea"; // (ok to specify? user didn’t forbid; still minimal)
    wCtx.beginPath();
    const mid = waveCv.height/2;
    for(let i=0;i<tData.length;i++){
      const x = (i/(tData.length-1))*waveCv.width;
      const v = (tData[i]-128)/128;
      const y = mid + v*(waveCv.height*0.40);
      if(i===0) wCtx.moveTo(x,y);
      else wCtx.lineTo(x,y);
    }
    wCtx.stroke();

    // spectrum
    const fData = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(fData);

    sCtx.clearRect(0,0,specCv.width,specCv.height);
    const bars = 96;
    const step = Math.floor(fData.length / bars);
    const bw = specCv.width / bars;

    for(let i=0;i<bars;i++){
      let sum = 0;
      for(let k=0;k<step;k++) sum += fData[i*step+k];
      const v = sum/(step*255); // 0..1
      const h = v * specCv.height * 0.95;
      const x = i*bw;
      const y = specCv.height - h;

      sCtx.fillStyle = "#eaeaea";
      sCtx.globalAlpha = 0.18 + 0.75*v;
      sCtx.fillRect(x+1*dpr, y, Math.max(1, bw-2*dpr), h);
    }
    sCtx.globalAlpha = 1;

    raf = requestAnimationFrame(draw);
  }

  // ---------- UI events ----------
  $("startBtn").addEventListener("click", async ()=>{
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // ring buffer (4 seconds)
    ringLen = Math.floor(ctx.sampleRate * 4.0);
    ring = new Float32Array(ringLen);
    ringWrite = 0;

    buildDSPGraph();
    resetVoices(Number($("voices").value));
    buildProcessor();

    enableUI(true);
    $("micBtn").disabled = false;
    $("micOffBtn").disabled = true;
    $("panicBtn").disabled = false;

    // preset init
    applyPreset($("preset").value);
    resetVoices(Number($("voices").value));

    await initMIDI();

    // viz
    resizeCanvas();
    if(raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(draw);

    log("Start ✅ AudioContext ready");
    $("startBtn").disabled = true;
  });

  $("micBtn").addEventListener("click", async ()=>{
    try{
      await micOn();
      $("micBtn").disabled = true;
      $("micOffBtn").disabled = false;
    }catch(e){
      log("Mic error: " + e.message);
    }
  });

  $("micOffBtn").addEventListener("click", ()=>{
    micOff();
    $("micBtn").disabled = false;
    $("micOffBtn").disabled = true;
  });

  $("panicBtn").addEventListener("click", panic);

  $("midiIn").addEventListener("change", (e)=> connectInput(e.target.value));

  $("preset").addEventListener("change", ()=>{
    applyPreset($("preset").value);
    resetVoices(Number($("voices").value));
  });

  window.addEventListener("resize", resizeCanvas);

  // start disabled until Start
  enableUI(false);
})();
</script>
</body>
</html>
