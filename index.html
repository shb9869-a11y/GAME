<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>TouchMe â€“ Voice Granular Shatter (REC + MIDI)</title>
  <style>
    :root{color-scheme:dark}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0b0b0b;color:#eee;margin:0;padding:20px}
    .card{max-width:920px;margin:0 auto;background:#141414;border:1px solid #2a2a2a;border-radius:16px;padding:16px}
    h1{font-size:18px;margin:0 0 10px}
    p{opacity:.9;line-height:1.55;margin:8px 0}
    label{display:block;margin-top:10px}
    input,select,button{width:100%;margin-top:6px;padding:12px;border-radius:12px;border:1px solid #333;background:#0f0f0f;color:#eee}
    button{cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > *{flex:1;min-width:180px}
    .hint{font-size:12px;opacity:.78;margin-top:10px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:#0f0f0f;border:1px solid #2a2a2a;border-radius:12px;padding:12px;white-space:pre-wrap}
    .tinyrow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .tinyrow .mini{flex:1;min-width:210px}
    .mini span{display:block;font-size:12px;opacity:.8;margin-top:10px}
    .mini input[type="range"]{padding:0}
  </style>
</head>
<body>
  <div class="card">
    <h1>TouchMe â†’ â€œëŠ˜ì–´ì§€ê³  ë©€ì–´ì§€ë©° íŒŒí¸ì ìœ¼ë¡œ ë­‰ê·¸ëŸ¬ì§„â€ ëª©ì†Œë¦¬ (REC + MIDI)</h1>

    <p>
      1) <b>Start Audio</b> â†’ 2) <b>Record Voice</b>ë¡œ ë„¤ ëª©ì†Œë¦¬ ë…¹ìŒ(ë˜ëŠ” íŒŒì¼ ì—…ë¡œë“œ) â†’ 3) <b>MIDI Input</b>ì—ì„œ TouchMe ì„ íƒ â†’ ì†ëŒ€ë©´ ì¬ìƒ/ë³€í˜•.
      <br/>â€» WebMIDIëŠ” ë³´í†µ <b>Chrome</b>ì—ì„œ ê°€ì¥ ì•ˆì •ì .
    </p>

    <div class="row">
      <button id="startBtn">Start Audio (í•„ìˆ˜)</button>
      <button id="recBtn" disabled>Record Voice</button>
      <button id="stopRecBtn" disabled>Stop Record</button>
      <button id="panicBtn" disabled>Panic (Stop)</button>
    </div>

    <label>ë‚´ ìŒì› ì—…ë¡œë“œ (wav/mp3/ogg/webm)</label>
    <input id="file" type="file" accept="audio/*" disabled />

    <div class="row">
      <div>
        <label>MIDI Input (TouchMe)</label>
        <select id="midiIn" disabled><option>Start Audio í›„ í™œì„±í™”</option></select>
      </div>
      <div>
        <label>ìºë¦­í„°(í”„ë¦¬ì…‹)</label>
        <select id="preset" disabled>
          <option value="ghost" selected>ìœ ë ¹/ë©€ì–´ì§ (ëŠ˜ì–´ì§+ì”í–¥)</option>
          <option value="shatter">íŒŒí¸/ì°¢ê¹€ (ë” ì¡°ê°+í¬ëŸ¬ì‹œ)</option>
          <option value="cute">ê·€ì—½ê²Œ ë­‰ê·¸ëŸ¬ì§ (ì§§ì€ ê·¸ë ˆì¸)</option>
        </select>
      </div>
    </div>

    <div class="tinyrow">
      <div class="mini">
        <span>íŒŒí¸ê° (Jitter)</span>
        <input id="jitter" type="range" min="0" max="100" value="55" disabled />
      </div>
      <div class="mini">
        <span>ë©€ì–´ì§ (Distance)</span>
        <input id="distance" type="range" min="0" max="100" value="60" disabled />
      </div>
      <div class="mini">
        <span>ê¹¨ì§ (Crush)</span>
        <input id="crush" type="range" min="0" max="100" value="50" disabled />
      </div>
    </div>

    <div class="hint">
      - ì†ì„ ë” â€œì„¸ê²Œâ€ ëˆ„ë¥¼ìˆ˜ë¡: ë” ëŠ˜ì–´ì§/ë” ë©€ì–´ì§/ë” íŒŒí¸í™”(velocity ê¸°ë°˜).<br/>
      - â€œë§ì˜ ê²°â€ì„ ë‚¨ê¸°ê³  ì‹¶ìœ¼ë©´: <b>Crush</b>ë¥¼ ë‚®ì¶”ê³ , <b>Distance</b>ë¥¼ ì˜¬ë¦¬ëŠ” ê²Œ ìì—°ìŠ¤ëŸ¬ì›€.
    </div>

    <label>ë¡œê·¸</label>
    <div id="log" class="mono">ëŒ€ê¸° ì¤‘â€¦</div>
  </div>

  <!-- Tone.js -->
  <script src="https://unpkg.com/tone@15.1.22/build/Tone.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    const log = (msg) => { logEl.textContent = msg + "\n" + logEl.textContent; };

    // ---------- helpers ----------
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function norm01(v){ return clamp(v/127, 0, 1); }

    // ---------- Audio graph ----------
    // GrainPlayer -> Crusher -> Delay -> Reverb -> LPF -> Out
    const crusher = new Tone.BitCrusher(5);
    const delay = new Tone.FeedbackDelay("8n", 0.30);
    const reverb = new Tone.Reverb({ decay: 6.0, preDelay: 0.02, wet: 0.35 });
    const lp = new Tone.Filter(11000, "lowpass");
    const out = new Tone.Gain(0.95).toDestination();

    crusher.connect(delay);
    delay.connect(reverb);
    reverb.connect(lp);
    lp.connect(out);

    let player = null;
    let bufferLoaded = false;
    let activeNotes = new Map(); // note -> true

    function ensurePlayer(){
      if(player) return player;
      player = new Tone.GrainPlayer({
        url: null,
        loop: true,
        autostart: false,
        grainSize: 0.10,
        overlap: 0.06
      });
      player.connect(crusher);
      return player;
    }

    // ---------- Presets ----------
    function applyPreset(name){
      if(!player) return;

      if(name === "cute"){
        player.grainSize = 0.05;
        player.overlap = 0.03;
        player.playbackRate = 1.0;
        player.detune = 0;
        delay.delayTime.value = 0.12;
        delay.feedback.value = 0.18;
        reverb.decay = 2.2;
        reverb.wet.value = 0.22;
        lp.frequency.value = 14000;
        crusher.bits = 6;
      } else if(name === "ghost"){
        player.grainSize = 0.12;
        player.overlap = 0.08;
        player.playbackRate = 0.85;
        player.detune = -120;
        delay.delayTime.value = 0.22;
        delay.feedback.value = 0.35;
        reverb.decay = 7.0;
        reverb.wet.value = 0.42;
        lp.frequency.value = 9000;
        crusher.bits = 5;
      } else if(name === "shatter"){
        player.grainSize = 0.04;
        player.overlap = 0.015;
        player.playbackRate = 1.05;
        player.detune = 80;
        delay.delayTime.value = 0.09;
        delay.feedback.value = 0.55;
        reverb.decay = 1.6;
        reverb.wet.value = 0.18;
        lp.frequency.value = 11000;
        crusher.bits = 3;
      }
      log(`preset: ${name}`);
    }

    // ---------- Mapping (MIDI -> â€œíŒŒí¸/ëŠ˜ì–´ì§/ë©€ì–´ì§â€) ----------
    function noteToPosition(note){
      // 0..127 -> 0..1 (ì‚´ì§ ë¹„ì„ í˜•)
      const x = clamp(note / 127, 0, 1);
      return Math.pow(x, 1.15);
    }

    function uiJitter(){ return clamp(Number($("jitter").value)/100, 0, 1); }
    function uiDistance(){ return clamp(Number($("distance").value)/100, 0, 1); }
    function uiCrush(){ return clamp(Number($("crush").value)/100, 0, 1); }

    function startGrains(note, velocity){
      if(!bufferLoaded || !player) return;

      const v = norm01(velocity);
      const preset = $("preset").value;

      // UI knobs (0..1)
      const j = uiJitter();
      const d = uiDistance();
      const c = uiCrush();

      // Position jitter (íŒŒí¸ê°)
      const basePos = noteToPosition(note);
      const jitterAmt = lerp(0.02, 0.28, clamp(0.35*j + 0.65*v, 0, 1));
      const jitter = jitterAmt * (Math.random()*2 - 1);

      const segLen = lerp(0.10, 0.34, clamp(0.25 + 0.75*v, 0, 1)); // ê°•í• ìˆ˜ë¡ êµ¬ê°„ ê¸¸ì´ ëŠ˜ë ¤ "ëŠ˜ì–´ì§"
      player.loopStart = clamp(basePos + jitter, 0, 0.97);
      player.loopEnd   = clamp(player.loopStart + segLen, 0.03, 1.0);

      // Grain params (ê°•í• ìˆ˜ë¡ ë­‰ê°œì§)
      const gSize = lerp(0.03, 0.22, clamp(0.25 + 0.75*v, 0, 1));
      const ovlp  = lerp(0.008, 0.16, clamp(0.20 + 0.80*v, 0, 1));

      // í”„ë¦¬ì…‹ì— ë”°ë¼ ì§ˆê° ì¡°ê¸ˆ ë‹¤ë¥´ê²Œ
      if(preset === "ghost"){
        player.grainSize = clamp(gSize * lerp(0.9, 1.25, d), 0.02, 0.28);
        player.overlap   = clamp(ovlp  * lerp(1.0, 1.35, d), 0.005, 0.22);

        // playbackRate ëŠë ¤ì§(ëŠ˜ì–´ì§) + detune í•˜ê°•(ìœ ë ¹í™”)
        const slow = clamp(lerp(0.95, 0.40, 0.65*v + 0.35*d), 0.30, 1.10);
        player.playbackRate = slow;
        player.detune = -80 - (520*(0.55*v + 0.45*d));

      } else if(preset === "cute"){
        player.grainSize = clamp(gSize * 0.7, 0.02, 0.18);
        player.overlap   = clamp(ovlp  * 0.7, 0.005, 0.14);
        player.playbackRate = clamp(1.0 - 0.12*(0.7*v), 0.78, 1.12);
        player.detune = 0 + 140*(0.6*v);

      } else { // shatter
        player.grainSize = clamp(gSize * lerp(0.55, 0.95, c), 0.02, 0.20);
        player.overlap   = clamp(ovlp  * 0.55, 0.005, 0.10);
        player.playbackRate = clamp(1.05 - 0.45*(0.8*v), 0.45, 1.2);
        player.detune = 120 + 620*(0.55*v + 0.45*j);
      }

      // â€œë©€ì–´ì§â€ (Distance): LPF, Reverb, Delay, Volume
      const dist = clamp(0.35*d + 0.65*v, 0, 1);
      lp.frequency.value = clamp(lerp(15000, 1600, dist), 800, 16000);
      reverb.decay = lerp(1.6, 8.0, dist);
      reverb.wet.value = clamp(lerp(0.10, 0.78, dist), 0, 0.95);
      delay.feedback.value = clamp(lerp(0.10, 0.75, dist), 0, 0.92);

      // â€œê¹¨ì§â€ (Crush): Bit depth
      const crushAmt = clamp(0.50*c + 0.50*v, 0, 1);
      const bits = Math.round(clamp(lerp(7, 1.6, crushAmt), 1, 8));
      crusher.bits = bits;

      // â€œë©€ì–´ì§â€ ë³¼ë¥¨(ì›ë³¸ ê²° ìœ ì§€í•˜ë ¤ë©´ ë„ˆë¬´ ë‚®ì¶”ì§€ ë§ ê²ƒ)
      player.volume.value = -8 - 22*dist;

      if(!activeNotes.get(note)){
        try { player.start(); } catch(e){}
        activeNotes.set(note, true);
      }

      log(`NOTE ON  note=${note} vel=${velocity}  seg=${(player.loopEnd-player.loopStart).toFixed(2)}  grain=${player.grainSize.toFixed(3)}  bits=${crusher.bits}  LPF=${Math.round(lp.frequency.value)}`);
    }

    function stopGrains(note){
      activeNotes.delete(note);
      if(activeNotes.size === 0 && player){
        setTimeout(()=>{ try{ player.stop(); }catch(e){} }, 70);
      }
      log(`NOTE OFF note=${note} (active=${activeNotes.size})`);
    }

    // ---------- Recorder (Mic -> Blob -> GrainPlayer) ----------
    let mediaStream = null;
    let mediaRecorder = null;
    let chunks = [];

    async function startRecord(){
      ensurePlayer();
      chunks = [];

      mediaStream = await navigator.mediaDevices.getUserMedia({ audio:true });

      // mimeTypeì€ ë¸Œë¼ìš°ì €ë§ˆë‹¤ ë‹¤ë¦„: ê°€ëŠ¥í•œ ê°’ìœ¼ë¡œ fallback
      let options = {};
      if(MediaRecorder.isTypeSupported("audio/webm;codecs=opus")) options.mimeType = "audio/webm;codecs=opus";
      else if(MediaRecorder.isTypeSupported("audio/webm")) options.mimeType = "audio/webm";
      else if(MediaRecorder.isTypeSupported("audio/ogg;codecs=opus")) options.mimeType = "audio/ogg;codecs=opus";

      mediaRecorder = new MediaRecorder(mediaStream, options);

      mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = async ()=>{
        const blob = new Blob(chunks, { type: mediaRecorder.mimeType || "audio/webm" });
        const url = URL.createObjectURL(blob);

        bufferLoaded = false;
        log("Loading recorded voice...");
        try{
          await player.load(url);
          bufferLoaded = true;
          applyPreset($("preset").value);
          log(`Recorded voice loaded âœ… (dur ~ ${player.buffer.duration.toFixed(2)}s)`);
        }catch(e){
          log("Load recorded voice FAILED: " + e.message);
        }

        try { mediaStream.getTracks().forEach(t=>t.stop()); } catch(e){}
        mediaStream = null;
      };

      mediaRecorder.start();
      log("Recording... ğŸ™ï¸ (ë§/í˜¸í¡/ì†ì‚­ì„ ì¶”ì²œ)");
    }

    function stopRecord(){
      if(mediaRecorder && mediaRecorder.state !== "inactive"){
        mediaRecorder.stop();
        log("Stop recording.");
      }
    }

    // ---------- WebMIDI ----------
    let midiAccess = null;
    let currentInput = null;

    async function initMIDI(){
      if(!navigator.requestMIDIAccess){
        $("midiIn").innerHTML = `<option>WebMIDI ë¯¸ì§€ì› ë¸Œë¼ìš°ì €</option>`;
        log("WebMIDI ë¯¸ì§€ì›: Chrome ê¶Œì¥");
        return;
      }
      midiAccess = await navigator.requestMIDIAccess({ sysex:false });
      refreshInputs();
      midiAccess.onstatechange = refreshInputs;
      log("MIDI ready âœ…");
    }

    function refreshInputs(){
      const sel = $("midiIn");
      sel.innerHTML = "";
      const inputs = Array.from(midiAccess.inputs.values());

      if(inputs.length === 0){
        sel.innerHTML = `<option>ì—°ê²°ëœ MIDI ì—†ìŒ</option>`;
        return;
      }
      inputs.forEach((inp)=>{
        const opt = document.createElement("option");
        opt.value = inp.id;
        opt.textContent = `${inp.name || "MIDI Input"}${inp.manufacturer ? " â€“ " + inp.manufacturer : ""}`;
        sel.appendChild(opt);
      });

      if(!currentInput){
        connectInput(inputs[0].id);
        sel.value = inputs[0].id;
      }
    }

    function connectInput(id){
      if(currentInput) currentInput.onmidimessage = null;
      currentInput = midiAccess.inputs.get(id);
      if(!currentInput) return;

      currentInput.onmidimessage = (msg)=>{
        const [status, d1, d2] = msg.data;
        const cmd = status & 0xF0;

        if(cmd === 0x90){ // note on
          const note = d1;
          const vel = d2;
          if(vel === 0) stopGrains(note);
          else startGrains(note, vel);
        } else if(cmd === 0x80){ // note off
          stopGrains(d1);
        }
      };

      log(`MIDI input connected: ${currentInput.name || id}`);
    }

    // ---------- UI wiring ----------
    function setEnabledAll(on){
      $("recBtn").disabled = !on;
      $("stopRecBtn").disabled = true;
      $("panicBtn").disabled = !on;
      $("file").disabled = !on;
      $("midiIn").disabled = !on;
      $("preset").disabled = !on;
      $("jitter").disabled = !on;
      $("distance").disabled = !on;
      $("crush").disabled = !on;
    }

    $("startBtn").addEventListener("click", async ()=>{
      await Tone.start();
      ensurePlayer();
      reverb.generate();
      setEnabledAll(true);
      await initMIDI();
      log("Audio started âœ…  (REC/íŒŒì¼/MIDI ì‚¬ìš© ê°€ëŠ¥)");
      $("startBtn").disabled = true;
    });

    $("preset").addEventListener("change", (e)=> applyPreset(e.target.value));

    $("panicBtn").addEventListener("click", ()=>{
      activeNotes.clear();
      try { if(player) player.stop(); } catch(e){}
      log("PANIC: stop");
    });

    $("midiIn").addEventListener("change", (e)=> connectInput(e.target.value));

    $("file").addEventListener("change", async (e)=>{
      const f = e.target.files?.[0];
      if(!f) return;

      ensurePlayer();
      const url = URL.createObjectURL(f);
      bufferLoaded = false;

      log(`Loading sample: ${f.name}`);
      try{
        await player.load(url);
        bufferLoaded = true;
        applyPreset($("preset").value);
        log(`Loaded âœ… duration ~ ${player.buffer.duration.toFixed(2)}s`);
      }catch(err){
        log("Load FAILED: " + err.message);
      }
    });

    $("recBtn").addEventListener("click", async ()=>{
      try{
        $("recBtn").disabled = true;
        $("stopRecBtn").disabled = false;
        await startRecord();
      }catch(e){
        log("Record error: " + e.message);
        $("recBtn").disabled = false;
        $("stopRecBtn").disabled = true;
      }
    });

    $("stopRecBtn").addEventListener("click", ()=>{
      $("stopRecBtn").disabled = true;
      $("recBtn").disabled = false;
      stopRecord();
    });

    // start disabled until Start Audio
    setEnabledAll(false);
  </script>
</body>
</html>
