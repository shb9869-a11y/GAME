<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TouchMe – Granular Voice Smear</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#0b0b0b;color:#eee;margin:0;padding:20px}
    .card{max-width:860px;margin:0 auto;background:#141414;border:1px solid #2a2a2a;border-radius:14px;padding:16px}
    h1{font-size:18px;margin:0 0 10px}
    p{opacity:.9;line-height:1.5}
    label{display:block;margin-top:10px}
    input,select,button{width:100%;margin-top:6px;padding:10px;border-radius:10px;border:1px solid #333;background:#0f0f0f;color:#eee}
    button{cursor:pointer}
    .row{display:flex;gap:10px}
    .row > *{flex:1}
    .hint{font-size:12px;opacity:.75;margin-top:8px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:#0f0f0f;border:1px solid #2a2a2a;border-radius:10px;padding:10px;white-space:pre-wrap}
  </style>
</head>
<body>
  <div class="card">
    <h1>TouchMe → “늘어지고 멀어지는” 그레뉼러 말소리 파편</h1>
    <p>
      1) <b>Start Audio</b> 누르고<br/>
      2) 음원 업로드(말소리/숨/속삭임 추천)<br/>
      3) MIDI 장치에서 TouchMe 선택 → 손대면 파편화 재생.
    </p>

    <div class="row">
      <button id="startBtn">Start Audio (필수)</button>
      <button id="panicBtn">Panic (Stop)</button>
    </div>

    <label>내 음원 업로드 (wav/mp3/ogg)</label>
    <input id="file" type="file" accept="audio/*" />

    <label>MIDI Input</label>
    <select id="midiIn"><option>검색 중...</option></select>

    <label>캐릭터(프리셋)</label>
    <select id="preset">
      <option value="cute">귀엽게 뭉그러짐 (짧은 그레인 + 반짝)</option>
      <option value="ghost" selected>유령/멀어짐 (늘어짐 + 리버브)</option>
      <option value="shatter">파편/찢김 (비트크러시 + 짧은 딜레이)</option>
    </select>

    <div class="hint">
      - Chrome 권장(WebMIDI). TouchMe는 MIDI 컨트롤러로 인식돼요. :contentReference[oaicite:2]{index=2}<br/>
      - “늘어짐/시간왜곡”은 GrainPlayer(Granular) 기반. :contentReference[oaicite:3]{index=3}
    </div>

    <label>로그</label>
    <div id="log" class="mono">대기 중…</div>
  </div>

  <!-- Tone.js (Granular + FX) -->
  <script src="https://unpkg.com/tone@15.1.22/build/Tone.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);
    const logEl = $("log");
    const log = (msg) => { logEl.textContent = msg + "\n" + logEl.textContent; };

    let midiAccess = null;
    let currentInput = null;

    // --- Audio graph (Tone.js) ---
    // GrainPlayer (granular) -> bitcrusher -> delay -> reverb -> out
    const crusher = new Tone.BitCrusher(4);           // bits: 1~8
    const delay = new Tone.FeedbackDelay("8n", 0.35); // feedback: 0~0.9
    const reverb = new Tone.Reverb({ decay: 6, preDelay: 0.02, wet: 0.35 });

    // “멀어짐” 느낌용 필터(고역 깎기) + 볼륨
    const lp = new Tone.Filter(12000, "lowpass");
    const out = new Tone.Gain(0.9).toDestination();

    crusher.connect(delay);
    delay.connect(reverb);
    reverb.connect(lp);
    lp.connect(out);

    // GrainPlayer는 URL/Buffer 필요. 업로드 후 생성.
    let player = null;
    let bufferLoaded = false;

    // 상태
    let activeNotes = new Map(); // note -> started?

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function normVelocity(v){ return clamp(v / 127, 0, 1); }

    function applyPreset(name){
      if(!player) return;

      if(name === "cute"){
        // 짧은 그레인 + 밝은 느낌
        player.grainSize = 0.05;
        player.overlap = 0.03;
        player.playbackRate = 1.0;
        player.detune = 0;
        crusher.bits = 6;
        delay.delayTime.value = 0.12;
        delay.feedback.value = 0.18;
        reverb.decay = 2.2;
        reverb.wet.value = 0.22;
        lp.frequency.value = 14000;
      } else if(name === "ghost"){
        // 늘어짐 + 멀어짐 + 잔향
        player.grainSize = 0.12;
        player.overlap = 0.08;
        player.playbackRate = 0.85; // 살짝 느리게
        player.detune = -120;       // 살짝 낮춰서 유령화
        crusher.bits = 5;
        delay.delayTime.value = 0.22;
        delay.feedback.value = 0.35;
        reverb.decay = 7.0;
        reverb.wet.value = 0.42;
        lp.frequency.value = 9000;
      } else if(name === "shatter"){
        // 파편/찢김(크러시+짧은 딜레이)
        player.grainSize = 0.04;
        player.overlap = 0.01;
        player.playbackRate = 1.05;
        player.detune = 80;
        crusher.bits = 3;
        delay.delayTime.value = 0.09;
        delay.feedback.value = 0.55;
        reverb.decay = 1.6;
        reverb.wet.value = 0.18;
        lp.frequency.value = 11000;
      }
      log(`preset: ${name}`);
    }

    function ensurePlayer(){
      if(player) return player;
      player = new Tone.GrainPlayer({
        url: null,
        loop: true,
        autostart: false,
        grainSize: 0.12,
        overlap: 0.08
      });
      player.connect(crusher);
      return player;
    }

    // MIDI note -> sample position (0~1)로 매핑해서 "파편적으로" 다른 조각에서 재생
    function noteToPosition(note){
      // 0~127 => 0~1 (약간 비선형, 중간에 더 몰리게)
      const x = clamp(note / 127, 0, 1);
      return Math.pow(x, 1.2);
    }

    function startGrains(note, velocity){
      if(!bufferLoaded || !player) return;
      const v = normVelocity(velocity);

      // 손 세기가 강할수록 더 “뭉그러짐/파편화/멀어짐”
      // v: 0(약) ~ 1(강)
      const preset = $("preset").value;

      // 공통: position 랜덤 흔들림(파편감)
      const basePos = noteToPosition(note);
      const jitter = (0.06 + 0.20*v) * (Math.random()*2 - 1); // 강할수록 더 흔들
      player.loopStart = clamp(basePos + jitter, 0, 0.95);
      player.loopEnd   = clamp(player.loopStart + (0.08 + 0.22*v), 0.05, 1.0);

      // 시간/공간 왜곡
      // 강할수록 playbackRate는 더 느려지거나 불안정
      if(preset === "ghost"){
        player.playbackRate = clamp(0.95 - 0.35*v, 0.35, 1.1);
        player.detune = -80 - 380*v; // 강할수록 더 낮아짐
      } else if(preset === "cute"){
        player.playbackRate = clamp(1.0 - 0.12*v, 0.75, 1.1);
        player.detune = 0 + 120*v;
      } else { // shatter
        player.playbackRate = clamp(1.05 - 0.25*v, 0.55, 1.2);
        player.detune = 120 + 520*v;
      }

      // 그레뉼러 파라미터(뭉그러짐)
      player.grainSize = clamp(0.03 + 0.18*v, 0.02, 0.25);
      player.overlap   = clamp(0.01 + 0.14*v, 0.005, 0.2);

      // FX (강할수록 멀어짐/깨짐)
      crusher.bits = Math.round(clamp(7 - 5*v, 1, 8)); // 강하면 bits ↓ (더 깨짐)
      delay.feedback.value = clamp(0.15 + 0.65*v, 0, 0.9);
      reverb.wet.value = clamp(0.10 + 0.65*v, 0, 0.9);
      lp.frequency.value = clamp(15000 - 9000*v, 1200, 16000);

      // 볼륨: 강할수록 조금 줄여서 "멀어지는" 느낌도 같이
      player.volume.value = -10 - 18*v;

      if(!activeNotes.get(note)){
        player.start();
        activeNotes.set(note, true);
      }

      log(`NOTE ON  note=${note} vel=${velocity}  pos=${player.loopStart.toFixed(2)}~${player.loopEnd.toFixed(2)}  bits=${crusher.bits}`);
    }

    function stopGrains(note){
      // 멀티터치(폴리)라면 진짜로는 “모든 노트가 떼어졌을 때”만 stop 하는 편이 자연스러움
      activeNotes.delete(note);
      if(activeNotes.size === 0 && player){
        // 살짝 잔향 남기고 멈춤
        setTimeout(()=>{ try{ player.stop(); }catch(e){} }, 60);
      }
      log(`NOTE OFF note=${note} (active=${activeNotes.size})`);
    }

    // --- UI ---
    $("preset").addEventListener("change", (e)=> applyPreset(e.target.value));

    $("panicBtn").addEventListener("click", ()=>{
      activeNotes.clear();
      try { if(player) player.stop(); } catch(e){}
      log("PANIC: stop");
    });

    $("startBtn").addEventListener("click", async ()=>{
      await Tone.start();
      log("Audio started ✅  (이제 MIDI/파일 업로드 가능)");
      // 리버브 초기화는 약간 시간 걸릴 수 있음
      reverb.generate();
    });

    $("file").addEventListener("change", async (e)=>{
      const f = e.target.files?.[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      ensurePlayer();
      bufferLoaded = false;

      log(`Loading sample: ${f.name}`);
      await player.load(url);
      bufferLoaded = true;
      applyPreset($("preset").value);
      log(`Loaded ✅ duration ~ ${player.buffer.duration.toFixed(2)}s`);
    });

    // --- WebMIDI ---
    async function initMIDI(){
      if(!navigator.requestMIDIAccess){
        $("midiIn").innerHTML = `<option>WebMIDI 미지원 브라우저</option>`;
        log("WebMIDI 미지원: Chrome 권장");
        return;
      }
      midiAccess = await navigator.requestMIDIAccess({ sysex:false });
      refreshInputs();
      midiAccess.onstatechange = refreshInputs;
      log("MIDI ready ✅");
    }

    function refreshInputs(){
      const sel = $("midiIn");
      sel.innerHTML = "";
      const inputs = Array.from(midiAccess.inputs.values());

      if(inputs.length === 0){
        sel.innerHTML = `<option>연결된 MIDI 없음</option>`;
        return;
      }
      inputs.forEach((inp, idx)=>{
        const opt = document.createElement("option");
        opt.value = inp.id;
        opt.textContent = `${inp.name || "MIDI Input"}${inp.manufacturer ? " – " + inp.manufacturer : ""}`;
        sel.appendChild(opt);
      });

      // 자동 첫 선택
      if(!currentInput){
        connectInput(inputs[0].id);
        sel.value = inputs[0].id;
      }
    }

    function connectInput(id){
      if(currentInput) currentInput.onmidimessage = null;
      currentInput = midiAccess.inputs.get(id);
      if(!currentInput) return;

      currentInput.onmidimessage = (msg)=>{
        const [status, data1, data2] = msg.data;
        const cmd = status & 0xF0;

        // NoteOn (0x90) / NoteOff (0x80)
        if(cmd === 0x90){
          const note = data1;
          const vel  = data2;
          if(vel === 0) stopGrains(note);
          else startGrains(note, vel);
        } else if(cmd === 0x80){
          stopGrains(data1);
        }

        // (선택) CC로 “손 세기”가 따로 오면 여기서 매핑 가능
        // if(cmd === 0xB0){ ... }
      };

      log(`MIDI input connected: ${currentInput.name || id}`);
    }

    $("midiIn").addEventListener("change", (e)=> connectInput(e.target.value));

    initMIDI();
  </script>
</body>
</html>
